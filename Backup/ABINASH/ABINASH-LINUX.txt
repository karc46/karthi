===================================================================================================================================================================================================
modbus
--------


unset MALLOC_CHECK_
export MALLOC_CHECK_=3


sudo apt update
sudo apt install libmodbus-dev
gcc -o modbus_master master.c -lmodbus
gcc -o master master.c -lmodbus
gcc slave.c -o slave -lmodbus


git clone https://github.com/stephane/libmodbus.git
cd libmodbus
./autogen.sh

sudo apt-get update
sudo apt-get install libtool automake autoconf m4
sudo apt-get update
sudo apt-get install g++-arm-linux-gnueabihf


./configure --host=arm-linux-gnueabihf --prefix=/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib --disable-tests

autoreconf -i

make -j$(nproc)

sudo make install

static
======

 ./configure --host=arm-linux-gnueabihf --prefix=/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib  --disable-tests --enable-static  --disable-shared


./configure --host=arm-linux-gnueabihf --prefix=/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib  --disable-tests --enable-static --disable-shared CFLAGS="-static" LDFLAGS="-static -lm"

make -j$(nproc)
make install


single line command
-------------------

arm-linux-gnueabihf-gcc modbus_can.c -o modbus_can -L/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib/lib -I/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib/include -lmodbus

static
--------

arm-linux-gnueabihf-gcc -o  modbus_can modbus_can.c  -I/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib/include -L/home/zumi/Abinash/am4376_board_bringup_new_project/modbus/modbus_can/lib/lib -static -lmodbus -lm

gcc -o modbus_can modbus_can.c -lmodbus

sudo apt-get install libmodbus-dev

gcc -o master master.c -lmodbus


arm-linux-gnueabihf-gcc -static am437x_modbus_can.c -o am437x_TCP_ETU_COMMUNICATE -lpthread


arm-linux-gnueabihf-gcc -static -I/home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work/am437x_evm-linux-gnueabi/linux-ti-staging/5.4.106+gitAUTOINC+023faefa70-r3a.arago5.tisdk1.1/git/include/uapi -I/home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work/am437x_evm-linux-gnueabi/linux-ti-staging/5.4.106+gitAUTOINC+023faefa70-r3a.arago5.tisdk1.1/git/include 4.c



git clone https://github.com/stephane/libmodbus.git
cd libmodbus
./autogen.sh
sudo apt-get update
sudo apt-get install libtool automake autoconf m4
./configure --host=arm-linux-gnueabihf
autoreconf -i
make
sudo make install



=====================================================================================================================================================================










Listen carefully. I will give you the CVE number and the kernel version, so you need to perform an extensive search across multiple websites. Once you find the relevant information, provide me with a 3-4 line summary about whether a patch is available for this issue. If you can't find the patch link, please explain the solution in 2-3 lines, and specify why this approach is necessary.


google drive soure code for kenrle 
=================================

https://drive.google.com/drive/folders/1ejhBrni39jaXJPeOu5BBg6n9_7Vy7HlU?usp=sharing






cve links
=========
https://ubuntu.com/security/livepatch



"cifs-utils-5.10 - CVE-2014-2830"

I need a document that provides proper details about the above library and CVE. The document should include the following sections:


CVE Number : cifs-utils-5.10 - CVE-2014-2830

CVE Issue:

Description:

Dependency Modules: 


Conclusion:

Required : Provide the Reason

Not Required : Provide the Reason

Test Methods:


Dependency Analysis
-------------------
List all module details related to this library.
Identify which modules can access this library, including the stack's top and lower layers.
List the modules managed by this library.
Requirement Analysis
--------------------
Explain the use case of this library in real-time applications.
Determine whether this library is necessary or if it can be removed.
Provide details about the library's use cases and working principles.
Testing Methodology
-------------------
If the library is required, find the patch for the CVE, apply it, and recheck the system.
Verify whether the CVE has been resolved after applying the patch.






export PATH=$HOME/.local/bin:$PATH

echo 'export PATH=$HOME/.local/bin:$PATH' >> ~/.bashrc
source ~/.bashrc


bitbake xz -c clean
bitbake xz -c fetch
bitbake xz






Total CVE Counts per Library
Library	Total CVEs
golang-runtime-1.14.15	18
expat-2.2.9	15
libxml2-2.9.10	8
mbed_tls3.5.0	5
ntp-4.2.8p15	5
glibc2.30	3
systemd244	2
systemd244.5	2
glib2.62.6	2
net-snmp5.8	2
libarchive3.4.2	2
elfutils0.178	2
libpcap1.9.1	2
less551	        2
openssl1.1.1s	1
libexif0.6.22	1
jvm-hotspot-oracle17.0.10u7	1
vsftpd3.0.3	1
zlib1.2.11	1
libflac1.3.3	1
xz5.2.4	        1
iperf3	        1
libcap2.32	1
libwebp1.1.0	1

Total Libraries Listed: 24






NVD CVE (National Vulnerability Database - Common Vulnerabilities and Exposures) 

https://chatgpt.com/share/67b857b5-1a04-800f-9e6f-1ea86b97207e



~/.cache/cve-bin-tool

pip install --upgrade --force-reinstall cve-bin-tool reportlab
pip uninstall cve-bin-tool -y
pip install --user cve-bin-tool
pip install --upgrade cve-bin-tool


cve-bin-tool --output-file scp_cve_report.json -f json scp
cve-bin-tool --output-file scp_cve_report.json -f json --offline scp
cve-bin-tool --import cve_db.json
cve-bin-tool --export cve_db.json
cve-bin-tool --update now
cve-bin-tool --output-file scp_cve_report.json -f json -n json-mirror scp
cve-bin-tool --output-file scp_cve_report.json -f json scp
n




scancode -clp --json license_results.json scancode
cat license_results.json | jq '.files[] | {path, detected_license_expression}'

scancode -clp --json license_results.json ls
cat license_results.json | jq '.files[] | {path, detected_license_expression}'


scancode -clp --json license_results.json rfkill
cat license_results.json | jq '.files[] | {path, detected_license_expression}'

























i need a best real time example code for callback fun in c give me 2 code like big one without call back this very complivate and with call back this is very ease updimacs one like i need 

========================================================================================================================================================================================================

am437x rtos
=========================


patch -p0 -d /home/zumi/ti/pdk_am437x_1_0_17/packages/ti/drv/icss_emac < /home/zumi/Abinash/new-project_DLC-MRP_protocol/mrp/protocols/pdk_patches/06.03.00



export SDK_INSTALL_PATH=~/home/zumi/ti/processor_sdk_rtos_am437x_6_03_00_106
export PDK_INSTALL_PATH=/home/zumi/ti/pdk_am437x_1_0_17/packages
export PATH=/home/zumi/ti/gcc-arm-none-eabi-7-2018-q2-update/bin:$PATH


source ./pdksetupenv.sh


./pdkProjectCreate.sh AM437x all little

./pdkProjectCreate.sh AM437x evmAM437x little all all arm

./pdkProjectCreate.sh AM437x idkAM437x little all all arm



cd $PDK_INSTALL_PATH/packages/ti/drv/icss_emac
make BOARD=am437x_idk PROFILE=release

cd $PDK_INSTALL_PATH/packages/ti/pru_icss_fw
make BOARD=am437x_idk PROFILE=release

The output binary will be located in:
$PDK_INSTALL_PATH/packages/ti/binary/<example>/bin/am437x/



Convert RTOS Binary to U-Boot Loadable Format


arm-none-eabi-objcopy -O binary app.out app.bin




sudo update-alternatives --config java



=======================================================================================================================================================================
systemd
=========

Enable Manually
Open the inittab file located in the /etc/inittab directory.

You will find a line similar to:

si::sysinit:/etc/init.d/rcS
Add one more line below it to include your script:


s1::sysinit:/etc/init.d/your_script.sh
Then create a UBI (Unsorted Block Image) for it to work during the system boot.

=============================================================

#!/bin/sh

# Load CAN related modules
insmod /lib/modules/can.ko
insmod /lib/modules/can-raw.ko
insmod /lib/modules/can-gw.ko
insmod /lib/modules/can-bcm.ko
insmod /lib/modules/can-dev.ko
insmod /lib/modules/c_can.ko
insmod /lib/modules/c_can_platform.ko

# Load other modules
insmod /lib/modules/hsr.ko
insmod /lib/modules/pruss.ko
insmod /lib/modules/pru_rproc.ko
insmod /lib/modules/icss_iep.ko
insmod /lib/modules/irq-pruss-intc.ko
insmod /lib/modules/llc.ko
insmod /lib/modules/stp.ko
insmod /lib/modules/bridge.ko
insmod /lib/modules/prueth.ko

ifconfig eth0 up
ifconfig eth1 up

insmod /lib/modules/at25.ko

echo "Modules inserted successfully!"

****************************************************

#!/bin/sh

# Remove modules in reverse order
rmmod at25
rmmod prueth
rmmod bridge
rmmod stp
rmmod llc
rmmod irq_pruss_intc
rmmod icss_iep
rmmod pru_rproc
rmmod pruss
rmmod hsr

# CAN related modules
rmmod c_can_platform
rmmod c_can
rmmod can_dev
rmmod can_bcm
rmmod can_gw
rmmod can_raw
rmmod can

echo "Modules removed successfully!"

*****************************************************
modula search script 
==============

#!/bin/bash

# Create kernel_modula folder if it doesn't exist
mkdir -p kernel_modula

echo "Searching for .ko files in the current directory..."

# List of kernel modules to search and copy
modules=(
  can.ko can-raw.ko can-gw.ko can-bcm.ko can-dev.ko c_can.ko c_can_platform.ko
  hsr.ko pruss.ko pru_rproc.ko icss_iep.ko irq-pruss-intc.ko llc.ko stp.ko bridge.ko
  prueth.ko at25.ko
)

# Search and copy .ko files to kernel_modula folder
for module in "${modules[@]}"; do
  found=$(find . -type f -name "$module" 2>/dev/null)
  if [ -n "$found" ]; then
    echo "Copying $module to kernel_modula"
    cp $found kernel_modula/
  else
    echo "$module not found"
  fi
done

echo "All required modules copied if found."


insmod script 
===============

#!/bin/sh

# List of kernel modules to load (space-separated)
modules="can.ko can-raw.ko can-gw.ko can-bcm.ko can-dev.ko c_can.ko c_can_platform.ko
hsr.ko pruss.ko pru_rproc.ko icss_iep.ko irq-pruss-intc.ko llc.ko stp.ko bridge.ko
prueth.ko at25.ko"

# Load each module using insmod
for module in $modules; do
  module_path=$(find /lib/modules -type f -name "$module" 2>/dev/null)

  if [ -n "$module_path" ]; then
    echo "Loading $module using insmod..."
    insmod "$module_path"
    if [ $? -eq 0 ]; then
      echo "$module loaded successfully."
    else
      echo "Failed to load $module."
    fi
  else
    echo "$module not found in /lib/modules."
  fi
done

echo "All modules processed."






#!/bin/bash

# Load dependencies first
insmod hsr.ko 
insmod pruss.ko
insmod pru_rproc.ko
insmod icss_iep.ko 
insmod irq-pruss-intc.ko  
insmod llc.ko 
insmod stp.ko 
insmod bridge.ko 

brctl addbr br0 

insmod prueth.ko
insmod garp.ko  
insmod mrp.ko  
insmod 8021q.ko

ifconfig eth0 down
ifconfig eth1 down 
brctl addif br0 eth0
brctl addif br0 eth1

ifconfig eth0 up
ifconfig eth1 up

ifconfig br0 192.168.0.100 netmask 255.255.255.0 up
bridge mrp set br0 domain 1
bridge mrp set br0 role client


echo "All kernel modules loaded successfully."


Step 2: Configure the Bridge Interface
Set up a network bridge (br0) to manage redundancy:

bash
Copy
Edit
brctl addbr br0
brctl addif br0 eth0
brctl addif br0 eth1
ifconfig br0 up
Verify the bridge is set up:

bash
Copy
Edit
brctl show
Step 3: Assign an IP Address to the Bridge
Assign an IP to br0:

bash
Copy
Edit
ifconfig br0 192.168.0.100 netmask 255.255.255.0 up
Check the interface settings:

bash
Copy
Edit
ifconfig br0
Step 4: Add MRP Domain (Make MRP Work in Client Mode)
Configure MRP to operate in client mode:

bash
Copy
Edit
bridge mrp set br0 domain 1
Verify the configuration:

bash
Copy
Edit
bridge mrp show
To set MRP as a client:

bash
Copy
Edit
bridge mrp set br0 role client
Step 5: Verify MRP Status
Check the MRP status and logs:

bash
Copy
Edit
dmesg | grep mrp
bridge mrp show
Step 6: Enable MRP on Boot
To make the setup persistent after reboot, add the following commands to a startup script (/etc/rc.local or a custom startup script):


Make it executable:

bash
Copy
Edit
chmod +x /etc/rc.local
Step 7: Testing MRP Functionality
Check if MRP is enabled:

bash
Copy
Edit
bridge mrp show
Disconnect a link (simulate failure) and check the failover:

bash
Copy
Edit
ifconfig eth0 down
MRP should switch to eth1. Verify with:

bash
Copy
Edit
bridge mrp show
Re-enable the interface:

bash
Copy
Edit
ifconfig eth0 up


===================

Step 1: Verify MRP Module
Check if the MRP module is already loaded:

bash
Copy
Edit
lsmod | grep mrp
If it’s not loaded, you can manually load it using:

bash
Copy
Edit
modprobe mrp
Step 2: Create a Bridge for MRP
MRP requires a bridge interface to manage redundancy. You can create a bridge named br0 and add both Ethernet interfaces (eth0 and eth1).

bash
Copy
Edit
ip link add name br0 type bridge
ip link set dev br0 up
ip link set dev eth0 master br0
ip link set dev eth1 master br0
To confirm that the bridge is created and interfaces are assigned:

bash
Copy
Edit
bridge link
Step 3: Enable MRP on the Bridge
Once the bridge is created, you can enable MRP:

bash
Copy
Edit
bridge mrp add br0
bridge mrp show
To add a MRP instance and configure your board as an MRP Manager:

bash
Copy
Edit
bridge mrp set br0 role manager
bridge mrp show
To configure your board as an MRP Client:

bash
Copy
Edit
bridge mrp set br0 role client
bridge mrp show
To add an MRP domain:

bash
Copy
Edit
bridge mrp set br0 domain 1
Step 4: Verify MRP Status
Check the MRP configuration and status:

bash
Copy
Edit
bridge mrp show
To check if MRP frames are being exchanged:

bash
Copy
Edit
tcpdump -i br0 -n -s0 -XX ether proto 0x88e3
(MRP uses EtherType 0x88E3.)

Step 5: Enable MRP at Boot (Optional)
To enable MRP permanently, add these commands to your startup script (e.g., /etc/rc.local or a systemd service script).

Troubleshooting
If bridge mrp is not available, ensure your iproute2 package is updated.
Check if your Ethernet drivers support MRP (ethtool -i eth0).
Ensure your PRU firmware is correctly handling Ethernet switching.   
   
   
   
   
 2369  MACHINE=am437x-evm bitbake-layers show-recipes | grep mrp
 2370  MACHINE=am437x-evm bitbake-layers show-recipes | grep bridge
 2371  MACHINE=am437x-evm bitbake-layers show-recipes | grep iproute
 2372  MACHINE=am437x-evm bitbake -e iproute2 | grep ^EXTRA_OECONF
 2373  bridge -c | grep mrp

   
   
    mrp-utils \


DLR am4376
===



make -C /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc M=$(pwd) clean
make -C /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc M=$(pwd) prueth.ko
make -C /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc M=$(pwd) modules

 printk("Zumi Fun: %s Line: %d\r\n",__func__, __LINE__);

loading madual as manualy 
=========================

lsmod

rmmod prueth  //remove

insmod /lib/modules/5.10.100-rt62-g204ec708dc/extra/prueth.ko // install

make the madual as alone 
=============================

make -C /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc M=$(pwd) modules
make -C /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc M=$(pwd) prueth.ko
make -C /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc M=$(pwd) clean




make -C /home/zumi/Abinash/AM4376/tisdk/build M=$(pwd) clean 


TI board enable for DLC and MRP in ethrnet 
==================================================================================
https://software-dl.ti.com/processor-sdk-linux/esd/docs/06_03_00_106/linux/Foundational_Components_PRU-ICSS_PRU_ICSSG.html
https://software-dl.ti.com/processor-industrial-sw/esd/PRU-ICSS-ETHERNETIP-ADAPTER/latest/index_FDS.html
https://software-dl.ti.com/processor-sdk-rtos/esd/docs/04_03_00_05/rtos/Overview.html#linux-sd-card-creation-guide
https://software-dl.ti.com/processor-industrial-sw/esd/PRU-ICSS-ETHERNETIP-ADAPTER/latest/index_FDS.html
https://software-dl.ti.com/processor-sdk-rtos/esd/AM437X/05_00_00_15/index_FDS.html

mrp dlr code
==========
https://www.ti.com/tool/PRU-ICSS-INDUSTRIAL-SW


===========ne

https://e2e.ti.com/support/processors-group/processors/f/processors-forum/1378648/am4376-unable-to-enable-mrp-for-bridge-and-if-enabled-using-kernel-config-it-is-impacting-pru-ethernet?utm_source=chatgpt.com


 modinfo net/802/mrp.ko
 

how to find depends for ko files
=================================
 
modinfo ./drivers/net/ethernet/ti/prueth.ko | grep depends
 
mrp
802 
 
 

https://e2e.ti.com/support/processors-group/processors/f/processors-forum/951722/am4376-hsr-dlr-mrp
https://software-dl.ti.com/processor-industrial-sw/esd/docs/indsw/ethernetIP_adapter/01_00_04/PRU_ICSS_EthernetIP.html


karthi
====
https://e2e.ti.com/support/processors-group/processors/f/processors-forum/1289189/am4376-dlr-support-and-implementation-prodecure?keyMatch=am437x%20DLR%20driver&tisearch=universal_search




pru-icss start in am4376
=======================
https://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/Foundational_Components/PRU-ICSS-Getting-Started.html




https://software-dl.ti.com/processor-industrial-sw/esd/ind_comms_sdk/am64x/latest/docs/api_guide_am64x/group__EIP__DLR.html










1 2 3 4 









==============================================================================================================================================================================================
ip issue in pc 

/etc/netplan/01-network-manager-all.yaml

org 

# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager



modbus in am4376
====================

https://teams.microsoft.com/v2/?meetingjoin=true#/l/meetup-join/19:meeting_ZmEyODM4NDUtY2E5MS00N2NhLTg5YzEtMmU3ODhiZWQ1NTVj@thread.v2/0?context=%7b%22Tid%22%3a%226e51e1ad-c54b-4b39-b598-0ffe9ae68fef%22%2c%22Oid%22%3a%2278250722-1e44-4306-bfb3-7d1a729bb3b0%22%7d&anon=true&deeplinkId=e4e1ab9d-2709-4010-b54b-d456ed537505


rstp
        
        
        insmod /lib/modules/5.4.106-g023faefa70/kernel/net/llc/llc.ko
        sleep 1                                             
        
        insmod /lib/modules/5.4.106-g023faefa70/kernel/net/802/stp.ko
        sleep 1                                             
        
        insmod /lib/modules/5.4.106-g023faefa70/kernel/net/bridge/bridge.ko
        sleep 1                                                                                      

        insmod /lib/modules/5.4.106-g023faefa70/kernel/net/bridge/br_netfilter.ko
        sleep 1        



sudo ifconfig br0 down
sudo brctl delbr br0

brctl showstp br0



sudo tcpdump -i br0









CONFIG_CMD_MEMTEST

You can consider Monitoring data, breaker data, Module data and protection settings for phase 1

 
Monitoring data, 
breaker data, 
Module data 
protection settings for phase 1



make -C /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work/am437x_evm-linux-gnueabi/linux-ti-staging/5.4.106+gitAUTOINC+023faefa70-r3a.arago5.tisdk1.1/git M=$(pwd) clean
make -C /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work/am437x_evm-linux-gnueabi/linux-ti-staging/5.4.106+gitAUTOINC+023faefa70-r3a.arago5.tisdk1.1/git M=$(pwd) prueth.ko
make -C /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work/am437x_evm-linux-gnueabi/linux-ti-staging/5.4.106+gitAUTOINC+023faefa70-r3a.arago5.tisdk1.1/git M=$(pwd) modules









export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

make distclean



make tisdk_am437x-evm_defconfig
make -j8

cd /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work-shared/am437x-evm/kernel-source
$ make mrproper





















export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH


make distclean

make am43xx_evm_defconfig

make








	modified:   arch/arm/boot/dts/am437x-gp-evm-hdmi.dts
	modified:   arch/arm/boot/dts/am437x-gp-evm.dts
	modified:   drivers/misc/eeprom/Makefile
	modified:   drivers/net/ethernet/ti/prueth_core.c
	modified:   drivers/net/phy/Makefile




git diff --cached > my-changes.patch
patch -p1 < my-changes.patch


Username: projects@kemsys.com
Password: J$585844205412uc


projects@kemsys.com
J$585844205412uc


f
nand erase.chip
nand erase.part NAND.SPL
nand erase.part NAND.u-boot
nand erase.part NAND.kernel
nand erase.part NAND.file-system



fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL 0x2ac74


fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot 0x9f43c

nand read 0x80800000 NAND.kernel 0x487882



nand erase.part NAND.kernel
fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel 0x4cdd2e




nand erase.part NAND.file-system
fatload mmc 0:1 0x82000000 rootfs.ubi
nand write 0x82000000 NAND.file-system 0x1980000


MACHINE=am437x-evm bitbake -C compile -f virtual/kernel -C kernel_modules
MACHINE=am437x-evm bitbake virtual/kernel -c menuconfig
MACHINE=am437x-evm bitbake -C compile_kernelmodules linux-ti-staging
MACHINE=am437x-evm bitbake -C compile linux-ti-staging

do_compile_modules



MACHINE=am437x-evm bitbake -C compile u-boot-ti-staging


make distclean

make am43xx_evm_defconfig

make -j8


teamp fs 
=========

https://e2e.ti.com/support/processors-group/processors/f/processors-forum/1161394/am6548-pru-ethernet-rx---packet-issue

gmount -t tmpfs -o size=350m tmpfs /mnt


~[ 1195.684119] Kemsys dp83822_read_status : 324 MII Ethernet Phy Status = 90c 
ytool [ 1196.724387] Kemsys dp83822_read_status : 324 MII Ethernet Phy Status = 90c 

Usage: phytool read  IFACE/ADDR/REG
       phytool write IFACE/ADDR/REG <0-0xffff>
       phytool print IFACE/ADDR[/REG]
where
















phytool read eth0/0x00/0x16

phytool read eth0/0x00/0x10
phytool write eth0/0x00/0x00 0x3000  //disable loopback
phytool write eth0/0x00/0x00 0x6000  //enable loopback


phytool read eth0/0x00/0x00
phytool write eth0/0x00/0x00 0x6100  //disable loopback


PHY  to Connector  loopback checking commands:(eth0)

External loopback:

pc--->Connector-->phy-->Connection->pc    //working perfectly

phytool write eth0/0x00/0x16 0x0050

Back to Normal:

phytool write eth1/0x00/0x16 0x0128

phytool read eth0/0x00/0x16
Processor and PHY loopback checking commands:
Pc-->Processor-->phy-->Processor ->pc    //not working 
phytool read eth0/0x00/0x10
phytool write eth0/0x00/0x00 0x3000  //disable loopback
phytool write eth0/0x00/0x00 0x6000  //enable loopback


phytool read eth0/0x00/0x00
phytool write eth0/0x00/0x00 0x6100  //disable loopback

Eth1 both are not working


ethernet commands:
==================

Read BMCR Reg:   // Table 8-14. 0x0000 Basic Mode Control Register (BMCR)
=============

phytool read eth0/0x00/0x00      //phytool read  network interface to which the PHY is connected/PHY address/register address
phytool read eth0/0x01/0x00      //

Enable Loopback:
================
phytool write eth0/0x01/0x00 0x7100

Disable Loopback:
================
phytool write eth0/0x01/0x00 0x3100

External loopback
=================
pc--->Connector-->phy-->Connection->pc
phytool write eth0/0x00/0x16 0x0050

Back to Normal:
==============
phytool write eth1/0x00/0x16 0x0128


PHYCR
====

phytool read eth0/0x00/0x10
phytool read eth0/0x00/0x10



ADDR := C22 | C45
C22  := <0-0x1f>
C45  := <0-0x1f>:<0-0x1f>
REG  := <0-0x1f>

Examples:
       phytool read  eth0/0:3/1
       phytool write eth0/0xa/0 0x1140
       phytool print eth0/0x1c

Note: Not all MDIO drivers support the `port:device` Clause 45 address
format.

The `read` and `write` commands are simple register level
accessors. The `print` command will pretty-print a register. When
using the `print` command, the register is optional. If left out, the
most common registers will be shown.

Bug report address: https://github.com/wkz/phytool/issues

nand erase.part NAND.file-system-1
fatload mmc 0:1 0x82000000 rootfs.ubi
nand write 0x82000000 NAND.file-system-1 0x700000

linux flash commant for nand
----------------------------

/run/media/mmcblk0p1
flash_erase /dev/mtd1 0 0
nandwrite -p /dev/mtd1 MLO


flash_erase /dev/mtd5 0 0
nandwrite -p /dev/mtd5 fitImage.itb

flash_erase /dev/mtd8 0 0
nandwrite -p /dev/mtd8 fitImage.itb

flash_erase /dev/mtd9 0 0
nandwrite -p /dev/mtd9 rootfs.ubi


flash_erase /dev/mtd6 0 0
nandwrite -p /dev/mtd6 rootfs.ubi


flash u-boot for kernle in am4376
-------------------------------
nand scrub.chip //we get any bad block use this one 
nand erase.chip //erase all memory
nand erase.part NAND.SPL
nand erase.part NAND.u-boot
nand erase.part NAND.kernel
nand erase.part NAND.u-boot-spl-os
nand erase.part NAND.file-system 

nand erase.part NAND.SPL.backup1
nand erase.part NAND.u-boot-1
nand erase.part NAND.kernel-1
nand erase.part NAND.file-system-1



nand erase.part NAND.SPL.backup2
nand erase.part NAND.u-boot-2
nand erase.part NAND.kernel-2
nand erase.part NAND.file-system-2




fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL.backup1 0x2ac74


fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot-1 0x9f43c

nand erase.part NAND.kernel-1
fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel-1 0x4ce01e

nand erase.part NAND.file-system-1
fatload mmc 0:1 0x82000000 lnt_fs.ubi
nand write 0x82000000 NAND.file-system-1 0xc7c0000


nand erase.part NAND.file-system-2
fatload mmc 0:1 0x82000000 rootfs.ubi
nand write 0x82000000 NAND.file-system-2 0x1100000



fatload mmc 0:1 0x82000000 MLO1
nand write 0x82000000 NAND.SPL.backup2 0x2a874


fatload mmc 0:1 0x82000000 u-boot.img1
nand write 0x82000000 NAND.u-boot-2 0x9e9c4

nand erase.part NAND.kernel-2
fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel-2 0x4cdffa

fatload mmc 0:1 0x82000000 lnt_fs.ubi

nand write 0x82000000 NAND.file-system-2 0xc7c0000


ethernet up ko files
=====================

kernel/drivers/net/ethernet/ti/prueth.ko: kernel/net/hsr/hsr.ko kernel/drivers/net/ethernet/ti/icss_iep.ko kernel/drivers/soc/ti/pruss.ko kernel/drivers/remoteproc/pru_rproc.ko 


find . -type f -name "pru_rproc.ko "

/lib/modules/5.10.100-rt62-g204ec708dc/kernel/drivers/net/ethernet/ti


cp prueth.ko /lib/modules/5.10.100-rt62-g204ec708dc/kernel/drivers/net/ethernet/ti

irq_pruss_intc         16384  0
hsr                    57344  0
icss_iep               24576  0
pru_rproc              24576  0
pruss                  16384  1 pru_rproc



cd /run/media/mmcblk0p1

insmod pruss.ko

rmmod pruss


cd /run/media/mmcblk0p1

insmod hsr.ko

insmod pruss.ko

insmod icss_iep.ko  

insmod pru_rproc.ko

insmod prueth.ko


rmmod hsr

rmmod pruss

rmmod icss_iep

rmmod pru_rproc

rmmod prueth





     
=======================================================================================================================================================================================
[2025-03-25 11:54:58] [    4.360482] ubi0: attaching mtd9
[2025-03-25 11:54:58] [    6.419743] ubi0: scanning is finished
[2025-03-25 11:54:58] [    6.434207] ubi0 warning: ubi_eba_init: cannot reserve enough PEBs for bad PEB handling, reserved 23, need 80
[2025-03-25 11:54:58] [    6.437723] ubi0: attached mtd9 (name "NAND.file-system", size 502 MiB)
[2025-03-25 11:54:58] [    6.437765] ubi0: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
[2025-03-25 11:54:58] [    6.437788] ubi0: min./max. I/O unit sizes: 2048/2048, sub-page size 512
[2025-03-25 11:54:58] [    6.437807] ubi0: VID header offset: 2048 (aligned 2048), data offset: 4096
[2025-03-25 11:54:58] [    6.437824] ubi0: good PEBs: 4016, bad PEBs: 0, corrupted PEBs: 0
[2025-03-25 11:54:58] [    6.437841] ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
[2025-03-25 11:54:58] [    6.437860] ubi0: max/mean erase counter: 2/0, WL threshold: 4096, image sequence number: 1337353840
[2025-03-25 11:54:58] [    6.437882] ubi0: available PEBs: 0, total reserved PEBs: 4016, PEBs reserved for bad PEB handling: 23
[2025-03-25 11:54:58] [    6.440986] ALSA device list:
[2025-03-25 11:54:58] [    6.441009]   No soundcards found.
[2025-03-25 11:54:58] [    6.442454] ubi0: background thread "ubi_bgt0d" started, PID 80
[2025-03-25 11:54:58] [    6.444494] UBIFS (ubi0:0): Mounting in unauthenticated mode
[2025-03-25 11:54:58] [    6.452721] UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 82
[2025-03-25 11:54:58] [    6.464242] UBIFS (ubi0:0): recovery needed
[2025-03-25 11:54:58] [    6.527008] UBIFS (ubi0:0): recovery completed
[2025-03-25 11:54:58] [    6.527590] UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs"
[2025-03-25 11:54:58] [    6.527628] UBIFS (ubi0:0): LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
[2025-03-25 11:54:58] [    6.527657] UBIFS (ubi0:0): FS size: 497872896 bytes (474 MiB, 3921 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
[2025-03-25 11:54:58] [    6.527691] UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
[2025-03-25 11:54:58] [    6.527710] UBIFS (ubi0:0): media format: w4/r0 (latest is w5/r0), UUID 819B57F3-A5EA-45BD-AD8D-1BDCAB1D58C5, small LPT model
[2025-03-25 11:54:58] [    6.528526] VFS: Mounted root (ubifs filesystem) on device 0:15.



-p = physical eraseblock size = 256KiB
-e = logical eraseblock size = 258048
-m = smallest flash I/O unit = 2048•
-s = VID header offset = 2048 (some flash will also have a sub-page
size reported when you run ubiattach, which is what you should use
with –s)
-c = available PEB = 966

above is document blow is work we need do check in real time of ubi date using linux command are u-boot cmt  ubi
--------------------------------------------------------------------------------------------------------------

-m 2048    <=========>  ubi0: min./max. I/O unit sizes: 2048/2048
-e 126976  <=========>  LEB size: 126976 bytes
-c 0       <=========>  ubi0: available PEBs: 0
-p 128KIB  <=========>  ubi0: PEB size: 131072 bytes (128 KiB)
-s 2048    <=========>  VID header offset: 2048 (aligned 2048)



UBI manula creat make nand ubifs 
================================

sudo apt update
sudo apt install mtd-utils

tar -xvf rootfs.tar.xz

working 1gp sw update board
================================================

main
====

sw-update-board rstp_mstp ubi file make 
=========================================

1)file name ubinize.cfg

[ubifs]
mode=ubi
image=rootfs.ubifs
vol_id=0
vol_size=310MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize


2)sudo mkfs.ubifs -r /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/rstp_mstp/rootfs -o rootfs.ubifs -F -m 4096 -e 253952 -c 1368
sudo ubinize -o rootfs.ubi -m 4096 -p 256KiB -s 4096 -O 4096 ubinize.cfg



tiny
=====

1)file name ubinize.cfg

[ubifs]
mode=ubi
image=rootfs.ubifs
vol_id=0
vol_size=28MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize


sudo mkfs.ubifs -r /home/zumi/karthi/yocto_build_am437x/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/pear_ethernet_tiny_rootfs/rootfs -o rootfs.ubifs -F -m 4096 -e 253952 -c 200
sudo ubinize -o rootfs.ubi -m 4096 -p 256KiB -s 4096 -O 4096 ubinize.cfg



//------------------------------------------------------------------------------------------------------------------------------------------////



small board am437x nand512 pearl ethernet 
*****************************************

1)
sudo apt update
sudo apt install mtd-utils

2)file name ubinize.cfg
=======================

[ubifs]
mode=ubi
image=rootfs.ubifs
vol_id=0
vol_size=483MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize

3)
sudo mkfs.ubifs -r /home/zumi/Karthi/yocto_build_am437x/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/tisdk-tiny-image/rootfs -o rootfs.ubifs -F -m 2048 -e 126976 -c 3932
sudo ubinize -o rootfs.ubi -m 2048 -p 128KiB -s 512 -O 2048 ubinize.cfg


   
./meta-arago-distro/recipes-core/images/tisdk-tiny-image.bb

Confirm Availability:
--------------------
MACHINE=am437x-evm bitbake-layers show-recipes bridge-utils



ARAGO_SYSVINIT = "1"

require arago-image.inc

IMAGE_FEATURES_remove = "package-management splash"

IMAGE_FSTYPES += "cpio cpio.xz"

ARAGO_TINY_IMAGE_EXTRA_INSTALL ?= ""

IMAGE_INSTALL = " \
    packagegroup-arago-sysvinit-boot \
    dhcp-client \
    net-snmp \
    iproute2 \
    can-utils \
    openssh-scp \
    openssh-ssh \
    bridge-utils \
    mstpd \
    ${ARAGO_TINY_IMAGE_EXTRA_INSTALL} \
"


deltask do_packagedata

export IMAGE_BASENAME = "tisdk-tiny-image"







=============================sd card rootfs ======================

set nandroot "/dev/mmcblk0p2 rw"
set nandrootfstype "ext4 rootwait=10"

nand rootfs mount 
=================

set nandroot "ubi0:rootfs rw ubi.mtd=NAND.file-system,2048"
set nandrootfstype "ubifs rootwait"


=========================================================================================================================================================================================
































































================================================================================================================================================================================================

arduino ide istall 
===================

sudo apt update
sudo apt upgrade
sudo apt install -y wget software-properties-common
wget https://downloads.arduino.cc/arduino-1.8.19-linux64.tar.xz
ls
tar -xvf arduino-1.8.19-linux64.tar.xz
cd arduino-1.8.19
sudo ./install.sh
arduino
 


new-project edge AI using controller 
=====================

https://circuitdigest.com/microcontroller-projects/object-recognition-using-esp32-cam-and-edge-impulse

https://github.com/HJGrant/esp32-speech-recognition/blob/main/README.md

https://github.com/edgeimpulse/voice-activated-microbit?tab=readme-ov-file

i need voice recognition for using ai in controller project wed said links i need using ai 





















patch file total folder 
======================

u-boot-total-patch
=================

diff -Naur u-boot-2019.01+gitAUTOINC+333c3e72d3-g333c3e72d3/ u-boot-patch/ > u-boot-patch.diff


patch -p1 -d u-boot-patch/ < u-boot-patch.diff

patch -R -p1 -d u-boot-patch/ < u-boot-patch.diff

first give first commat that not getting any error give one more time that time getting error that time use 2 second commant 2 commnat is working so both use ulta 

linux total patch
========================

diff -Naur linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc/ linux-patch/ > linux-patch.diff


patch -p1 -d linux-patch/ < linux-patch.diff 

patch -R -p1 -d linux-patch/ < linux-patch.diff 



patch --force -p1 -d u-boot-patch/ < u-boot-patch.diff

patch -R -p1 -d u-boot-patch/ < u-boot-patch.diff || patch --force -p1 -d u-boot-patch/ < u-boot-patch.diff



single file patch 
===============================


git status 
git add
git commit -sm "u-boot partition"
git format-patch --no-numbered -1

#include <stdio.h>
#include <stdlib.h>
#include <modbus.h>

#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 1502

int main() {
    modbus_t *ctx;
    uint16_t register_value;
    int register_address, rc;

    // Initialize the master
    ctx = modbus_new_tcp(SERVER_IP, SERVER_PORT);
    if (ctx == NULL) {
        fprintf(stderr, "Unable to create the Modbus context\n");
        return -1;
    }

    // Connect to the slave
    if (modbus_connect(ctx) == -1) {
        fprintf(stderr, "Unable to connect: %s\n", modbus_strerror(errno));
        modbus_free(ctx);
        return -1;
    }

    printf("Connected to the slave.\n");

    while (1) {
        // Get the register address from the user
        printf("Enter the register address (0 - 99, or -1 to quit): ");
        scanf("%d", &register_address);

        if (register_address == -1) {
            printf("Exiting...\n");
            break;
        }

        if (register_address < 0 || register_address >= 100) {
            printf("Invalid register address. Try again.\n");
            continue;
        }

        // Read the register value from the slave
        rc = modbus_read_registers(ctx, register_address, 1, &register_value);
        if (rc == -1) {
            fprintf(stderr, "Failed to read: %s\n", modbus_strerror(errno));
        } else {
            printf("Value at register %d: %d\n", register_address, register_value);
        }
    }

    // Clean up
    modbus_close(ctx);
    modbus_free(ctx);
    return 0;
}
git log --oneline

git reset --hard HEAD^1 


git checkout -b file-name 

Linux:
root@-pc:/opt/ti-processor-sdk-linux-am437x-hs-evm 06.03.00.106/board-support/linux-rt-5.10_new.100+gitAUTOINC+204ec708dc-g204ec708dc#
patch -p1 < patchfile_name_path

U-BOOT:
root-pc:/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/u-boot-2019.01+gitAUTOINC+333c3e72d3-g333c3e72d3# 
patch -p1 < patchfile_name_path



board/ti/am43xx/board.c
common/spl/spl_nand.c

include/configs/am43xx_evm.h
hw_watchdog_init

manula crash kernrl 
=======================
echo c > /proc/sysrq-trigger



You can do this using the U-Boot command:

bash
Copy code
md 0x80000000 1  # Read memory to confirm it's clear
mw 0x80000000 0x2D500000  # Write the value to a memory address (e.g., 0x80000000)
Write to NAND: Now, use the nand write.raw command to write the memory content to NAND.

bash
Copy code
nand write.raw 0x80000000 0x2d500000 4  # Write 4 bytes from 0x80000000 to NAND offset 0x2D500000





md 0x80000000 1  
mw 0x80000000 0x2D500000  


nand write.raw 0x80000000 0x2d500000 4  



PRCM_PRM
PRM_DEVICE 0x44DF_4000 




increas the tcp protocol efficiency 
====================================
increass tcp window

/etc/sysctl.conf

net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 16384 16777216

4096 is the minimum size of the TCP window.
87380 is the default size of the TCP window.
16777216 is the maximum size of the TCP window.

sysctl -p

after change verifying 
=======================

cat /proc/sys/net/ipv4/tcp_rmem
cat /proc/sys/net/ipv4/tcp_wmem
======================================================


systemctl restart networking

ubiattach /dev/ubi_ctrl -m 11 -d 1
mount -t ubifs ubi1:rootfs /mnt




ubiattach /dev/ubi_ctrl -m 11 -d 1
mount -t ubifs ubi1:rootfs /mnt

/etc/init.d/networking restart
systemctl restart networking






add script in board auto
==============================================
one more way for dynamic
----------------------------------------------

1) sudo vi /etc/systemd/system/fwappli.service

[Unit]
Description=A description for your custom service goes here
After=fwupdate.target

[Service]
Type=simple
ExecStart=/bin/bash /usr/sbin/fwappli.sh
TimeoutStartSec=0

[Install]
WantedBy=default.target


2)Make the script executable:
sudo chmod +x /usr/sbin/fwappli.sh

3)Reload systemd and enable service:
sudo systemctl daemon-reload
sudo systemctl enable fwappli.service

4)Start the service:
sudo systemctl start fwappli.service

5)Check the service status:
sudo systemctl status fwappli.service

6)View logs (optional):
sudo journalctl -u fwappli.service


7)To start the service manually, run:
sudo systemctl start fwappli.service

This will start your service immediately.

8)Check the service status
sudo systemctl status fwappli.service

To check whether the service is running correctly:








dd if=/dev/mtd1 of=/mnt/backup-mtd1.img bs=1M


#!/bin/sh
# Run the commands you want at boot
echo "Starting custom boot commands..."

# Attach UBI device and mount filesystem
ubiattach /dev/ubi_ctrl -m 11 -d 1
mount -t ubifs ubi1:rootfs /mnt

exit 0



vi /etc/init.d/my_startup_script

chmod +x  /etc/init.d/my_startup_script

update-rc.d my_startup_script defaults

systemctl enable my_startup_script.service





is already exist

update-rc.d -f my_startup_script remove
update-rc.d my_startup_script defaults


systemctl enable my_startup_script.service
systemctl status my_startup_script.service


manual start 
=============

sudo /etc/init.d/my_startup_script start

=================================================================


nand read 0x80008000 0x2d500000 4


md.l 0x80008000 1


#define NANDARGS \
        "mtdids=" CONFIG_MTDIDS_DEFAULT "\0" \
        "mtdparts=" CONFIG_MTDPARTS_DEFAULT "\0" \
        "nandargs=setenv bootargs console=${console} " \
                "${optargs} " \
                "root=${nandroot} " \
                "rootfstype=${nandrootfstype}\0" \
        "nandroot=ubi0:rootfs rw ubi.mtd=NAND.file-system-1,4096\0" \
        "nandrootfstype=ubifs rootwait=10\0" \
        "nandboot=echo Booting from nand...; " \
                "run nandargs; " \
                "nand read ${fdtaddr} NAND.u-boot-spl-os; " \
                "nand read ${addr_fit} ${NAND-kernel}; " \
                "bootm ${addr_fit} \0" \
        "spl_boot1 = if selectbootdev; test ${bootdev} -eq 1; then setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-1,4096'; fi;" \
        "spl_boot2 = if selectbootdev; test ${bootdev} -eq 2; then setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-2,4096'; fi;" \
        "bootcmd=run spl_boo1; run spl_boot2; run findfdt; run finduuid; run distro_bootcmd"

 set nandroot "ubi0:rootfs rw ubi.mtd=NAND.file-system,2048"
 set nandrootfstype "ubifs rootwait"
 spl_boot1 = if selectbootdev; test ${bootdev} -eq 1; then setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-1,4096'; setenv NAND-kernel 'NAND.kernel-1'; fi;
 spl_boot2 = if selectbootdev; test ${bootdev} -eq 2; then setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-2,4096'; setenv NAND-kernel 'NAND.kernel-2';' fi;

bootcmd=run spl_boo1; run spl_boot2; run findfdt; run finduuid; run distro_bootcmd




in u-boot cmt line do run the c code fun c program on u-boot
------------------------------------------------------------


1)configs/am43xx_hs_evm_defconfig
---------------------------------

CONFIG_BOOTCOMMAND="run spl_boot1; run findfdt; run finduuid; run distro_bootcmd; infloop;"

2)include/configs/am43xx_evm.h
-------------------------------

"spl_boot1=selectbootdev; if test \"${bootdev}\" -eq 1; then echo \"BootRFS1 with uboot ${bootdev}\"; setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-1,4096'; setenv NAND-kernel 'NAND.kernel-1'; else echo \"BootRFS2 with uboot ${bootdev}\"; setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-2,4096'; setenv NAND-kernel 'NAND.kernel-2'; fi; \0"

3)board/ti/am43xx/board.c
-------------------------

#ifndef CONFIG_SPL_BUILD

void indefiniteloop()
{
    printf("Kernel booting issue \r\n");
    while(1);
}

void Set_select_boot_dev()
{
    char     cmd[64];
    u32      addr             = 0x80008000;     // RAM address to write into
    u32      *data;                             // Pointer to read the value from RAM
    u32      nand_offset      = sw_env_offset;     // NAND offset address to read from
    u32      size             = 4;              // Number of bytes to read
    uint8_t  *TEMP_PRM_RSTST  = (uint8_t *)  0x82000000;
    uint32_t *PRCM_PRM_RSTST  = (uint32_t *) 0x44df4004;
    sw_env   *swenv           = (sw_env *)addr;
    uint32_t reset_val;
    data = (u32 *)addr;

    /* 
     * Checking the Reset cause from the Reset register
     */
    reset_val = *PRCM_PRM_RSTST;
   // printf("\nSet_select_boot_dev Reading Reset Cause : PRCM_PRM_RSTST RegVal = %x \r\n", reset_val);
    
    reset_val = *TEMP_PRM_RSTST;
  //  printf("\nReading Reset Cause : TEMP_PRM_RSTST Val = %x \r\n", reset_val);

    if (EXTERNAL_WARM_RST & reset_val)
    {
        printf("External WARM Reset Occured \r\n");
    }
    if (WDT1_RST & reset_val)
    {
        printf("Watchdog Reset Occured \r\n");
    }
    if (GLOBAL_WARM_SW_RST & reset_val)
    {
        printf("Global Warm Software Reset Occured \r\n");
    }
    if (GLOBAL_COLD_RST & reset_val)
    {
        printf("Global Cold Reset Occured \r\n");
    }


    /* 
     * Read Software udpate Env partition
     */
    sprintf(cmd, "nand read 0x%x 0x%x %u", addr, nand_offset, sizeof(sw_env));


    run_command(cmd, 0);

    printf("Current SPL Value = %x \n", *data);

    if (0xFFFFFFFF == *data)
    {
        /*
	 * There is no value in the Software update evn
	 * Since this is first boot
	 * update the values
	 */
	memset(swenv, 0x00, sizeof(swenv));
	swenv->current_spl = 0;
	*data = swenv->current_spl;

        sprintf(cmd, "nand erase.part %s",sw_env_part);
        printf(" Erasing the SPL 0 backup\n");
        run_command(cmd, 0);

	printf("There is no proper value in the swenv... Writing...\r\n");
        sprintf(cmd, "nand write 0x80008000 %s 0x%x",sw_env_part,sizeof(sw_env));
        run_command(cmd, 0);     	
    }
    
   if( 1 == *data)
    {
        printf("1. Currently Running OS2\r\n");
    }
    else
    {
         printf("1. Currently Running OS1\r\n");
    }
    /* 
     * Check whether this reset is watchdog reset 
     */
    if ((reset_val >> 4) & 1)
    {
        printf("Watchdog reset is occured \r\n");

        if( 1 == *data)
        {

            printf("2. Currently Running OS2\r\n");
            sprintf(cmd, "nand read %s 0x8000a000 0x00040000",OS1_SPL_IMAGE_backup_part);
            printf("values u-boot start\n");
            run_command(cmd, 0);
            sprintf(cmd, "nand erase.part %s",OS1_SPL_IMAGE_part);
            printf(" Erasing the SPL 0 backup\n");
            run_command(cmd, 0);
            sprintf(cmd, "nand write 0x8000a000 %s 0x00040000",OS1_SPL_IMAGE_part);
            printf(" Write the SPL 0\n");
            run_command(cmd, 0);
            printf("Erasing NAND.sw-env\r\n");
            sprintf(cmd, "nand erase.part %s",sw_env_part);
            run_command(cmd, 0);
            *data = 0;
            sprintf(cmd, "nand write 0x80008000 %s 0x%x",sw_env_part,sizeof(sw_env));
            printf(" Erasing the SPL 0 backup\n");
            run_command(cmd, 0);
            sprintf(cmd, "reset");
            printf(" Reset the Device and Boot the previous SPL\n");
	    *TEMP_PRM_RSTST = 0;
            run_command(cmd, 0);
        }
        else
        {
             printf("2. Currently Running OS1\r\n");
             sprintf(cmd, "nand erase.part %s",OS1_SPL_IMAGE_part);
             printf(" Erasing the SPL 0 backup\n");
             run_command(cmd, 0);
             printf("2. Erasing NAND.sw-env\r\n");
             sprintf(cmd, "nand erase.part %s",sw_env_part);
             run_command(cmd, 0);
             *data = 1;
             sprintf(cmd, "nand write 0x80008000 %s 0x%x",sw_env_part,sizeof(sw_env));
             printf(" Erasing the SPL 0 backup\n");
             run_command(cmd, 0);
            sprintf(cmd, "reset");
             printf(" Reset the Device and Boot the previous SPL\n");
	     *TEMP_PRM_RSTST = 0;
             run_command(cmd, 0);
        }
    }


    // Check the value and set the boot device accordingly
   if (*data == 1)
    {
       env_set("bootdev", "2");
	printf("Booting with ROOTFS 2 \r\n");
    }
    else
    {
        env_set("bootdev", "1");
	printf("Booting with ROOTFS 1 \r\n");
    }

}



/* create as environment variable */
U_BOOT_CMD(selectbootdev, 1, 0,Set_select_boot_dev,
        "It will Set the kernel Based on values present in FLash memory ","help");

U_BOOT_CMD(infloop, 1, 0, indefiniteloop,
        "It will hang the u-boot ","help");


#endif



====================================================================

umount /mnt

ubidetach -d 1

ubiformat /dev/mtd11

ubiattach /dev/ubi_ctrl -m 11 -d 1

ubimkvol /dev/ubi1 -N rootfs -s 260MiB

mount -t ubifs ubi1:rootfs /mnt/


after reboot
==============

ubiattach /dev/ubi_ctrl -m 11 -d 1
mount -t ubifs ubi1:rootfs /mnt

==========================================================================




======================================woriking-280============================

ubidetach -d 1

ubiformat /dev/mtd11

ubiattach /dev/ubi_ctrl -m 11 -d 1

ubimkvol /dev/ubi1 -N rootfs -s 254MiB
ubimkvol /dev/ubi1 -N rootfs -s 260MiB

mount -t ubifs ubi1:rootfs /mnt



after reboot
==============

ubiattach /dev/ubi_ctrl -m 11 -d 1
mount -t ubifs ubi1:rootfs /mnt/



=================================================================================


/run/media/mmcblk0p1

/home/zumi/tftp/new-partition

./arch/arm/dts/am437x-gp-evm.dts


2-os




device nand0 <nand.0>, # parts = 10
 #: name                size            offset          mask_flags
 0: NAND.SPL            0x00040000      0x00000000      0
 1: NAND.SPL.backup1    0x00040000      0x00040000      0
 2: NAND.SPL.backup2    0x00040000      0x00080000      0
 3: NAND.SPL.backup3    0x00040000      0x000c0000      0
 4: NAND.u-boot-1       0x00200000      0x00100000
 5: NAND.kernel-1       0x00a00000      0x00300000
 6: NAND.file-system-1  0x12c00000      0x00d00000
 7: NAND.u-boot-2       0x00200000      0x13900000
 8: NAND.kernel-2       0x00a00000      0x13b00000
 9: NAND.file-system-2  0x12c00000      0x14500000














/**********************************************/

Kernel Building method

/*********************************************/

fisrt-setup
===========

wget https://launchpad.net/gcc-arm-embedded/4.7/4.7-2013-q1-update/+download/gcc-arm-none-eabi-4_7-2013q1-20130313-linux.tar.bz2
tar -xjf gcc-arm-none-eabi-4_7-2013q1-20130313-linux.tar.bz2

cd /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts

export GCC_ARM_NONE_TOOLCHAIN=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/gcc-arm-none-eabi-4_7-2013q1
export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

./build_secdev.sh

cd -


linux build 
================
sudo apt-get update
sudo apt-get install bison flex build-essential libssl-dev
sudo apt-get install libyaml-dev

wget https://developer.arm.com/-/media/Files/downloads/gnu-a/8.3-2019.03/binrel/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf.tar.xz
tar -Jxvf gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf.tar.xz -C $HOM

export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH
export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

make distclean

make tisdk_am437x-evm-rt_defconfig

make -j8
 
recomplie dts
==========
Makefile
 make dtbs
 
  @$(if $(dtstree), \
                echo 'Devicetree:'; \
                echo '* dtbs             - Build device tree blobs for enabled boards'; \
                echo '  dtbs_install     - Install dtbs to $(INSTALL_DTBS_PATH)'; \
                echo '  dt_binding_check - Validate device tree binding documents'; \
                echo '  dtbs_check       - Validate device tree source files';\
                echo '')

install this 
============
sudo apt-get install libyaml-dev




build u-boot
========

wget https://developer.arm.com/-/media/Files/downloads/gnu-a/8.3-2019.03/binrel/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf.tar.xz
tar -Jxvf gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf.tar.xz -C $HOME

sudo apt-get update
sudo apt-get install bison flex build-essential libssl-dev



export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH
export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

make distclean

make am43xx_hs_evm_defconfig

make




make distclean

make am43xx_evm_defconfig

make -j8










export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/secure-binary-image.sh


===================

Goto following path

 

cd /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/linux-4.19.94+gitAUTOINC+be5389fd85-gbe5389fd85

 

Execute following commands

 

-- export ARCH=arm CROSS_COMPILE=/home/gauravmore/Working/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-

export ARCH=arm CROSS_COMPILE=/home/mahesh/Working/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-

-- export PATH=$/home/gauravmore/Working/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

export PATH=/home/mahesh/Working/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

-- export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- export TI_SECURE_DEV_PKG=/home/gauravmore/Working/TI_Keys_board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- make distclean

 

-- make tisdk_am437x-hs-evm_defconfig // tisdk_am437x-evm-rt_defconfig

 

-- make

 

/* To make Uimage with Load Address */

 

make ARCH=arm CROSS_COMPILE=/home/gaurav/Working/Softwares/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf- uImage LOADADDR=0X80008000

 

This will create uImage with load addr mentioned above.

Install module path

make INSTALL_MOD_PATH=/home/mahesh/Working/ modules_install

 

Building External Modules:

------------------------

https://stackoverflow.com/questions/26581161/make-modules-install-restarts-configuration-process-for-cross-compile

 

This is incotinuation with the above sequence. this is to build external modules means other version of fileystem with kernel.

 

make ARCH=arm CROSS_COMPILE=/home/gaurav/Working/Softwares/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf -C /lib/modules/`uname -r`/build M=$PWD

21111

make ARCH=arm CROSS_COMPILE=/home/gaurav/Working/Softwares/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf- 







nand read 0x403018e0 0x40000 0x2a874

go 0x403018e0















/home/zumi/tftp/working-backup

include/ctype.h

nand read and load commant
==============================

nand read 0x82000000 0x00300000 0x00700000

bootz 0x82000000


nand read 0x90000000 0x300000 0x700000
bootm 0x90000000


fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel 0x4daff6

nand read 0x82000000 NAND.file-system 0x2800
md 0x82000000 0x2800

-----------------
am43xx_hs_evm_defconfig:CONFIG_SYS_NAND_U_BOOT_OFFS=0x00180000
--------------

//abin

/etc/init.d/networking restart

systemctl restart networking

sudo dhclient -r eth0   
sudo dhclient eth0      

ethernet init

nmcli device disconnect eth0   
nmcli device connect eth0     

ethtool eth0          
dmesg | grep eth      


systemctl restart NetworkManager
   



u-boot env default
===========
env default -a




=================================build commants for am4376==============================

 

 

Steps to build and install the secdev SDL Ver 6.03 :

=====================================================

Before initiatin install 

sudo apt-get install lib32ncurses5 lib32z1

 

1. Download the latest Secdev SDK Version 06.03.00.106 from (https://www.ti.com/tool/download/PROCESSOR-SDK-LINUX-AM437X/06.03.00.106)

 

2. Install ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106-Linux-x86-Install.bin using follwing steps

 

  1. Go to the folder location where ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106-Linux-x86-Install.bin is installed

  2. Exceute follwing commands

                chmod 777 ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106-Linux-x86-Install.bin

                ./ti-processor-sdk-linux-am4F37x-hs-evm-06.03.00.106-Linux-x86-Install.bin

  3. SDK will be installed in /opt folder

 

3. Follow the below steps to install the setup

 

  1. cd /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106

  2. ./setup.sh

 

 

 

----For Creating ppa file ---------

 

 

 

/*********************************/

Method to build ppa_am43xx.bin

/*********************************/

 

1. Goto to below path

 

/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts

 

2. Follow below process


gcc install link 
================
wget https://launchpad.net/gcc-arm-embedded/4.7/4.7-2013-q1-update/+download/gcc-arm-none-eabi-4_7-2013q1-20130313-linux.tar.bz2
tar -xjf gcc-arm-none-eabi-4_7-2013q1-20130313-linux.tar.bz2

export GCC_ARM_NONE_TOOLCHAIN=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/gcc-arm-none-eabi-4_7-2013q1
export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

./build_secdev.sh

================
 

-- export GCC_ARM_NONE_TOOLCHAIN=/home/mahesh/Working/OneDrive_1_15-5-2024/gcc-arm-none-eabi-4_7-2013q1-20130313-linux/gcc-arm-none-eabi-4_7-2013q1

 

-- export GCC_ARM_NONE_TOOLCHAIN=/home/gauravmore/Working/Compilers/gcc-arm-none-eabi-4_7-2013q1-20130313-linux/gcc-arm-none-eabi-4_7-2013q1

 

-- export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- export TI_SECURE_DEV_PKG=/home/gauravmore/Working/TI_Keys_board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- ./build_secdev.sh

 

A successful build for AM43xx, results in creation of out/optee/am43xx/ppa_am43xx.bin.

 

 

 

 

/**************************************************/

Method to create u-boot image in HS

/**************************************************/

https://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/Foundational_Components_U-Boot.html

 

1. Got to the below path

 

cd /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/u-boot-2019.01+gitAUTOINC+333c3e72d3-g333c3e72d3

 

2. set the following paths by using following commands

gcc install link
================
wget https://developer.arm.com/-/media/Files/downloads/gnu-a/8.3-2019.03/binrel/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf.tar.xz
tar -Jxvf gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf.tar.xz -C $HOME

sudo apt-get update
sudo apt-get install bison flex build-essential libssl-dev



export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH
export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

make distclean

make am43xx_hs_evm_defconfig

make

===============

 

-- export ARCH=arm CROSS_COMPILE=/home/gauravmore/Working/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-

 

-- export ARCH=arm CROSS_COMPILE=/home/gaurav/Working/Softwares/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-

 

-- export ARCH=arm CROSS_COMPILE=/opt/ti-processor-sdk-linux-am437x-evm-09.01.00.001/external-toolchain-dir/arm-gnu-toolchain-11.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-

 

-- export PATH=$/home/gauravmore/Working/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

 

-- export PATH=$/home/gauravmore/Working/Compilers/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

 

-- export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- export TI_SECURE_DEV_PKG=/home/gauravmore/Working/TI_Keys_board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- export TI_SECURE_DEV_PKG=/opt/TI_Keys_board-support/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

 

-- make distclean

 

-- make am43xx_hs_evm_defconfig

 

-- make

 

This will build the secure images of MLO and u-boot.img

 

As a result the u-boot image will be created inside the u-boot-2019.01+gitAUTOINC+333c3e72d3-g333c3e72d3 folder








====================================================================

nand scrub.chip

am4376-crosse compile 
=========================
include/ctype.h

sudo chmod +x scripts/*.sh


./arch/arm/dts/am437x-gp-evm.dts


export CC=/opt/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
sudo make ARCH=arm CROSS_COMPILE=${CC} distclean

///
sudo make ARCH=arm CROSS_COMPILE=${CC} am43xx_evm_defconfig
///


sudo make ARCH=arm CROSS_COMPILE=${CC} am43xx_hs_evm_defconfig
sudo make ARCH=arm CROSS_COMPILE=${CC}





flash u-boot for kernle in am4376
-------------------------------
nand scrub.chip //we get any bad block use this one 
nand erase.chip //erase all memory
nand erase.part NAND.SPL
nand erase.part NAND.u-boot
nand erase.part NAND.kernel
nand erase.part NAND.u-boot-spl-os
nand erase.part NAND.file-system 


nand erase.part NAND.SPL.backup1

fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL.backup1 0x2aa74


fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL 0x2a874

fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot 0x9E82C

fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel 0x4daff6

fatload mmc 0:1 0x82000000 rootfs.ubi
nand write 0x82000000 NAND.file-system 0xc7c0000

=========================================

fatload mmc 0:1 0x82000000 lnt_fs.ubi


nand erase.part NAND.SPL.backup1
nand erase.part NAND.u-boot-1
nand erase.part NAND.kernel-1
nand erase.part NAND.file-system-1



nand erase.part NAND.SPL.backup2
nand erase.part NAND.u-boot-2
nand erase.part NAND.kernel-2
nand erase.part NAND.file-system-2




fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL.backup1 0x2ac74


fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot-1 0x9edb8

fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel-1 0x4cdffa

fatload mmc 0:1 0x82000000 lnt_fs.ubi
nand write 0x82000000 NAND.file-system-1 0xc7c0000




fatload mmc 0:1 0x82000000 MLO1
nand write 0x82000000 NAND.SPL.backup2 0x2a874


fatload mmc 0:1 0x82000000 u-boot.img1
nand write 0x82000000 NAND.u-boot-2 0x9e9c4

fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel-2 0x4cdffa

fatload mmc 0:1 0x82000000 lnt_fs.ubi
nand write 0x82000000 NAND.file-system-2 0xc7c0000




     setenv spl_boot1 'if selectbootdev; test ${bootdev} -eq 1; then setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-1,4096; fi;'
 \
            spl_boot2=if selectbootdev; test ${bootdev} -eq 2; then setenv nandroot 'ubi0:rootfs rw ubi.mtd=NAND.file-system-2,4096'; fi; 





















fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL 0x2973D

fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot 0xBB408

fatload mmc 0:1 0x82000000 zImage
nand write 0x82000000 NAND.kernel 0x4CA200

fatload mmc 0:1 0x82000000 am437x-idk-evm.dtb
nand write 0x82000000 NAND.u-boot-spl-os 0x12159

fatload mmc 0:1 0x82000000 tisdk-base-image-am437x-evm.ubi        //fatload mmc 0:1 0x82000000 arago-base-tisdk-image-am437x-evm.ubi
nand write 0x82000000 NAND.file-system 0x3D40000


=============am4376 1gb nand===========

 vi ./common/autoboot.c



nand erase.part NAND.u-boot
fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot 0x9E82C
F
nand erase.part NAND.file-system 
fatload mmc 0:1 0x82000000 lnt_fs.ubi
nand write 0x82000000 NAND.file-system 0xC7C0000



=======================================================
nand erase.part NAND.kernel
fatload mmc 0:1 0x82000000 fitImage.itb
nand write 0x82000000 NAND.kernel 0x4daff6

=========================================
=========================================

linux flash commant for nand
----------------------------

/run/media/mmcblk0p1
flash_erase /dev/mtd1 0 0
nandwrite -p /dev/mtd1 MLO


flash_erase /dev/mtd5 0 0
nandwrite -p /dev/mtd5 fitImage.itb

flash_erase /dev/mtd8 0 0
nandwrite -p /dev/mtd8 fitImage.itb



flash_erase /dev/mtd8 0 0
nandwrite -p /dev/mtd8 /path/to/fitImage.itb


flash_erase /dev/mtd8 0 0
nandwrite -p /dev/mtd8 /path/to/fitImage.itb



flash_erase /dev/mtd9 0 0
nandwrite -p /dev/mtd9 /path/to/fitImage.itb




===============




sudo apt install gcc-arm-linux-gnueabihf


cross compile ABINASH
===============
arm-linux-gnueabihf-gcc -static server-board.c -o server-board




in linux nand flash commant
===========================

flash_erase /dev/mtdX 0 0
nandwrite -p /dev/mtdX <image-file>
cat /proc/mtd


ubi config file
==============
am437x-evm.conf


am4376-new-1gb-nand-build
============================
link
===
https://software-dl.ti.com/processor-sdk-linux/esd/docs/06_03_00_106/AM335X/linux/Overview_Building_the_SDK.html




BABY SMILE 

bme688 code link
================
https://itbrainpower.net/a-gsm/Arduino-BME688-sensor_basic_howto
https://www.hackster.io/dragos-iosub/arduino-bme280-sensor-how-to-115560




ubi config file am437x
am437x-evm.conf


bootcmd=ubi part NAND.file-system; ubifsmount ubi0:rootfs; ubifsload 0x80000000 boot/zImage; ubifsload 0x88000000 boot/am437x-idk-evm.dtb;



nand erase.part NAND.file-system && fatload mmc 0:1 0x82000000 rootfs.ubi && nand write 0x82000000 NAND.file-system 0x3D40000 && saveenv && reset

nand erase.part NAND.file-system && fatload mmc 0:1 0x82000000 tisdk-base-image-am437x-evm.ubi && nand write 0x82000000 NAND.file-system 0x3D40000 && saveenv && reset

ubi part NAND.file-system && ubifsmount ubi0:rootfs

zimage

bootz 0x80000000 - 0x88000000

uimage

bootm 0x80000000 - 0x88000000



ubifsload 0x80000000 boot/zImage
ubifsload 0x88000000 boot/am437x-idk-evm.dtb
mtdids=nand0=atmel_nand




set nandrootfstype "ubifs rootwait=10"

set nandroot "ubi0:rootfs rw ubi.mtd=NAND.file-system,2048"

set nandroot "ubi0:rootfs rw ubi.mtd=NAND.file-system,4096"


=> nand info

Device 0: nand0, sector size 128 KiB
  Page size         2048 b
  OOB size            64 b
  Erase size      131072 b
  ecc strength         8 bits
  ecc step size      512 b
  subpagesize        512 b
  options       0x4000400c
  bbt options   0x00008000

=============================================================================================================================

ubiformat /dev/mtd9        # Format the MTD partition
ubi part mtd9              # Specify the partition for UBI
ubi attach -m 9 -O 2048 /dev/ubi_ctrl   # Attach UBI to the partition
ubi info  


nand read 0x82000000 NAND.file-system 0x2800
md 0x82000000 0x2800   



meta-ti/conf/machine/am437x-evm.conf


nand erase.part NAND.u-boot-spl-os
fatload mmc 0:1 0x82000000 am437x-idk-evm.dtb
nand write 0x82000000 NAND.u-boot-spl-os 0x12159




=> editenv nandroot
edit: ubi0:rootfs rw ubi.mtd=NAND.file-system,2048 ubi.mtd=9
=> save


nandroot=ubi0:NAND.file-system rw ubi.mtd=9\0



flash u-boot for kernle in am4376
-------------------------------
nand erase.part NAND.SPL
nand erase.part NAND.u-boot
nand erase.part NAND.kernel
nand erase.part NAND.u-boot-spl-os
nand erase.part NAND.file-system 


fatload mmc 0:1 0x82000000 MLO
nand write 0x82000000 NAND.SPL 0x2973D

fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot 0xBB408

fatload mmc 0:1 0x82000000 zImage
nand write 0x82000000 NAND.kernel 0x4CA200

fatload mmc 0:1 0x82000000 am437x-idk-evm.dtb
nand write 0x82000000 NAND.u-boot-spl-os 0x12159

fatload mmc 0:1 0x82000000 tisdk-base-image-am437x-evm.ubi        //fatload mmc 0:1 0x82000000 arago-base-tisdk-image-am437x-evm.ubi
nand write 0x82000000 NAND.file-system 0x3D40000


=============am4376 1gb nand===========

 vi ./common/autoboot.c



nand erase.part NAND.u-boot
fatload mmc 0:1 0x82000000 u-boot.img
nand write 0x82000000 NAND.u-boot 0x9E82C

nand erase.part NAND.file-system 
fatload mmc 0:1 0x82000000 lnt_fs.ubi
nand write 0x82000000 NAND.file-system 0xC7C0000



=======================================================


209453056 size


nand write 0x82000000 NAND.file-system 0xa00000 0x80C0000

209453056


 0: NAND.SPL            0x00040000      0x00000000      0
 1: NAND.SPL.backup1    0x00040000      0x00040000      0
 2: NAND.SPL.backup2    0x00040000      0x00080000      0
 3: NAND.SPL.backup3    0x00040000      0x000c0000      0
 4: NAND.u-boot-spl-os  0x00080000      0x00100000      0
 5: NAND.u-boot         0x00100000      0x00180000      0
 6: NAND.u-boot-env     0x00040000      0x00280000      0
 7: NAND.u-boot-env.backup10x00040000   0x002c0000      0
 8: NAND.kernel         0x00700000      0x00300000      0
 9: NAND.file-system    0x1f600000      0x00a00000      0
 
run nandboot



fatload mmc 0:1 0x82000000 tisdk-base-image-am437x-evm.ext2.gz

tisdk-base-image-am437x-evm.ext2.gz



nand erase.part NAND.file-system 
fatload mmc 0:1 0x82000000 rootfs.ubi
nand write 0x82000000 NAND.file-system 0x3D40000

nand erase.part NAND.kernel && fatload mmc 0:1 0x82000000 zImage && nand write 0x82000000 NAND.kernel 0x4CA200 && saveenv && reset



=======================================================
ubiattach -m 11 -d 1 /dev/ubi_ctrl
	ubimkvol /dev/ubi1 -m -N rootfs
	ubiupdatevol /dev/ubi1_0 atc-gen2-core-atc-gen2
	mount -t ubifs ubi1:rootfs /mnt/
	ls /mnt
	umount /mnt	

==================================================
















nand u-boot

=> nand erase.part NAND.u-boot-spl-os





================================
am4376 rebuild command
-----------------------


sudo wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz

sudo tar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz

export CC=/home/zumi/Abinash/am4376_board_bringup_new_project/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-

make ARCH=arm CROSS_COMPILE=${CC} distclean


make ARCH=arm CROSS_COMPILE=${CC} am43xx_evm_defconfig

make ARCH=arm CROSS_COMPILE=${CC} am43xx_hs_evm_defconfig

make ARCH=arm CROSS_COMPILE=${CC}


====================================================================================================================

customer u-boot soure code crose complie build
------------------------------------------------------
link
https://forum.digikey.com/t/debian-getting-started-with-the-am437x-evm/12456

1
uboot@openwrt:/opt$ sudo wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz
2
uboot@openwrt:/opt$ sudo tar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz
3
uboot@openwrt:/opt/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin$ export CC=/opt/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
4
uboot@openwrt:/opt/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin$ ${CC}gcc --version
5
uboot@openwrt:/U-boot-9.0.1/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2$ make ARCH=arm CROSS_COMPILE=${CC} distclean
6
uboot@openwrt:/U-boot-9.0.1/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2$ make ARCH=arm CROSS_COMPILE=${CC} am43xx_eth_defconfig

7
uboot@openwrt:/U-boot-9.0.1/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2$ make ARCH=arm CROSS_COMPILE=${CC}






./arch/arm/dts/am437x-gp-evm.dts


export CC=/opt/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
make ARCH=arm CROSS_COMPILE=${CC} distclean

make ARCH=arm CROSS_COMPILE=${CC} am43xx_evm_defconfig
make ARCH=arm CROSS_COMPILE=${CC} am43xx_hs_evm_defconfig
make ARCH=arm CROSS_COMPILE=${CC}









 

------------------------------------------------------------------------
mlo flash  c file link mlo send using xmodarm
https://e2e.ti.com/support/processors-group/processors/f/processors-forum/436686/download-the-u-boot-spl-to-am437x-gp-evm-via-uart

sudo picocom -b 115200 /dev/ttyUSB0 --send-cmd "sx -vv"
https://forum.digikey.com/t/ccc-is-not-displayed-in-uart0-booting-mode/8438/10


vendor=ti
ver=U-Boot 2019.01-g333c3e72d3 (Jul 15 2024 - 06:40:49 +0000)

Environment size: 3550/262140 bytes
=> editenv mtdparts
edit: mtdparts=davinci_nand.0:1024k(bootloader)ro,512k(params)ro,310M(ub=> <INTERRUPT>)l)
=> editenv mtdparts
edit: mtdparts=davinci_nand.0:1024k(bootloader)ro,512k(params)ro,310M(ubifs)ro,200M(kernel)
=> pri mtdparts
mtdparts=mtdparts=davinci_nand.0:1024k(bootloader)ro,512k(params)ro,310M(ubifs)ro,200M(kernel)
=> mtdparts 



u-boot env default
===========
env default -a


sw-description for nand link

https://sbabic.github.io/swupdate/sw-description.html


find . -type f -iname "*k2e*.dts"
find . A-type f -iname "*k2e*.dts" -exec grep -H "nand" {} +


custmer u-boot code 
=====================
dts - am437x-eth.dts


nand read commant 
---------------------

mtd_debug read /dev/mtd4 0 534249472 /path/to/output_file
mtdinfo 


clone branch
=======================================
git clone -b thud https://github.com/sbabic/meta-swupdate.git



nand partion on dts in linux
----------------------------
~/Abinash/swupdate/k2e/tisdk/build/arago-tmp-external-arm-toolchain/work-shared$ vi ./k2e-evm/kernel-source/arch/arm/boot/dts/keystone-k2e-evm.dts

                       
working
------------------                       
                       
                         partition@180000 {
                                label = "ubifs";
                                reg = <0x180000 0x1FD80000>;
                        };
                        partition@1ff00000 {
                                label = "kernal";
                                reg = <0x1ff00000 0x100000>;
                        };            
                       
                       
                       
                       
                       
                        partition@0 {
                                label = "u-boot";
                                reg = <0x0 0x100000>;
                                read-only;
                        };

                        partition@100000 {
                                label = "params";
                                reg = <0x100000 0x80000>;
                                read-only;
                        };
                        partition@180000 {
                                label = "ubifs0";
    /100                            reg = <0x180000 0x6400000>;
                        };
                        partition@6580000 {
   /100                             label = "ubifs1";
                                reg = <0x6580000 0x6400000>;
                        };
                        partition@c980000 {
                                label = "ubifs2";
  /100                              reg = <0xc980000 0x6400000>;
                        };
                        partition@12d80000 {
                                label = "ubifs3";
   /210.5                             reg = <0x12d80000 0xd200000>;
                        };


                           partition@0 {
                                label = "u-boot";
                                reg = <0x0 0x100000>;
                                read-only;
                        };

                        partition@100000 {
                                label = "params";
                                reg = <0x100000 0x80000>;
                                read-only;
                        };
                        partition@180000 {
     /310.5                           label = "ubifs0";
                                reg = <0x180000 0x13680000>;
                        };
                        partition@13800000 {
                                label = "ubifs1";
   /200                             reg = <0x13800000 0xc800000>;
                        };



                        partition@0 {
                                label = "u-boot";
                                reg = <0x0 0x100000>;
                                read-only;
                        };

                        partition@100000 {
                                label = "params";
                                reg = <0x100000 0x80000>;
                                read-only;
                        };
                        partition@180000 {
                                label = "ubifs0";
//410.5                                reg = <0x180000 0x19a80000>;
                        };
                        partition@19c00000 {
//100                                label = "ubifs1";
                                reg = <0x19c00000 0x6400000>;
                        };








memory calculat
------------------

hex 0x100000 = 1048576 dec

1048576/1024 = 1024 kB

1024/1024    = 1 MB



hex 0x10000 = 65536 dec

65536/1024 = 64 KB

 	






jtag flash for k2e board
======================== ====


zumipc@Abinash:~/Abinash/sw-update/k2E/pre-build/ti-processor-sdk-linux-k2e-evm-bin-06.03.00.106/board-support/prebuilt-images$ 
zumipc@Abinash:~/Abinash/sw-update/k2E/pre-build/ti-processor-sdk-linux-k2e-evm-bin-06.03.00.106/bin/program_evm$ $DSS_SCRIPT_DIR/dss.sh program_evm.js evmk2e-le nor


flow this steps 
https://www.ti.com/video/5486552249001#tab-1


boot switch all up no boot mode 1111

flashing port is j3 

download this 2

CCS9.3.0.00012_linux-x64.tar.gz /using this to install the code composer studio 

k2e-evm-linux-sdk-bin-06.03.00.106.tar.xz

export DSS_SCRIPT_DIR=export DSS_SCRIPT_DIR=/home/zumipc/ti/ccs930/ccs/ccs_base/scripting/bin
export PROGRAM_EVM_TARGET_CONFIG_FILE=configs/evmk2e/evmk2e-linuxhost.ccxml
$DSS_SCRIPT_DIR/dss.sh program_evm.js evmk2e-le nor



k2e build steps
==================

https://software-dl.ti.com/processor-sdk-linux/esd/docs/06_03_00_106/linux/Overview_Building_the_SDK.html


git clone git://git.ti.com/arago-project/oe-layersetup.git tisdk
$ cd tisdk
$ ./oe-layertool-setup.sh -f configs/processor-sdk/processor-sdk-06.03.00.106-config.txt
$ cd build
$ . conf/setenv
$ export TOOLCHAIN_PATH_ARMV7=$HOME/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf
$ export TOOLCHAIN_PATH_ARMV8=$HOME/gcc-arm-8.3-2019.03-x86_64-aarch64-linux-gnu
$ MACHINE=k2e=evm bitbake arago-base-tisdk-image

re-compile

MACHINE=k2e-evm bitbake -C compile u-boot-ti-staging
MACHINE=k2e=evm bitbake -C compile arago-base-tisdk-image

sir image
MACHINE=k2e-evm bitbake arago-console-image



1.2.3. Processor SDK Build Reference




https://www.ti.com/video/5486552249001#tab-1





spi
===============

setenv default -f -a          
  setenv serverip 192.168.0.172
  setenv boot ubi              
  setenv mem_reserve 1536M     

 run get_uboot_net        
 run burn_uboot_spi
 
  run get_ubi_net  
  
  run burn_ubi   
 

dhcp 0x82000000  u-boot-spi-k2e-evm.gph


u-boot nand
=======================

 run get_uboot_net 
 
 run burn_uboot_nand
 






nand
===================

setenv ipaddr 192.168.0.118

 setenv serverip 192.168.0.120
 
 setenv gatewayip 192.168.0.1
 

run get_ubi_net && run burn_ubi  && saveenv && reset 
 
 saveenv
 
 reset

dhcp 0x87000000











  libconfig \
    swupdate  \
    swupdate-www  \


















 1850  mv linux-4.19.94+gitAUTOINC+be5389fd85-gbe5389fd85 linux-4.19.94+gitAUTOINC+be5389fd85-g
 1853  mv linux-4.19.94+gitAUTOINC+be5389fd85-g linux-4.19.94+gitAUTOINC+be5389fd85-gbe5389fd85
 1854  mv linux-4.19.94+gitAUTOINC+be5389fd85-gbe5389fd85 linux-4.19.94+gitAUTOINC+be5389fd85-g
 1863  mv linux-4.19.94+gitAUTOINC+be5389fd85-gbe5389fd85 linux-4.19.94+gitAUTOINC+be5389fd85-g
 1965  mv u-boot-2019.01+gitAUTOINC+333c3e72d3-g333c3e72d3 u-boot-2019.01+gitAUTOINC+333c3e72d3-g






DEBUG: Executing shell function populate_srcipk_package
cp: cannot stat '/home/zumi/Abinash/swupdate/k2e/tisdk/build/arago-tmp-external-arm-toolchain/work/k2e_evm-linux-gnueabi/linux-ti-staging/4.19.94+gitAUTOINC+be5389fd85-r10a.arago5.tisdk1.1/srcipk-staging/board-support/linux-4.19.94+gitAUTOINC+be5389fd85-g/.': No such file or directory
WARNING: /home/zumi/Abinash/swupdate/k2e/tisdk/build/arago-tmp-external-arm-toolchain/work/k2e_evm-linux-gnueabi/linux-ti-staging/4.19.94+gitAUTOINC+be5389fd85-r10a.arago5.tisdk1.1/temp/run.populate_srcipk_package.26036:1 exit 1 from 'cp -Prf --preserve=mode,timestamps --no-preserve=ownership /home/zumi/Abinash/swupdate/k2e/tisdk/build/arago-tmp-external-arm-toolchain/work/k2e_evm-linux-gnueabi/linux-ti-staging/4.19.94+gitAUTOINC+be5389fd85-r10a.arago5.tisdk1.1/srcipk-staging/board-support/linux-4.19.94+gitAUTOINC+be5389fd85-g/. /home/zumi/Abinash/swupdate/k2e/tisdk/build/arago-tmp-external-arm-toolchain/work/k2e_evm-linux-gnueabi/linux-ti-staging/4.19.94+gitAUTOINC+be5389fd85-r10a.arago5.tisdk1.1/packages-split/linux-ti-staging-src/board-support/linux-4.19.94+gitAUTOINC+be5389fd85-g'
DEBUG: Python function do_package finished
ERROR: Function failed: populate_srcipk_package (log file is located at /home/zumi/Abinash/swupdate/k2e/tisdk/build/arago-tmp-external-arm-toolchain/work/k2e_evm-linux-gnueabi/linux-ti-staging/4.19.94+gitAUTOINC+be5389fd85-r10a.arago5.tisdk1.1/temp/log.do_package.26036)
                                                                                                                                                                                          456,1         Bot




linux-4.19.94+gitAUTOINC+be5389fd85-gbe5389fd85

branch=main

===================================================================================am4375 customer board=======================================


sw-update 
=========

u-boot link 

https://youtu.be/6sKLH95g4Do?si=rseXnNe8n4sedeIg


symbolic link

sudo ln -s /home/zumi/Abinash/swupdate/tisdk/build/arago-tmp-external-arm-glibc/work/armv7at2hf-neon-linux-gnueabi/mtd-utils/2.1.1-r0.arago1/package/usr/src/debug/mtd-utils/2.1.1-r0.arago1/git/include/* /home/zumi/Abinash/swupdate/tisdk/build/arago-tmp-external-arm-glibc/work/armv7at2hf-neon-linux-gnueabi/swupdate/2023.05-r0/git/include/

sudo ln -s /home/zumi/Abinash/swupdate/tisdk/build/arago-tmp-external-arm-glibc/work/armv7at2hf-neon-linux-gnueabi/mtd-utils/2.1.1-r0.arago1/package/usr/src/debug/mtd-utils/2.1.1-r0.arago1/git/include/* /home/zumi/Abinash/swupdate/tisdk/build/arago-tmp-external-arm-glibc/work/armv7at2hf-neon-linux-gnueabi/swupdate/2023.05-r0/git/include/


 grep "LAYERSERIES_COMPAT" * -r  package vertion

base image org .bb file

# Arago TI SDK base image with test tools
# Suitable for initramfs

require arago-image.inc

IMAGE_FSTYPES += "cpio.xz"
IMAGE_FSTYPES_append_dra7xx = " ubifs ubi"

IMAGE_INSTALL += "\
    packagegroup-arago-base \
    packagegroup-arago-console \
    packagegroup-arago-base-tisdk \
    ${VIRTUAL-RUNTIME_initramfs} \
    swupdate \
    swupdate-www \

    "

export IMAGE_BASENAME = "tisdk-base-image"
                                                                                                                                       
           




sir link build link 
-------------------
https://software-dl.ti.com/processor-sdk-linux/esd/AM437X/07_03_00_005/exports/docs/linux/Overview_Building_the_SDK.html#quick-start

one time
********

sudo apt-get install build-essential autoconf automake bison flex libssl-dev bc u-boot-tools python diffstat texinfo gawk chrpath dos2unix wget unzip socat doxygen libc6:i386 libncurses5:i386 libstdc++6:i386 libz1:i386 g++-multilib


sudo dpkg-reconfigure dash     // give no




wget https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf.tar.xz
tar -Jxvf gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf.tar.xz -C $HOME
wget https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz
tar -Jxvf gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu.tar.xz -C $HOME



--------

git clone git://arago-project.org/git/projects/oe-layersetup.git tisdk

cd tisdk

./oe-layertool-setup.sh -f configs/coresdk/coresdk-07.03.00.005-config.txt

cd build

. conf/setenv

export TOOLCHAIN_PATH_ARMV7=$HOME/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf

export TOOLCHAIN_PATH_ARMV8=$HOME/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu

MACHINE=<machine> bitbake tisdk-base-image


modify commands 
=====================

git clone git://git.ti.com/arago-project/oe-layersetup.git tisdk

cd tisdk

./oe-layertool-setup.sh -f configs/processor-sdk/processor-sdk-07.03.00.005-config.txt

cd build/

. conf/setenv
export TOOLCHAIN_PATH_ARMV7=$HOME/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf
export TOOLCHAIN_PATH_ARMV8=$HOME/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu

MACHINE=am437x-evm bitbake -k tisdk-base-image


MACHINE=am437x-evm bitbake -c cleanall tisdk-base-image


file     .bb

./meta-arago/meta-arago-distro/recipes-core/images/tisdk-base-image.bb

u-boot-ti-staging_2021.01.bb


bitbake server issues

ps aux | grep bitbake

sudo kill -9 16578





3. Forcing Reconfiguration & Recompilation

    Clean and rebuild:

    bitbake libarchive-native -c clean
    bitbake libarchive-native -c configure -f
    bitbake libarchive-native

4. Checking for Missing Dependencies

    Run:

bitbake libarchive-native -c deps
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






























=============================no no
TI AM4376 RT-linux swupdate (schneider electric)

build link
=========


https://www.ti.com/tool/PROCESSOR-SDK-AM437X#downloads

https://software-dl.ti.com/processor-sdk-linux-rt/esd/AM437X/09_01_00_001/exports/docs/linux/Overview_Building_the_SDK.html

commands:
*********


sudo apt-get update


sudo apt-get -f -y install \
    git build-essential diffstat texinfo gawk chrpath socat doxygen \
    dos2unix python3 bison flex libssl-dev u-boot-tools mono-devel \
    mono-complete curl python3-distutils repo pseudo python3-sphinx \
    g++-multilib libc6-dev-i386 jq git-lfs pigz zstd liblz4-tool \
    cpio file zstd lz4



git clone https://git.ti.com/git/arago-project/oe-layersetup.git tisdk

cd tisdk

./oe-layertool-setup.sh -f configs/processor-sdk/processor-sdk-09.01.00-config.txt


cd build

. conf/setenv

MACHINE=am437x-evm bitbake -ktisdk-default-image  

MACHINE=am437x-evm bitbake -k tisdk-default-image  

MACHINE=am437x-evm bitbake  -c cleanall  tisdk-default-image  

 -c cleanall 













---------------------------------------------------------------------------------------------

1)Compress

tar -cvf archive_name.tar /path/to/directory_or_files      // log

tar -cjf archive_name.tar /path/to/directory_or_files      //no log


Decompress

tar -xvf archive_name.tar                                 //log

tar -xjf archive_name.tar                                 //no log




----------------------------
2)compress

tar -cJf archive_name.tar.xz /path/to/directory_or_files

Decompress

tar -xJf archive_name.tar.xz                  // no log

tar -xvJf archive_name.tar.xz                     // log

----------------------------------
3)

# To extract:
tar -xzf openssl-1.1.1k.tar.gz

# To compress:
tar -czf openssl-1.1.1k.tar.gz openssl-1.1.1k/


extract multifull file in same time 
==============================
for file in ../*.tar.gz; do tar -xzf "$file" -C ./; done

-------------------
file only not folder 
--------------------
3)compress

xz filename

Decompress
xz -d filename.xz


4)compress
zip -r my_archive.zip my_folder

decompress
unzip 26Aug2024_ISSI_Executables.zip


5)

tar -xjf make-4.1.tar.bz2




6)

sudo apt-get update
sudo apt-get install unrar

unrar x Pro_Orbit_STM32H7_Release.rar









dd if=/dev/zstis-001-image-am62xx-evm-20240606061617.rootfs.wic of=/dev/mmcblk0 bs=4M


u-boot issues build image am62x

https://software-dl.ti.com/processor-sdk-android/esd/AM62X/09_01_00/docs/android/Overview_Flashing.html#step-5-flashing-instructions

--------------------------------
env default -f -a; saveenv;

setenv force_avb "1"; saveenv;



ospi nor




sudo cp /media/zumipc/boot/tiboot3-am62x-gp-evm.bin /media/zumipc/boot/tiboot3.bin



boot mode sk-am62
https://software-dl.ti.com/mcu-plus-sdk/esd/AM62X/latest/exports/docs/api_guide_am62x/EVM_SETUP_PAGE.html


================================================================================================


setenv testvar testvalue


fw_setenv mmcdev 0

fw_printenv mmcdev


setenv fdt_file imx8qxp-mek-rpmsg.dtb


mmcblk0boo0
============





echo 0 > /sys/class/block/mmcblk0/force_ro

dd if=imx-boot-imx8qxpmek-sd.bin-flash of=/dev/mmcblk0boot0 bs=512 seek=2


echo 1 > /sys/class/block/mmcblk0boot0/force_ro



mmc bootpart enable 1 1 /dev/mmcblk0


========

mmcblk0boot1


echo 0 > /sys/class/block/mmcblk0boot0/force_ro

dd if=imx-boot-imx8qxpmek-sd.bin-flash of=/dev/mmcblk0boot0 bs=512 seek=2


echo 1 > /sys/class/block/mmcblk0boot0/force_ro



mmc bootpart enable 1 1 /dev/mmcblk0






clear memory

echo 0 > /sys/class/block/mmcblk0/force_ro

dd if=/dev/zero of=/dev/mmcblk0 bs=1M conv=fsync



dd if=/dev/zero of=/dev/mmcblk0 bs=1k seek=384 conv=fsync count=129

dd if=/dev/zero of=/dev/mmcblk0boot1 bs=1k seek=384 conv=fsync count=129

echo 0 > /sys/class/block/mmcblk0/force_ro

dd if=/dev/zero of=/dev/mmcblk0p1 bs=1k seek=384 conv=fsync count=129

dd if=/dev/zero of=/dev/mmcblk0p2 bs=1k seek=384 conv=fsync count=129





#!/bin/bash

# Disable read-only mode on boot partition
echo 0 > /sys/class/block/mmcblk0boot0/force_ro

# Read the boot partition
dd if=/dev/mmcblk0boot0 of=boot0.bin bs=8M count=2048

# Re-enable read-only mode on boot partition
echo 1 > /sys/class/block/mmcblk0boot0/force_ro

# Verify the contents
hexdump -C boot0.bin




sudo dd if=/dev/mmcblk0boot0 of=~/mmcblk0boot0_backup.img bs=4M status=progress




dd if=/dev/mmcblk0boot0 bs=8M count=2048 | hexdump -C > boot0.txt

dd if=/dev/mmcblk0boot1 bs=2k count=2048 | hexdump -C > boot1.txt

dd if=/dev/mmcblk0p1 bs=2k count=2048 | hexdump -C > p1.txt

dd if=/dev/mmcblk0p2 bs=2k count=2048 | hexdump -C > p2.txt





dd if=imx-boot-imx8qxpmek-sd.bin-flash_spl bs=2k count=2048 | hexdump -C > image.txt




read all

dd if=/dev/mmcblk1 bs=8M | hexdump -C > boot0.txt



echo 0 > /sys/class/block/mmcblk0boot0/force_ro


dd if=/dev/mmcblk0boot0 bs=8M | hexdump -C > boot1.txt



echo 1 > /sys/class/block/mmcblk0boot0/force_ro








google not working like wget r git clone 
=======================================

bad address error comming means 
------------------------------

ls -lh /etc/resolv-conf.systemd
rm /etc/resolv.conf
echo "nameserver 8.8.8.8" > /etc/resolv.conf
ping google.com

after also not working try this
==================================
 sudo dhclient -v









sudo mmc extcsd read /dev/mmcblk0 | grep -i 'boot'




google chrome install in linux
==============================

wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb

sudo dpkg -i google-chrome-stable_current_amd64.deb

sudo apt-get install -f

google-chrome








emmc single copy
============================

setenv bootslot singlenormal
save
setenv mmcdev 0
save

emmc dual copy
============================


setenv bootslot dualB
save
setenv mmcdev 0
save


sdcard
================================

setenv bootslot dualA
save
setenv mmcdev 1
save



setenv bootcmd 'mmc dev 0; ext4load mmc 0:1 0x80000000 /boot/uImage; bootm 0x80000000'



unzip commant 

tar -xvzf ../Abinash/image_assembling_imx8qxpmek.tgz






sd card flash commant imx8qxp

sudo dd if=fsl-image-validation-imx-imx8qxpmek.sdcard of=/dev/sdb bs=4M status=progress conv=fsync









off set calclution 
===================================



0x6e000 in hexadecimal is equivalent to 450560 in decimal.

To convert this to kilobytes, divide by 1024 (1KB = 1024 bytes):

Offset in KB=4505601024=440 KBOffset in KB=1024450560​=440 KB

So, the offset you need to specify is 440 KB.






echo 0 > /sys/block/mmcblk0boot0/force_ro


echo 0 > /sys/block/mmcblk0p4/force_ro




dd if=imx-boot-imx8qxpmek-sd.bin-flash_spl of=/dev/mmcblk0boot0 bs=1K seek=440

dd if=imx-boot-imx8qxpmek-sd.bin-flash_spl of=/dev/mmcblk0boot0 bs=1K seek=398

echo 1 > /sys/block/mmcblk0boot0/force_ro

dd if=/dev/mmcblk0boot0 bs=1K skip=440 count=1 | hexdump -C


dd if=/dev/mmcblk0boot0 bs=1K skip=398 count=1 | hexdump -C


dd if=imx-boot-imx8qxpmek-sd.bin-flash_spl bs=1K skip=0 count=1 | hexdump -C


reboot






binary to hexa

hexdump -C file






sw-update imx8mm imx8qxbomek
===================================

./x86_64-linux/qemu-native/6.2.0-r0/qemu-6.2.0/roms/u-boot/arch/arm/mach-imx/imx8/image.c
./x86_64-linux/u-boot-tools-native/1_2022.01-r0/git/arch/arm/mach-imx/image-container.c






u-boot
============




struct mmc {
#if !CONFIG_IS_ENABLED(BLK)
        struct list_head link;
#endif
        const struct mmc_config *cfg;   /* provided configuration */
        uint version;
        void *priv;
        uint has_init;
        int high_capacity;
        bool clk_disable; /* true if the clock can be turned off */
        uint bus_width;
        uint clock;
        uint saved_clock;
        enum mmc_voltage signal_voltage;
        uint card_caps;
        uint host_caps;
        uint ocr;
        uint dsr;
        uint dsr_imp;
        uint scr[2];
        uint csd[4];
        uint cid[4];
        ushort rca;
        u8 part_support;
        u8 part_attr;
        u8 wr_rel_set;
        u8 part_config;
        u8 gen_cmd6_time;       /* units: 10 ms */
        u8 part_switch_time;    /* units: 10 ms */
        uint tran_speed;
        uint legacy_speed; /* speed for the legacy mode provided by the card */
        uint read_bl_len;
#if CONFIG_IS_ENABLED(MMC_WRITE)
        uint write_bl_len;
        uint erase_grp_size;    /* in 512-byte sectors */
#endif
#if CONFIG_IS_ENABLED(MMC_HW_PARTITIONING)
        uint hc_wp_grp_size;    /* in 512-byte sectors */
#endif
#if CONFIG_IS_ENABLED(MMC_WRITE)
        struct sd_ssr   ssr;    /* SD status register */
#endif
        u64 capacity;
        u64 capacity_user;
        u64 capacity_boot;
        u64 capacity_rpmb;
        u64 capacity_gp[4];
#ifndef CONFIG_SPL_BUILD
        u64 enh_user_start;
        u64 enh_user_size;
#endif











unsigned long spl_mmc_get_uboot_raw_sector(struct mmc *mmc,
                                           unsigned long raw_sect)
{
        int end;

        end = get_imageset_end(mmc, MMC_DEV);
        end = ROUND(end, SZ_1K);

        printf("Load image from MMC/SD 0x%x\n", end);

        return end / mmc->read_bl_len;
}






===========================================================================================================
dtb

~/fsl-release-bsp-5.15.32/build-xwayland-swupdate/tmp/work/imx8qxpmek-poky-linux/linux-imx/5.15.32+gitAUTOINC+fa6c316859-r0/build/arch/arm64/boot/dts/freescale

Kernel

~/fsl-release-bsp-5.15.32/build-xwayland-swupdate/tmp/work/imx8qxpmek-poky-linux/linux-imx/5.15.32+gitAUTOINC+fa6c316859-r0/build/arch/arm64/boot


build 


 DISTRO=fsl-imx-wayland MACHINE=imx8qxpmek source imx-setup-release.sh -b build-xwayland-swupdate

 bitbake -c clean swupdate-image 
 
 bitbake swupdate-image 
 
 bitbake -c clean core-image-base
 
 bitbake core-image-base
 
 bitbake -f -D u-boot-imx -c compile
 
 bitbake -c clean imx-boot
 
 
 

 bitbake -f imx-boot -c compile


bitbake -c clean meta-environment-extsdk-imx8qxpmek

bitbake imx8qxp-mek

bitbake -c compile linux-imx


bitbake -C compile linux-imx

bitbake -C compile u-boot-imx 










ln -s /home/zumi/fsl-release-bsp-5.15.32/build-xwayland-swupdate/tmp/deploy/images/imx8qxpmek/ slota
ln -s /home/zumi/fsl-release-bsp-5.15.32/build-xwayland-swupdate/tmp/deploy/images/imx8qxpmek/ slotb









sdcard boot

  setenv mmcdev 1
  saveenv 
  setenv bootslot dualA
  saveenv 
 
 
 emmc singl copy 
 ===============
 
 setenv mmcdev 0
 save
 setenv bootslot singlenormal
 save
 
 
 emmc dual copy 
 ==================
  
 setenv mmcdev 0
 save
 setenv bootslot dualB
 save
 




u-boot


swupdate -l TRACE  -i imx8qxpevk.swu -e "stable,mmcblk0p2"

setenv testvar testvalue

setenv testvar testvalue

fw_printenv

In Linux:
fw_setenv bootslot singlerescue
fw_setenv upgrade_available 1
reboot 	




fw_setenv bootslot singlerescue
fw_setenv upgrade_available 1
reboot










flash commant 
=======================================


sudo ./uuu -b emmc_all swupdate-image-imx8qxpmek-20240520123504.rootfs.wic.bz2 
[sudo] password for zumipc: 
uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.5.181-0-gd362f4a

Success 1    Failure 0                                                                                                                                                                                     
                                                                                                                                                                                                            
                                                                                                                                                                                                            
2:43-        3/ 3 [=================100%=================] SDPV: jump -scanlimited 0x800000                                                                                                                 
2:43-1F0A800 1/ 1 [=================100%=================] SDPS: boot -scanterm -f swupdate-image-imx8qxpmek-20240520123504.rootfs.wic.bz2/* /-scanlimited 0x800000                                          
2:43-1F0A800 8/ 8 [Done                                  ] FB: done                                                                                                                                         







Environment size: 5738/16380 bytes
u-boot=> editenv fdtfile     
edit: imx8mm-evk.dtb    
u-boot=> saveenv 
Saving Environment to MMC... Writing to MMC(2)... OK
u-boot=> reset
resetting ...








web_server 

killall swupdate

echo "imx8mmevk 1.0" > /etc/hwrevision

swupdate -v -w "-r /www -p 8080"

http://192.168.0.153:8080/


fw_setenv bootslot singlerescue
fw_setenv upgrade_available 1
reboot












echo "imx8mmevk 1.0" > /etc/hwrevision


/etc/fw_env.config
echo -e "/dev/mmcblk2 0x400000 0x2000"  "/dev/mmcblk2 0x402000 0x2000" > /etc/fw_env.config
echo "/dev/mmcblk2 0x402000 0x2000" > /etc/fw_env.config




~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/work/armv8a-poky-linux/swupdate/2022.05-r0/git/core$ vi parser.c
~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/work/armv8a-poky-linux/swupdate/2022.05-r0/image/usr/bin
bitbake -c menuconfig swupdate


sw_update link 

zumi@zumi-H81M-S:~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/work/armv8a-poky-linux/swupdate/2022.05-r0/git$ vim core/parser.c 


f

sir link

https://sbabic.github.io/swupdate/swupdate.html


https://community.nxp.com/t5/CodeWarrior-for-MCU/rtshc08-c-MC9S08GB60-bootloader-in-C/td-p/130737

https://community.nxp.com/t5/i-MX-Processors-Knowledge-Base/SWUpdate-OTA-i-MX8MM-EVK-i-MX8QXP-MEK/ta-p/1307416


==============




CONFIG_SYS_MMC_ENV_PART

https://forum.elk.audio/t/how-to-install-from-a-local-swu-file-via-shell-command/742


swupdate -c -i my-software_1.0.swu




cpio -idv < my-software_1.0.swu

WIFI_FIRMWARE=y DISTRO=fsl-imx-xwayland MACHINE=pico-imx8mm source tn-setup-release.sh -b build-xwayland-pico-imx8mm


bitbake -c clean swupdate-image
bitbake swupdate-image


bitbake -c clean opencvswu_signed_image_build.sh
bitbake opencv
VERSION =echo "imx8mmevk 1.0" > /etc/hwrevision




apt list --upgradable
 2052  sudo apt update
 2053  sudo apt upgrade
 2054  sudo apt update
 2055  sync
 2056  sudo apt --fix-broken insta~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/work/pico_imx8mm-poky-linux/imx-image-swu/1.0-r0/imx-image-swull



sudo apt autoremove

sudo apt --fix-broken install

sudo apt install libformw5 libmenuw5 libncursesw5 libpanelw5 python3-core python3-dbus python3-pygobject perl
































i get one working script in internet so modify accarlingaclly my board what are things you want tellme i will give one by one my board is pico imx8mm "sw-description configuration file¶

The sw-description file is used to define elements and their metadata which are included in the .swu archive. Complete syntax details can be found in the "syntax and tags with the default parser" section of the SWUpdate manual.

The following example instructs the SWUpdate Installer Framework to install five files to the respective specified paths and to run the update.sh script for "preinst" and "postinst":

software =
{
    version = "1.0";
        files: (
                {
                        filename = "updatefactoryinfo";
                        path = "/mnt/root/usr/bin/updatefactoryinfo";
                },
                {
                        filename = "OS_VERSION.txt";
                        path = "/mnt/root/home/root/OS_VERSION.txt";
                },
                {
                        filename = "index.html";
                 i.mx8mm_evk_1.0_slotS_LF_v5.10.9_1.0.0-singlecopy-emmc-full_20240517-103149.swu       path = "/mnt/root/www/pages/index.html";
                },
                {
                        filename = "style.css";
                        path = "/mnt/root/www/pages/style.css";
                },
                {
                        filename = "UF-logo.png";
                        path = "/mnt/root/www/pages/UF-logo.png";
                }
        );
        scripts: (
                {
                        filename = "update.sh";
                        type = "shellscript";
                }
        );
}

When the file device and filesystem parameters are not specified as in the example above the file is copied to the absolute path of the current rootfs swupdate is running from. This allows the freedom of mounting involved partitions in the "preinst" phase of the update.sh script.

Note

The version element is not the version of the update file. It is currently unused, so you can just ignore it.
update.sh script file¶

Suppokillall swupdatert for optional scripts in SWUpdate is a handy way to add particular features or fill in small gaps that default behaviour of handlers might have.

The following script shows how to mount partitions by label in "preinst" and unmount in "postinst", and how to change permissions on an installed file in "postinst":

#!/bin/sh

if [ $# -lt 1 ]; then
    exit 0;
fi

mount_by_label() {
    LABEL=$1
    mkdir /mnt/$LABEL
        mount "LABEL=$LABEL" /mnt/$LABEL/
}

unmount_by_label() {
    LABEL=$1
    umount /mnt/$LABEL/
    rmdir /mnt/$LABEL
}

if [ $1 == "preinst" ]; then
    echo "Mounting root"
    mount_by_label root
    mkdir -p /mnt/root/www/pages
fi

if [ $1 == "postinst" ]; then
    chmod 755 /mnt/root/usr/bin/updatefactoryinfo
    unmount_by_label root
fi

generate_swu-1.sh update creation script file¶

Once all the files of the update are ready (sw-description, update.sh and the files to install) the final update file should be created using the following script from the same directory:

#!/bin/bash

CONTAINER_VER="1.1"
PRODUCT_NAME="uf-example-file-update"
FILES="sw-description updatefactoryinfo OS_VERSION.txt update.sh index.html UF-logo.png style.css"

for i in $FILES;do
        echo $i;done | cpio -ov -H crc >  ${PRODUCT_NAME}_${CONTAINER_VER}.swu

Variables

Both the CONTAINER_VER and PRODUCT_NAME variables are arbitrary. Go ahead and set them to something relevant for the update that you intend to prepare.

Warning

According to the specifications sw-description should always be the first file in the cpio archive, so don't put files before it in the FILES variable!

The output of the command should look something like this:

$ ./generate_swu-1.sh
sw-description
updatefactoryinfo
OS_VERSION.txt
update.sh
index.html
UF-logo.png
style.css
58 blocks

The resulting file uf-example-fizumi@zumi-H81M-S:~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/work/armv8a-poky-linux/swupdate/2022.05-r0/git$ vim core/parser.c 
le-update_1.1.swu can be uploaded to Update Factory and assigned to a target to update a device."






==================================

final flash 


zumi@zumi-H81M-S:~/imx-mfg-uuu-tool_20210421/imx-mfg-uuu-tool$ sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin /home/zumi/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/deploy/images/pico-imx8mm/imx-image-full-pico-imx8mm-20240514081329.rootfs.wic.bz2







root@pico-imx8mm:~# 
root@pico-imx8mm:~# swupdate -c -i imx-image-swu-pico-imx8mm.swu
SWUpdate v2023.12.1-dirty

Licensed under GPLv2. See source distribution for detailed copyright notices.

[INFO ] : SWUPDATE started :  Software Update started !
[ERROR] : SWUPDATE failed [0] ERROR : Found nothing to install
[ERROR] : SWUPDATE failed [0] ERROR : JSON File corrupted
[ERROR] : SWUPDATE failed [0] ERROR : no parser available to parse sw-description!
[ERROR] : SWUPDATE failed [0] ERROR : Compatible SW not found
[ERROR] : SWUPDATE failed [1] Image invalid or corrupted. Not installing ...
swupdate_image_write failed: Broken pipe
[ERROR] : SWUPDATE failed [0] ERROR : SWUpdate *failed* !
[INFO ] : No SWUPDATE running :  Waiting for requests...








=====================
swu

~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/work/pico_imx8mm-poky-linux/imx-image-swu/1.0-r0/imx-image-swu

~/Ajmal/Project/edm_yocto/sources/meta-imx/meta-sdk/dynamic-layers/qt6-layer/recipes-fsl/images

~/Ajmal/meta-swupdate/recipes-support/swupdate/swupdate$ vi swupdate.sh






web_server 

killall swupdate

echo "imx8mmevk 1.0" > /etc/hwrevision

swupdate -v -w "-r /www -p 8080"

http://192.168.0.153:8080/



~/imx-mfg-uuu-tool_20210421/imx-mfg-uuu-tool$ sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin ~/Ajmal/Project/edm_yocto/build-xwayland-pico-imx8mm/tmp/deploy/images/pico-imx8mm/swupdate-image-pico-imx8mm.wic.bz2



END swupdate
====================================================













======================================================================================

gen 2 android power button 
==========================




bitbake -c cleansstate virtual/kernel

bitbake -c cleanall ls-image-main
bitbake -c cleanall qoriq-composite-firmware
bitbake -c cleanall generate-boottgz
bitbake -c cleanall virtual/kernel
bitbake -c cleanall u-boot


bitbake ls-image-main
bitbake qoriq-composite-firmware
bitbake generate-boottgz



find . -type f -name "*.c" -exec grep -H "u_qe_init" {} +












16 day ritual

source distro-setup-env -m ls1021atwr

bitbake -c cleanall ls-image-main
bitbake -c cleanall ls-image-desktop
bitbake -c cleanall ls-image-lite
bitbake -c cleanall qoriq-composite-firmware
bitbake -c cleanall generate-boottgz
bitbake -c cleanall u-boot
bitbake -c cleanall kernel

bitbake ls-image-main
bitbake ls-image-desktop
bitbake ls-image-lite
bitbake qoriq-composite-firmware
bitbake generate-boottgz
bitbake u-boot
bitbake kernel



bitbake -c menuconfig u-boot
bitbake -c menuconfig virtual/kernel
 QE (QUICC Engine) driver 


source  distro-setup-env -m ls1021atwr







find . -type f -name "*.c" -exec grep -H "u_qe_init" {} +


u_qe_init








Boot Process Overview

The boot process involves several stages, typically including:

    ROM Code (BootROM): This is the initial code executed by the processor. It is embedded in the chip and cannot be changed. Its main job is to load the next stage of the bootloader from a predefined storage location.
    First Stage Bootloader (FSBL) or SPL (Secondary Program Loader): This stage is often referred to as SPL. It's responsible for initializing basic hardware, like DRAM, and then loading the next stage of the bootloader.
    Second Stage Bootloader (SSBL): This is usually U-Boot. It further initializes hardware, sets up the environment, and eventually loads the operating system kernel.
    Kernel: The operating system kernel takes over, initializes the rest of the system, and starts user-space processes.

Storage Devices and Booting
eMMC

eMMC (embedded MultiMediaCard) has specific partitions designated for boot purposes:

    boot0 and boot1: These are dedicated partitions for bootloaders.
    rpmb: Replay Protected Memory Block, used for secure operations.
    user: The main data partition.

When booting from eMMC, the ROM code usually looks for the bootloader in the boot0 or boot1 partition.
SD Card

SD cards typically have fewer partitions:

    Partition 1 (k2p1): Often used for the bootloader and possibly a small root filesystem.
    Partition 2 (k2p2): Generally used for the main filesystem or additional data.

When booting from an SD card, the process is slightly different:

    BootROM: The processor's built-in ROM code will check the SD card's Master Boot Record (MBR) to find the partition marked as bootable.
    SPL: If present, the SPL is loaded. For SD cards, this is often found in the first partition or immediately following the MBR.
    U-Boot: The SPL will then load U-Boot, which is typically located in the first partition.

What is SPL?

SPL (Secondary Program Loader) is a minimal, stripped-down version of U-Boot:

    Purpose: Initialize essential hardware (like DRAM) to load the full bootloader (U-Boot).
    Size: Small enough to fit in limited space, like the first few blocks of an SD card or in eMMC boot partitions.
    Functionality: Performs minimal tasks, such as setting up memory and then loading and executing U-Boot.

Boot Process for SD Card

    Power On: The BootROM code executes.
    Load SPL: The BootROM checks the SD card for a bootable image. It finds the SPL (usually located in the first partition or immediately following the MBR) and loads it.
    Initialize Hardware: SPL initializes the minimal required hardware, such as memory.
    Load U-Boot: SPL loads the full U-Boot image from the SD card (typically in the first partition).
    Execute U-Boot: U-Boot takes over, initializes more hardware, sets up the environment, and eventually loads the operating system kernel from the SD card.
    Boot the OS: The kernel is loaded and executed, and the operating system starts up.

Use Case of SPL

The use case of SPL is crucial for systems with limited initial hardware capabilities. SPL’s small size and focused functionality allow it to fit in restricted areas (like the first few blocks of an SD card) and perform the necessary hardware initialization to enable the loading of more complex bootloaders.
Detailed Steps in U-Boot Source Code

To understand how U-Boot is loaded and executed:

    SPL Code: The SPL code is typically found in the spl directory of the U-Boot source. It includes initialization routines for different architectures.
    Board Initialization: SPL performs board-specific initialization, found in board/<vendor>/<board>/ directories.
    Loading U-Boot: SPL loads U-Boot from a storage medium (e.g., SD card or eMMC). This involves reading the U-Boot image into memory and jumping to its entry point.
    U-Boot Execution: Once U-Boot is in memory, the SPL hands over control to U-Boot, which continues with more extensive hardware initialization and prepares to load the operating system.

Conclusion

In summary, the boot process involves several stages, starting with ROM code, followed by SPL, and then U-Boot. The role of SPL is to initialize minimal hardware and load U-Boot. For SD cards, the bootloader stages are typically found in the primary partitions, whereas eMMC devices have dedicated boot partitions. Understanding these stages and their roles helps in diagnosing boot issues and configuring bootloaders correctly for various storage devices.











----------------------------------------------

input keyevent 26 
scrcpy
adb shell 
adb root
adb push filename /path/

pm_power_off()




power key
=================

Android Architecture

    Linux Kernel
    Platform Libraries
    Android Runtime
    Application Framework
    Applications
   
    
    
    

1. Linux Kernel
---------------------
p ~/Qualcomm_XR1/kernel/msm-4.9/drivers/input/keyboard 

fi  gpio_keys.c

fu gpio_keys_gpio_isr


2. Input Subsystem
----------------------
p ~/Qualcomm_XR1/kernel/msm-4.9/drivers/input/ 

fi  input.c

fu input_event



3. Android Input Reader
------------------------
p ~/Qualcomm_XR1/frameworks/native/services/inputflinger

fi InputReader.cpp

fu InputReader::processEventsLocked


4. Android Input Dispatche
----------------------------
p ~/Qualcomm_XR1/frameworks/native/services/inputflinger

fi InputDispatcher.cpp

fu InputDispatcher::dispatchKeyLocked


5. Power Manager
-------------------------
p ~/Qualcomm_XR1/frameworks/base/services/core/java/com/android/server/power 

fi PowerManagerService.java

fu handleMessage



p ~/Qualcomm_XR1/frameworks/base/services/core/java/com/android/server/policy

f PhoneWindowManager.java

fu interceptPowerKeyDown

fu interceptPowerKeyUp






input_event



 printk("Zumi irq=%d  gpio_pin->=%d \n",irq,bdata->irq,bdata->gpio);

       printk("Zumi irq=%d  gpio_pin->=%d \n",irq,bdata->gpiod);







======================================
The compilation process using GCC

1. Preprocessing
The first stage handles preprocessor directives (like #include and #define). You can run the preprocessing stage with the -E option:

bash
Copy code
gcc -E hello.c -o hello.i
2. Compilation
This stage translates the preprocessed source code into assembly code. Use the -S option to generate an assembly file:

bash
Copy code
gcc -S hello.i -o hello.s
3. Assembly
In this stage, the assembly code is converted into machine code, resulting in an object file. Use the -c option for this step:

bash
Copy code
gcc -c hello.s -o hello.o
4. Linking
Finally, the object file is linked to create the executable. This is done by simply calling gcc with the object file:

bash
Copy code
gcc hello.o -o hello




gcc -E hello.c -o hello.i   # Preprocessing
gcc -S hello.i -o hello.s    # Compilation
gcc -c hello.s -o hello.o    # Assembly
gcc hello.o -o hello          # Linking



==================================================================



We have an application like "Hello, World!" that we compiled and ran, generating an output file. Currently, we can only access and run the application from its directory. However, if we want to run it from any location on the system, similar to commands like ls or pwd, we can achieve that by modifying the PATH variable.

To temporarily add the application's directory to the PATH, use the following command:

export PATH=$PATH:/home/zumi/Abinash/Laboratory/hello_world

You can check if the path was added using:

echo $PATH

This change is only temporary and will be lost when you close the terminal.
Making It Permanent

To permanently add the application to your PATH, you need to edit the .bashrc file:

vi ~/.bashrc

Add the same export command at the end of the file, save it, and then run:

source ~/.bashrc

This will ensure your application is accessible from any location every time you open a new terminal.





filezlla








==========================================================================================







find out all local network ip
============================
sudo apt-get install arp-scan
sudo arp-scan --localnet



 sudo apt install whois
 whois <IP address>


ip a


sudo apt-get install sshpass




this script find out our local network system details 

#!/bin/bash

# Replace this with your actual SSH password
SSH_PASSWORD="zs10062013"
USERNAME="zumi"  # Replace with actual username

# Get the list of IPs from arp-scan output
IP_LIST=$(arp-scan --localnet | awk '{print $1}' | tail -n +3)

# Check if there are any IPs found
if [ -z "$IP_LIST" ]; then
    echo "No IPs found on the local network."
    exit 1
fi

# Loop through the list of IPs
for IP in $IP_LIST; do
    echo "Checking $IP..."

    # Attempt to SSH into the machine and run whoami
    OUTPUT=$(sshpass -p "$SSH_PASSWORD" ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=2 $USERNAME@$IP "whoami" 2>/dev/null)

    # Check if SSH was successful
    if [ $? -eq 0 ]; then
        echo "User on $IP: $OUTPUT"
    else
        echo "Could not connect to $IP via SSH."
    fi

    # Wait 0.5 seconds before checking the next IP
    sleep 0.5
done


==================================


















=========================================================================================================================================================================================

1.CAN
2.imx8mm








1.fota
2.imx8mm
3.Xilinx Zync(3U VPX Modem Card)
4.apasamy 




Project    	Project Description	     Project Duration



i need seprate seprate sendecse in all project 


1.

projrct name
-----------------

     fota(firmware over the network) in royal enfield 

Project Description

   we are doing testing and debuging the code function pointer useing structer we are doing tcp udp protocally and paket sendind and reciving without any loss during testing we are implimenting function poiter useing c code 
   
 Project Duration
   
   ( 01/Mar/2023   to 15/jun/2023  ) 1.5 month   
   
   
 
 2.
 
 projrct name
-----------------
   
   
  



rasperrypi 3 


uart
============


sudo lsof /dev/ttyS0





./sysupgrade-tar.sh --board "qcom,ipq5018-ap-mp03.3" --kernel /workspace/workspace_12.2/MPL/256_0626/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50xx-ipq50xx_32-vmlinux.bin --rootfs /workspace/workspace_12.2/MPL/256_0626/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50xx-ipq50xx_32-squashfs-root.img out.bin



























256 linux dts

ipq5018-mp03.3.dts

~/build/openwrt/workspace/workspace_12.2/MPL/256_0626/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/linux-5.4/arch/arm64/boot/dts/qcom





    Upgrade or Flash Firmware: The "sysupgrade.bin" file contains the firmware image that you want to install on your router or device running OpenWrt. It typically includes the operating system, kernel, device drivers, and any additional software packages.

    Verify Firmware File: Before flashing the firmware, it's essential to verify that the "sysupgrade.bin" file is correct and compatible with your device model. This verification ensures that you don't accidentally brick your device by flashing an incorrect or corrupt firmware file.

    Flash Using Web Interface: OpenWrt provides a web interface that allows users to flash firmware easily. You need to log into the web interface of your router, navigate to the "System" section, and then to the "Backup/Flash Firmware" menu. From there, you can choose the "Flash new firmware image" option, select the "sysupgrade.bin" file, and proceed with flashing.

    Keep Settings Option: When flashing firmware, you typically have the option to keep or clear existing settings. For major upgrades, it's recommended to clear the settings to ensure compatibility with the new firmware version. However, for minor upgrades, you may choose to keep settings if they are compatible.

    Checksum Verification: After selecting the firmware file, the web interface may display a checksum (usually SHA256) of the uploaded file. You should verify that this checksum matches the checksum provided on the OpenWrt download page. This step ensures the integrity of the firmware file.

    Flashing Process: Once you confirm the firmware file and checksum, you can proceed with flashing. The router uploads the firmware image, writes it to the flash ROM, and then reboots. This process may take several minutes, during which the router applies the changes and reboots with the new firmware.
































total folder size
==============
du -sh /folder




commant
============

swconfig dev switch1 show


https://patchwork.kernel.org/project/linux-wireless/patch/TYZPR01MB55566969818BD4B49E770445C953A@TYZPR01MB5556.apcprd01.prod.exchangelabs.com/





after this madification all port are working fine but once  board was rebood that time eth0.0 vlan id automadically changed so we are done one more way do salve this issue 


| Port | Interface | PVID | vlan| cpu port | configuration |  Data |
|------|-----------|------|-----|----------|---------------|-------|
|   1  |  eth0.3   |   3  |  3  |    6t    |      wan      |   in  |
|   2  |  eth0.2   |   2  |  2  |    6t    |      lan      |   out | 
|   3  |  eth0.1   |   1  |  1  |    6t    |      lan      |   out |
|   4  |  eth0.0   |   4  |  4  |    6t    |      lan      |   out |


we are creat ona dummy alais name for port0 that time this issue is salved 


| Port | Interface | PVID | VLAN | CPU Port |configuration |  Data   |   interchange      |
|------|-----------|------|------|----------|--------------|---------|--------------------|
|   0  |  eth0.0   |   5  |   5  |    6t    |     wan      |  dummy  |     nothink        |
|   1  |  eth0.3   |   3  |   3  |    6t    |     lan      |    in   |       same         |
|   2  |  eth0.2   |   2  |   2  |    6t    |     lan      |    out  |       same         | 
|   3  |  eth0.1   |   1  |   1  |    6t    |     lan      |    out  |       same         |
|   4  |  eth0.4   |   4  |   4  |    6t    |     lan      |    out  |  eth0.4 <-> eth0.0 |















=================================================================================================================


qcom switch 




| Port | Interface | PVID | vlan| cpu port | 
|------|-----------|------|-----|----------|
|   1  |  eth0.3   |   3  |  3  |    6t    |
|   2  |  eth0.2   |   2  |  2  |    6t    |
|   3  |  eth0.1   |   1  |  1  |    6t    |
|   4  |  eth0.0   |   4  |  4  |    6t    |


1) after once reboot eth0 not working

config switch
    option name 'switch1'
    option reset '1'
    option enable_vlan '1'

# VLAN configuration for switch ports
config switch_vlan
    option device 'switch1'
    option vlan '2'
    option ports '6t 2'
    option vid '2'

config switch_vlan
    option device 'switch1'
    option vlan '3'
    option ports '6t 1'
    option vid '3'

config switch_vlan
    option device 'switch1'
    option vlan '1'
    option ports '6t 3'
    option vid '1'

config switch_vlan
    option device 'switch1'
    option vlan '4'
    option ports '6t 4'
    option vid '4'

# PVID configuration for switch ports
config switch_port
    option device 'switch1'
    option port '2'
    option pvid '2'

config switch_port
    option device 'switch1'
    option port '1'
    option pvid '3'

config switch_port
    option device 'switch1'
    option port '3'
    option pvid '1'

config switch_port
    option device 'switch1'
    option port '4'
    option pvid '4'
    
    
config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fdee:dce1:8b1a::/48'

# VLAN interface configuration
config interface 'wan'
    option ifname 'eth0.3'
    option proto 'dhcp'
    
config interface 'lan'
    option type 'bridge'
    option ifname 'eth0.0 eth0.1 eth0.2'
    option proto 'static'
    option ipaddr '192.168.1.1'
    option netmask '255.255.255.0'




-------------------------------------------------------------------------------------------------------------------------

| Port | Interface | PVID | VLAN | CPU Port |
|------|-----------|------|------|----------|
|   0  |  eth0.0   |   5  |   5  |    6t    |
|   1  |  eth0.3   |   3  |   3  |    6t    |
|   2  |  eth0.2   |   2  |   2  |    6t    |
|   3  |  eth0.1   |   1  |   1  |    6t    |
|   4  |  eth0.4   |   4  |   4  |    6t    |


vi /etc/config/network   //final working


config switch
        option name 'switch1'
        option reset '1'
        option enable_vlan '1'

config switch_vlan
        option device 'switch1'
        option vlan '2'
        option ports '6t 2'
        option vid '2'

config switch_vlan
        option device 'switch1'
        option vlan '5'
        option ports '6t 0'
        option vid '5'

config switch_vlan
        option device 'switch1'
        option vlan '3'
        option ports '6t 1'
        option vid '3'

config switch_vlan
        option device 'switch1'
        option vlan '1'
        option ports '6t 3'
        option vid '1'

config switch_vlan
        option device 'switch1'
        option vlan '4'
        option ports '6t 4'
        option vid '4'

config switch_port
        option device 'switch1'
        option port '2'
        option pvid '2'

config switch_port
        option device 'switch1'
        option port '1'
        option pvid '3'

config switch_port
        option device 'switch1'
        option port '3'
        option pvid '1'

config switch_port
        option device 'switch1'
        option port '4'
        option pvid '4'

config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fdee:dce1:8b1a::/48'

config interface 'wan'
        option ifname 'eth0.3'
        option proto 'dhcp'

config interface 'lan'
        option type 'bridge'
        option ifname 'eth0.0 eth0.1 eth0.2 eth0.4'
        option proto 'static'
        option ipaddr '192.168.1.1'
        option netmask '255.255.255.0'
        option force_link '1'

Physical Port 4 - eth0.3
Physical Port 3 - eth0.2
Physical Port 2 - eth0.1
Physical Port 1 - eth0.4


ip link set dev eth0.4 down
ip link set dev eth0.4 name eth1.1
ip link set dev eth1.1 up


ip link set dev eth0.1 down
ip link set dev eth0.1 name eth1.2
ip link set dev eth1.2 up


ip link set dev eth0.2 down
ip link set dev eth0.2 name eth1.3
ip link set dev eth1.3 up

ip link set dev eth0.3 down
ip link set dev eth0.3 name eth1.4
ip link set dev eth1.4 up

------------------------------------------------------------------------------------------------------------------------------
sir working

config switch
        option name 'switch1'
        option reset '1'
        option enable_vlan '1'

config switch_vlan
        option device 'switch1'
        option vlan '2'
        option ports '6t 2'
        option vid '2'

config switch_vlan
        option device 'switch1'
        option vlan '5'
        option ports '6t 0'
        option vid '5'

config switch_vlan
        option device 'switch1'
        option vlan '3'
        option ports '6t 1'
        option vid '3'

config switch_vlan
        option device 'switch1'
        option vlan '1'
        option ports '6t 3'
        option vid '1'

config switch_vlan
        option device 'switch1'
        option vlan '4'
        option ports '6t 4'
        option vid '4'

config switch_port
        option device 'switch1'
        option port '2'
        option pvid '2'

config switch_port
        option device 'switch1'
        option port '1'
        option pvid '3'

config switch_port
        option device 'switch1'
        option port '3'
        option pvid '1'

config switch_port
        option device 'switch1'
        option port '4'
        option pvid '4'

config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fdee:dce1:8b1a::/48'

config interface 'wan'
        option ifname 'eth0.3'
        option proto 'dhcp'

config interface 'lan'
        option type 'bridge'
        option ifname 'eth0.0 eth0.1 eth0.2 eth0.4'
        option proto 'static'
        option ipaddr '192.168.1.1'
        option netmask '255.255.255.0'
        option force_link '1'



------------------------------------------------------------------------------------------------------------------------------
manual first boot work after reboot eth0 not work


eth0.0 eth0.1, eth0.2 and eth0.3
=============================

swconfig dev switch1 set reset 1
swconfig dev switch1 set enable_vlan 1


# setup vlans for ports, CPU is on port 6 and wants tagged frames
# lan ports vlan 1-4
# the switch chip ports map to the physical ports on the board:
#     LAN      WAN
# [ 0 1 2 ]   [ 3 ]
swconfig dev switch1 port 2 set pvid 1
swconfig dev switch1 vlan 2 set ports "6t 2"
swconfig dev switch1 port 1 set pvid 2
swconfig dev switch1 vlan 3 set ports "6t 1"
swconfig dev switch1 port 3 set pvid 3
swconfig dev switch1 vlan 1 set ports "6t 3"
# wan port vlan 4
swconfig dev switch1 port 4 set pvid 4
swconfig dev switch1 vlan 4 set ports "6t 4"
swconfig dev switch1 set apply 1

ip link add link eth0 name eth0.0 type vlan id 4
ip link add link eth0 name eth0.1 type vlan id 1
ip link add link eth0 name eth0.2 type vlan id 2
ip link add link eth0 name eth0.3 type vlan id 3



config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fdee:dce1:8b1a::/48'

# WAN interface
config interface 'wan'
    option ifname 'eth0.3'
    option proto 'dhcp'

# LAN interface (bridge)
config interface 'lan'
    option type 'bridge'
    option ifname 'eth0.0 eth0.1 eth0.2'
    option proto 'static'
    option ipaddr '192.168.1.1'
    option netmask '255.255.255.0'

# WiFi AP interface
config interface 'wifi'
    option ifname 'wlan0'
    option proto 'static'
    option ipaddr '192.168.2.1'
    option netmask '255.255.255.0'



------------------------------------------------------------------------------------------------------------------------------



qcom

switch 


ip -d link show


 vim K90network




========================================


====================================



vi /etc/config/network


config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fd96:5475:979a::/48'

# WAN interface                       
config interface 'wan'                
    option ifname 'eth0.3'            
    option proto 'dhcp'               
                                      
# LAN interface (bridge)              
config interface 'lan'              
    option type 'bridge'            
    option ifname 'eth0.0 eth0.1 eth0.2'
    option proto 'static'    
    option ipaddr '192.168.1.1'
    option netmask '255.255.255.0'
                             
# WiFi AP interface          
config interface 'wifi'      
    option ifname 'wlan0'    
    option proto 'static'    
    option ipaddr '192.168.2.1'
    option netmask '255.255.255.0'


-----------------------------------------------------------------------------------------------------------------------------------

manual way command 

swconfig dev switch1 set reset 1
swconfig dev switch1 set enable_vlan 1


# setup vlans for ports, CPU is on port 6 and wants tagged frames
# lan ports vlan 1-4
# the switch chip ports map to the physical ports on the board:
#     LAN      WAN
# [ 0 1 2 ]   [ 3 ]
swconfig dev switch1 port 2 set pvid 1
swconfig dev switch1 vlan 2 set ports "6t 2"
swconfig dev switch1 port 1 set pvid 2
swconfig dev switch1 vlan 3 set ports "6t 1"
swconfig dev switch1 port 3 set pvid 3
swconfig dev switch1 vlan 1 set ports "6t 3"
# wan port vlan 4
swconfig dev switch1 port 4 set pvid 4
swconfig dev switch1 vlan 4 set ports "6t 4"
swconfig dev switch1 set apply 1


ip link add link eth0 name eth0.0 type vlan id 4
ip link add link eth0 name eth0.1 type vlan id 1
ip link add link eth0 name eth0.2 type vlan id 2
ip link add link eth0 name eth0.3 type vlan id 3




config interface 'loopback'
        option ifname 'lo'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'

config globals 'globals'
        option ula_prefix 'fdee:dce1:8b1a::/48'

# WAN interface
config interface 'wan'
    option ifname 'eth0.3'
    option proto 'dhcp'

# LAN interface (bridge)
config interface 'lan'
    option type 'bridge'
    option ifname 'eth0.0 eth0.1 eth0.2'
    option proto 'static'
    option ipaddr '192.168.1.1'
    option netmask '255.255.255.0'

# WiFi AP interface
config interface 'wifi'
    option ifname 'wlan0'
    option proto 'static'
    option ipaddr '192.168.2.1'
    option netmask '255.255.255.0'












vi /etc/profile





/etc/init.d/network restart

cat /tmp/dhcp.leases
udhcpc -i eth0.3 -n
udhcpc -i eth0.3 -n
/etc/init.d/network stop
/etc/init.d/network start












edit 

./qsdk/qca/src/linux-5.4/drivers/remoteproc/qcom_q6v5.c





rebuild 


rm -rf build_dir/target-arm/linux-ipq50xx_ipq50xx_32/linux-5.4.213





$ sed '/packages/d;/"ipq5018_64"/d;/t32/d;/ret_prep_64image/d;/Required/d;/skales/d;
/nosmmu/d;/os.system(cmd)/d;/os.chdir(ipq_dir)/d;/atfdir/d;/noac/d;/single-
atf/d;/bl31.mbn/d;/bin_atf/d;/ret_pack_64image/d;/list_out_64_single/d;/list_out_64_a
pps/d;/dict_64_bit_single/d;/dict_64_bit_apps/d;/list_out_debug/d' -i
update_common_info.py
$ export BLD_ENV_BUILD_ID=<profile-name>
$ python update_common_info.py
Where <profile-name> is P/LM512/LM256.






lakshmi folder

AP.MP-logs/Steps-to-Build-And-Flash.txt



tftpb nand-ipq5018-single1.img && imgaddr=$fileaddr && source $imgaddr:script

usb flash

usb start
fatload usb 0:1 0x44000000 norplusnand-ipq5018-single.img  && imgaddr=$fileaddr && source $imgaddr:script




 cp ./meta-tools/ipq5018/config.xml ./meta-tools/ipq5018/config.xml.bk
 cp ./apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml ./apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml.bk
 cp ./apss_proc/out/meta-tools/ipq5018/config.xml.bk
 cp ./apss_proc/out/meta-tools/ipq5018/config.xml ./apss_proc/out/meta-tools/ipq5018/config.xml.bk
 cp ./NHSS.QSDK.12.2/apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml ./NHSS.QSDK.12.2/apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml.bk
 cp ./common/build/ipq/ipq5018/config.xml ./common/build/ipq/ipq5018/config.xml.bk
 cp ./common/build/ipq_x64/ipq5018/config.xml ./common/build/ipq_x64/ipq5018/config.xml.bk
 mkdir ~/Abinash/xml
 cp ./common/build/ipq_x64/ipq5018/config.xml ~/Abinash/xml/
 vi ~/Abinash/xml/config.xml
 
 
 
 cp ~/Abinash/xml/config.xml ./common/build/ipq_x64/ipq5018/config.xml
 cp ~/Abinash/xml/config.xml ./apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml
 cp ~/Abinash/xml/config.xml ./apss_proc/out/meta-tools/ipq5018/config.xml
 cp ~/Abinash/xml/config.xml ./NHSS.QSDK.12.2/apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml
 cp ~/Abinash/xml/config.xml ./common/build/ipq/ipq5018/config.xml
 cp ~/Abinash/xml/config.xml ./common/build/ipq_x64/ipq5018/config.xml
 
 
 
 
 vi ./NHSS.QSDK.12.2/apss_proc/out/proprietary/QSDK-Base/meta-tools/ipq5018/config.xml










eth
==========


setenv ipaddr 192.168.1.2
setenv serverip 192.168.1.1
setenv ethact eth0
setenv eth1speed 100
saveenv


sudo nmcli connection modify <connection-name> 802-3-ethernet.speed 100

sudo ethtool -s eth0 speed 100 duplex full
sudo apt-get install ethtool
sudo yum install ethtool
 sudo tcpdump -i enp3s0



nmcli connection show
sudo nmcli connection modify WiredConn1 802-3-ethernet.speed 100







CONFIG_IPQ_MEM_PROFILE=0

__IPQ_MEM_PROFILE_256_MB__

				CUSTOM BOARD ENVIRONMENT
==============================================================================================================
24 JAN 2024
=============
COMPILATION STEPS
=====================
Go to qsdk directory:
-------------------------
make V=s -j5 2>&1| tee log.txt
if error occurs
	=> Check ethernet from zumi
	=> make V=s -j1 2>&1| tee log.txt

ONCE COMPILATION IS SUCCESS 

Go to qsdk directory:
-------------------------
cp -f bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ../common/build/ipq

cd ../common/build/

export BLD_ENV_BUILD_ID=P (If profile is not selected then only execute this command)
=================================================
To enable to LM256 Profile:
export BLD_ENV_BUILD_ID=LM256
=================================================
RUN THE BELOW COMMAND IN BUILD DIRECTORY: (EXAMPLE: /common/build/)

python update_common_info.py

ONCE SINGLE IMAGE IS GENERATED, COPY IT TO THE TFTP FOLDER (EXAMPLE: /home/zumi/tftp)
cd bin/
cp nand-ipq5018-single.img /home/zumi/tftp/nand-C7.img

Power cycle the Custom board and stop at u-boot prompt then execute the below commands in custom board terminal:
================================================================

setenv ipaddr 192.168.1.1
setenv serverip 192.168.1.10
tftpb nand-C5.img && imgaddr=$fileaddr && source $imgaddr:script
================================================================

tftpb nand-C1-256M.img && imgaddr=$fileaddr && source $imgaddr:script


If any issue occurs for tftp, execute the below commands:
############################################################
TFTP SETTINGS
############################################################
sudo vi /etc/default/tftpd-hpa
# EDIT TFTP_DIRECTORY="Your PATH"
sudo service tftpd-hpa restart
sudo service tftpd-hpa status

path edit 
----------
vi /etc/default/tftpd-hpa

re install
----------

sudo apt-get remove --purge tftpd-hpa
sudo apt-get install tftpd-hpa



DTS File path:
==============================================================================================================
~/QCOMM_12.2/qcom_setup_workspace_v1/MPL/P_0526/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/linux-5.4/arch/arm64/boot/dts/qcom

DTB File path:
==============================================================================================================
~/QCOMM_12.2/qcom_setup_workspace_v1/MPL/P_0526/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/common/build/ipq_x64


Reference Board
===============
Revision Version: mp03.3


Reference Board
===============




path
------------------

linux
-------
/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/linux-5.4

u-boot
---------
/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/u-boot-2016

dts 
------
/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/linux-5.4/arch/arm64/boot/dts/qcom

bin
-------
/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/common/build/bin


build path
-----------
/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk$ make V=s -j5 2>&1| tee log.txt



cp -f bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ../common/build/ipq


cd ../common/build/

export BLD_ENV_BUILD_ID=LM256

binary generation
======================
python update_common_info.py


u-boot changes
---------------
vim qca/arm/common/board_init.c

./qca/arm/ipq5018/ipq5018.c


wifi1{
	/* QCN6122 5G */
	qcom,multipd_arch;
	qcom,userpd-subsys-name = "q6v5_wcss_userpd2";
	qcom,rproc = <&q6_wcss_pd2>;




 profile = PROFILE
        command_list.append("mkdir -p " + sp)
        command_list.append("mkdir " + sp + "/" + profile + "_" + now)
        command_list.append("cp -rf " + MAIN_DISTRO + " " + sp + "/" + profile + "_" + now)
        start_time = time.time()
        subprocess_cmd(command_list)
        build_path = PATH +  sp + "/" + profile + "_" + now + "/"
        print "--- %s seconds ---" % (time.time() - start_time)
        os.chdir(build_path)
        print "CWD: ",os.getcwd()




qualcomme
==================================================


phy details

                                                                   internet
                                                                   
  
    MAC - media access controller. This is the part of the system which converts a packet from the OS into a stream of bytes to be
          put on  the wire (or fibre). Often interfaces to the host processor over something like PCI Express (for example).
          
    PHY - physical layer - converts a stream of bytes from the MAC into signals on one or more wires or fibres.
    
    MII - media independent interface. Just a standard set of pins between the MAC and the PHY, so that the MAC doesn't have to 
          know or care  what the physical medium is, and the PHY doesn't have to know or care how the host processor interface looks.
                                                                 
                                                                 
 The MII was standardised a long time ago and supports 100Mbit/sec speeds. A version using less pins is also available, RMII ('R' for reduced).

For gigabit speeds, the GMII ('G' for gigabit) interface is used, with a reduced pincount version called RGMII. A very reduced pincount version called SGMII is also available ('S' for serial) which requires special capabilities on the IO pins of the MAC, whereas the other xMIIs are relatively conventional logic signals.                                                                




The MII, SGMII, RGMII are three kinds of interface between the MAC block and the PHY chip. The Intel 82574L is one MAC chip. Looking following figure:

    _______         __________                  ___________
     CPU  | PCI-E   |        |  MII/SGMII/RGMII |         |
     or   |<=======>| MAC    |<================>| PHY     |<====>physical interface RJ45
     board| or else |        |                  |         |
    _______         __________                  ___________

    For details about MII (100Mbps), SGMII (1Gbps, serial), RGMII (1Gbps, reduced) definition, you can google them.

    Basically speaking, NIC (Network Interface Card) consist of one MAC block and related PHY chip, and other peripheral modules. And also one Ethernet device driver should work with the NIC hardware. The MAC block has one interface with the control CPU or PC main-board, such as PCIe bus or else.
    
    
MII   - Media Independent Interface - 100 Mbps
GMII  - Gigabit MII - 1 Gbps (24 pins) (8TX - 8RX)
RGMII - Reduced GMII - 1 Gbps (12 pins) (4TX - 4RX)
SGMII - Serial GMII - 1 Gbps (8 pins) (2TX - 2RX)
XAUI  - XGMII Extender - 10 Gbps (XY pins) (8TX - 8RX)
SPI-4.2 - System Packet Interface Level 4, Phase 2 (16TX - 16RX) 
    
    
The Media Independent Interface (MII) is a standard interface used to connect a Fast Ethernet (i.e. 100Mb/s) MAC-block to a PHY. The MII may connect to an external transceiver device via a pluggable connector or simply connect two chips on the same printed circuit board. Being media independent means that any of several different types of PHY devices can be used without redesigning or replacing the MAC hardware.

Gigabit Media Independent Interface (GMII) is an interface between the Media Access Control (MAC) device and the physical layer (PHY). The interface defines speeds up to 1000 Mbit/s, implemented using an eight bit data interface clocked at 125 MHz, and is backwards compatible with the Media Independent Interface (MII) specification.

Reduced Gigabit Media Independent Interface (RGMII) specifies a particular interface between an Ethernet MAC and PHY. RGMII uses half the number of pins as used in the GMII interface. This reduction is achieved by clocking data on both the rising and falling edges of the clock, and by eliminating non-essential signals (carrier-sense and collision-indication). Thus RGMII consists only of: RXC, RD[3:0], RX_CTL, TXC, TXD[3:0], and TX_CTL (12 pins, as opposed to GMII's 24).

The Serial Gigabit Media Independent Interface (SGMII) is a sequel of MII, a standard interface used to connect an Ethernet MAC-block to a PHY. It differs from GMII by its low-power and low pin count serial interface (commonly referred to as a SerDes).

XAUI is a standard for extending the XGMII (10 Gigabit Media Independent Interface) between the MAC and PHY layer of 10 Gigabit Ethernet (10GbE). XAUI is pronounced "zowie", a concatenatiFwifion of the Roman numeral X, meaning ten, and the initials of "Attachment Unit Interface".    
    
    
    
**********************************************************************************************************************************

QULAcomma OPEnwrt board

======================== 


Qualcomm Credentials:
Id:		madhukara@kaynestechnology.net
Password:	KtQual_2023

############################################################
Build U-BOOT Changes
############################################################
source: /qsdk/qca/src/u-boot-2016
After source change
	git status
	git add <file1> <file2> ...
	git commit -sm "Your commit messageee"
		# when you wants to update same commit id 
		git commit --amend
	git status
	# to see your changes in last commit
	git show

# clean u-boot in case of build failure
find build_dir/ -iname "u-boot" | xargs rm -rf

# Go to qsdk
make V=s -j5 2>&1| tee log.txt

############################################################
Build Linux-kernel Changes
############################################################
source: qsdk/qca/src/linux-5.4
After source change
	git status
	git add <file1> <file2> ...
	git commit -sm "Your commit messageee"
		# when you wants to update same commit id 
		git commit --amend
	git status
	# to see your changes in last commit
	git show
############################################################
Board Recovery using USB 
############################################################
usb start
fatload usb 0:1 0x44000000 norplusnand-v1.img  && imgaddr=$fileaddr && source $imgaddr:script

fatload usb 0:0 0x44000000 norplusnand-L2.img && imgaddr=$fileaddr && source $imgaddr:script

flash V2 Image using USB
usb start
fatload usb 0:0 0x44000000 addingswitch_gmac1-V2.img && imgaddr=$fileaddr && source $imgaddr:script

flash V3 Image using USB
usb start
fatload usb 0:0 0x44000000 moveswitch-gmac2-V3.img && imgaddr=$fileaddr && source $imgaddr:script

flash V4 Image using USB
usb start
fatload usb 0:0 0x44000000 removenapa_phyaddr-gmac2-V4.img && imgaddr=$fileaddr && source $imgaddr:script

Using tftp for V4 Image
tftpb remove_napa_phyaddr-gmac2-V4.img && imgaddr=$fileaddr && source $imgaddr:script



# Go to qsdk
make V=s -j5 2>&1| tee log.txt

############################################################
Build Single Image
############################################################
cd common/build
rm -rf bin/*
cp ../../qsdk/bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ipq/
python update_common_info.py


############################################################
TFTP SETTINGS
############################################################
sudo vi /etc/default/tftpd-hpa
# EDIT TFTP_DIRECTORY="Your PATH"
sudo service tftpd-hpa restart
sudo service tftpd-hpa status


############################################################
u-boot clean-up command from qsdk
############################################################
After Git commit steps:

From qsdk path:
---------------

qsdk$ find build_dir/target-arm/ -type d -iname "u-boot" | xargs rm -rf

Start Building
make V=s -j5 2>&1| tee log.txt

cp -f bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ../common/build/ipq

cd ../common/build/
python update_common_info.py




############################################################
Flashing norplusnand-ipq5018-single.img
############################################################
setenv serverip 192.168.0.128
setenv ipaddr 192.168.0.103
tftpb N5.img && imgaddr=$fileaddr && source $imgaddr:script
bootipq


############################################################
# To recover kernel auto boot incase of boot failure.
############################################################

# Go to u-boot prompt

env default -a
saveenv
reset


########################################
ABINASH SETUP:
########################################
Enter into the U-boot terminal:

setenv serverip 192.168.1.10
setenv ipaddr 192.168.1.1

tftpb norplusnand-dafault.img && imgaddr=$fileaddr && source $imgaddr:script
tftpb norplusnand-ipq5018-single.img && imgaddr=$fileaddr && source $imgaddr:script (Reference command)
tftpb norplusnand-L4.img && imgaddr=$fileaddr && source $imgaddr:script (Current working Image)

TFTP copy
========
cd ~/qcomm_ipq5018/qcom_setup_workspace_v1/M/P0214/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2/common/build/bin
cp norplusnand-ipq5018-single.img /home/zumi/tftp/norplusnand-L4.img

########################################
========================================================

tftpb norplusnand-v1.img && imgaddr=$fileaddr && source $imgaddr:script

tftpb norplusnand-L4.img && imgaddr=$fileaddr && source $imgaddr:script (Updated On 30 Nov 2023)

tftpb norplusnand-L3.img && imgaddr=$fileaddr && source $imgaddr:script (After Adding "CONFIG_PACKAGE_uhttpd-mod-ubus = y" Kernel Panic)

tftpb norplusnand-L2.img && imgaddr=$fileaddr && source $imgaddr:script (Before Adding "CONFIG_PACKAGE_uhttpd-mod-ubus = y")



tftpb norplusnand-Z9.img && imgaddr=$fileaddr && source $imgaddr:script

tftpb norplusnand-Z10.img && imgaddr=$fileaddr && source $imgaddr:script (Added print in athrs17.c and ipq_qca8084.c)

########################################
setenv serverip 192.168.0.128
setenv ipaddr 192.168.0.110

tftpb norplusnand-ipq5018-single.img && imgaddr=$fileaddr && source $imgaddr:script



smeminfo
saveenv

bootipq OR reset

=============================================================

# Find build error
grep -in '[^_-"a-z]error[^_-.a-z]' log.txt

ping 192.168.1.1

####################################################
cleanup uboot build
d22905dbf10d989141f0699c39bfd2/qsdk/build_dir$ find . -iname "u-boot" | xargs rm -rf


Net:   cmbblk is stable 5
MAC0 addr:0:11:22:33:44:55
PHY ID1: 0x4d
PHY ID2: 0xd0c0
MAC1 addr:0:11:22:33:44:56
GMAC1:Invalid PHY ID 
board_update_caldata: Unable to find slot-Id, Default CapIn/CapOut values used
eth0, eth1
IPQ5018# 




phy_pins:phy_pins {
	phy_reset {
		pins = "gpio39";
		function = "gpio";
		drive-strength = <8>;
		bias-pull-down;
		output-low;
	};
};

Zaid
======
cd ~/qcomm_ipq5018/qcom_setup_workspace_v1/M/P0214/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2/qsdk>
make V=s -j5 2>&1 | tee log.txt
~/qcomm_ipq5018/qcom_setup_workspace_v1/M/P0214/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2/common/build
rm -rf bin/*
cp ../../qsdk/bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ipq/
python update_common_info.py

TFTP copy
========
cd ~/qcomm_ipq5018/qcom_setup_workspace_v1/M/P0214/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2/common/build/bin
cp norplusnand-ipq5018-single.img /home/zumi/tftp/norplusnand-K1.img

Board
======
setenv serverip 192.168.1.10
setenv ipaddr 192.168.1.1
tftpb norplusnand-K4.img && imgaddr=$fileaddr && source $imgaddr:script

Kernel Source code
==================
/home/zumi/qcomm_ipq5018/qcom_setup_workspace_v1/M/P0214/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2/qsdk/qca/src/linux-5.4

DTS:
====
vi arch/arm64/boot/dts/qcom/ipq5018-mp03.3.dts

                       ess-switch1@1 {
                                compatible = "qcom,ess-switch-qca83xx";
                                device_id = <1>;
                                switch_access_mode = "mdio";
                                mdio-bus = <&mdio1>;
                                reset_gpio = <&tlmm 0x27 0>;
                                switch_cpu_bmp = <0x40>;  /* cpu port bitmap */
                                switch_lan_bmp = <0x1e>; /* lan port bitmap */
                                switch_wan_bmp = <0x0>;  /* wan port bitmap */
                                qca,ar8327-initvals = <
                                                0x00004 0x7600000   /* PAD0_MODE */
                                                0x00008 0x1000000   /* PAD5_MODE */
                                                0x0000c 0x80        /* PAD6_MODE */
                                                0x00010 0x2613a0    /* PORT6 FORCE MODE*/
                                                0x000e4 0xaa545     /* MAC_POWER_SEL */
                                                0x000e0 0xc74164de  /* SGMII_CTRL */
                                                0x0007c 0x4e        /* PORT0_STATUS */
                                                0x00094 0x4e        /* PORT6_STATUS */
                                >;
                                qcom,port_phyinfo {
                                        port@0 {
                                                port_id = <1>;
                                                phy_address = <0>;
                                        };
                                        port@1 {
                                                port_id = <2>;
                                                phy_address = <1>;
                                        };
                                        port@2 {
                                                port_id = <3>;
                                                phy_address = <2>;
                                        };
                                        port@3 {
                                                port_id = <4>;
                                                phy_address = <3>;
                                        };
                                };
                        };
                };


driver
======
~/qcomm_ipq5018/qcom_setup_workspace_v1/M/P0214/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2/qsdk/qca/src/linux-5.4/drivers/phy/qualcomm$ vim phy-qca-uniphy.c


git add .
git commit -sm "phy_reset: adding pin-control"

Document
========
/home/zumi/LAKSHMI/Router_Development/IPQ5018-imp-documents/IPQ50xx-switchSDK-dtconfiguration.pdf




re-build 
-----------------
binary generation problem

export BLD_ENV_BUILD_ID=P
python update_common_info.py
 
 
 export BLD_ENV_BUILD_ID=LM265

dts files in linux 


~/build/openwrt/workspace_12.2/MPL/P_1131/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/linux-5.4/arch/arm64/boot/dts/qcom





docker  
===========================

file name 
------------------------------------------------------------------------

#!/bin/bash
image_name="ubuntu-18.04"
container_name="myubuntu"
ws_dir=workspace

git_username="arjun"
git_email="arjun@zumisolutions.com"
hostname="openwrt"

command=$1
configure() {
    docker exec -it $container_name git config --global user.name ${git_username}
    docker exec -it $container_name git config --global user.email ${git_email}
    docker exec -it $container_name git config --global color.ui auto
}

if [ "$command" == '' ]; then
    echo "openwrt options not found"
    exit
fi

if [ "$command" == 'remove' ]; then
    docker stop $container_name
    docker ps -a

    docker rm $container_name
    docker rmi $image_name
    docker images -a
fi

if [ "$command" == 'create' ]; then
    docker build -t $image_name .
    docker images -a
fi

if [ "$command" == 'run' ]; then
    docker run -itd \
    --hostname ${hostname} \
    --mount type=bind,source="$(pwd)"/$ws_dir,target=/$ws_dir \
    --name $container_name $image_name
    configure
    docker ps -a
fi

if [ "$command" == 'start' ]; then
    docker start $container_name
fi

if [ "$command" == 'stop' ]; then
    docker stop $container_name
fi

if [ "$command" == 'attach' ]; then
    docker attach $container_name
fi

#####################################

if [ "$command" == 'config' ]; then
    configure
fi

if [ "$command" == 'setup_workspace' ]; then
    docker exec -it $container_name python setup_workspace.py
fi

-----------------------------------------------

# HOST SETUP
1. Docker installation
    $ sudo apt update
    $ sudo apt install -y docker
    OR
    $ sudo snap install docker

2. # Create container
    $ ./openwrt_qca.sh create

3. # Run Container
    $ ./openwrt_qca.sh run

3.1 # Start Container
    $ ./openwrt_qca.sh start

    Note: once container created you just need to start every time

4. # attach Container
    $ ./openwrt_qca.sh attach
    
5. # Copy qca-networking*.zip to workspace dir
# untar openwrt_build_workspace.tar
# copy <your path>/qca-networking-2022-spf-12-1_qca_oem-master-a1be06c71fd22905dbf10d989141f0699c39bfd2.zip /wrokspace

6. # Start Build
   $ python setup_workspace.py

   Select options 1, 2, 3

# Extra knowledge to handle containers
1. How to detach the container
   CTRL + P + Q


-----------
Dockerfile
-----------



===================================================


docker image prune -a

docker start 6829e120743e
docker attach 6829e120743e
docker rm 6829e120743e


docker ps -a
sudo docker ps -a
sudo docker pull ubuntu:18.04
docker run --help
docker ps -a
docker image -a
docker images -a
sudo docker kill myubuntu
sudo docker rm  myubuntu
sudo ./openwrt_qca.sh run
sudo ./openwrt_qca.sh attach
sudo ./openwrt_qca.sh start
sudo ./openwrt_qca.sh attach
sudo ./openwrt_qca.sh start
sudo ./openwrt_qca.sh remove
docker rm $(docker ps -qa)
sudo chmod 0777 /var/run/docker.sock

git status
git diff Dockerfile
git diff openwrt_qca.sh
git checkout openwrt_qca.sh
git status
vi .gitignore
git status
vi .gitignore
git status
git rm logs.txt 
git status


rebuild 

==============================

vi update_common_info.py 
find . -type f -name "README.md"

------------------------------

AAA
fdts
==============================================================
Go to qsdk directory:
-------------------------
make V=s -j5 2>&1| tee log.txt
if error occurs
        => Check ethernet from zumi
        => make V=s -j1 2>&1| tee log.txt

ONCE COMPILATION IS SUCCESS

Go to qsdk directory:
-------------------------
cp -f bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ../common/build/ipq

cd ../common/build/

export BLD_ENV_BUILD_ID=P (If profile is not selected then only execute this command)

RUN THE BELOW COMMAND IN BUILD DIRECTORY: (EXAMPLE: /common/build/)

python update_common_info.py

ONCE SINGLE IMAGE IS GENERATED, COPY IT TO THE TFTP FOLDER (EXAMPLE: /home/zumi/tftp)
cd bin/
cp nand-ipq5018-single.img /home/zumi/tftp/nand-C7.img

Power cycle the Custom board and stop at u-boot prompt then execute the below commands in custom board terminal:
================================================================

setenv ipaddr 192.168.1.1
setenv serverip 192.168.1.10
tftpb nand-C5.img && imgaddr=$fileaddr && source $imgaddr:script
================================================================

tftpb nand-C13.img && imgaddr=$fileaddr && source $imgaddr:script


If any issue occurs for tftp, execute the below commands:
############################################################
TFTP SETTINGS
############################################################
sudo vi /etc/default/tftpd-hpa
# EDIT TFTP_DIRECTORY="Your PATH"
sudo service tftpd-hpa restart
sudo service tftpd-hpa status

DTS File path:
==============================================================================================================
~/QCOMM_12.2/qcom_setup_workspace_v1/MPL/P_0526/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/qsdk/qca/src/linux-5.4/arch/arm64/boot/dts/qcom

DTB File path:
==============================================================================================================
~/QCOMM_12.2/qcom_setup_workspace_v1/MPL/P_0526/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/common/build/ipq_x64
                                                                                                                                                                                          58,8          Bot


==================================
compress 

tar -czvf archive_name.tar.gz file_or_directory


uncompress

tar -xzvf bttest.tar.gz






i need 3 daya leave for going home down for temple function a i want (25/03/2024) to (27/03/2024) i need this 3 leave please aprovel my leave i need proper mail contened" 












serial not working debug port 
===============================

https://community.nxp.com/t5/Layerscape/How-to-bring-up-TWR-LS1021A-PC-evk-board/td-p/1071374

example

1) There is a known issue with MBED operation under Win10.

Please apply the workaround:
DAPLink bootloader update | Mbed 

2) Plug in power to LS board. Hold down Reset button while plugging the PC USB cable into the CSAM USB connector on the board.
On Windows, the board will be shown as a Mass Storage Device under a volume labelled 'BOOTLOADER'.
LED for MBED status will blink green on the board to acknowledge it is in bootloader mode.

 

1. Unzip attached package and copy the binary into the 'BOOTLOADER’
2. Wait the binary copy to finish; LED for MBED status will blink with higher rate on finish;
3. Unplug the USB cable from the board, then plug it back in to power cycle the module
4. The board should be ready to connect to CodeWarrior
Add tags
k20dx128_if_mbed.bin.zip 









ssh service
=====================

sudo apt-get install sshpass

sudo apt-get install openssh-server

sudo systemctl status ssh


sudo systemctl enable ssh

sudo systemctl start ssh

sudo service ssh start

ssh -o HostKeyAlgorithms=+ssh-rsa root@192.168.0.100





PRCM_PRM
PRM_DEVICE 0x44DF_4000 





NEXT
-------------------------------


strings  search
==========================================
find the search file count
=============================

find . -type f -iname "*.ko" | wc -l

636


root files

find / -type f -name "*.sh" -exec grep -H "monitor_scan_qcawificfg80211" {} +

current folder all files 

find . -type f -exec grep -H "sbl1_main_ctl" {} +


currnt folder 

grep -r "ol_ath_ema_init_ctx" .


current folder case-insensitive search.

grep -i -r --include=* "ded" .


grep "] [" * -r

grep: Invalid regular expression

use like this
-------------
grep "] \[" * -r




currnt folder in spefic files in all

find . -type f -name "*.c" -exec grep -H "ol_ath_ema_init_ctx" {} +

currnt folder in spefic files in exact string

find . -type f -name "*.dts" -exec grep -wn "1000" {} +

currnt folder in spefic files in exact string for currnt folder in spefic files in exact string 

find . -type f -name "*.dts" -exec grep -iwn "1000" {} +
:



find . -type f -name "*.dts" -exec grep -H "__IPQ_MEM_PROFILE_512_MB__" {} +
__IPQ_MEM_PROFILE_512_MB__


current folder only not sub folders

find . -maxdepth 1 -type f -name "*.c" -exec grep -H "ol_ath_ema_init_ctx" {} +


mult fils current folder

find . -type f \( -name "*.c" -o -name "*.h" \) -exec grep -H "ol_ath_ema_init_ctx" {} +


==========================


folder search

find . -type d -name "safe"

file search

find . -type f -name "*abi*"


file search root

sudo find / -type f -name "*abi*"

folder search root

sudo find / -type d -name "safe"



=======================
path

find . -type f -path '*/1/5/3/abi'

find . -type d -path '*/1/5/3*'


cp -fpR


find . -type d -path '*/out/target/product*'

*/out/target/product*





Network commants
==============================

arp -a
cat /proc/cpuinfo
cat /proc/cpuinfo | grep "model name\|cpu MHz\|processor"
iw reg get
iw dev 
iw phy


ip neigh show | grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}' | awk 'BEGIN {OFS=","} {printf "%-2s,IP=%-15s dev %-8s MAC ADD=%-18s status=%s\n", NR, $1, $3, $5, $NF}'






copy commant 

cp -rf




pheriperal test

============================================================================================================================

#!/bin/ash
#-------------------------------------------------------------------------------------------------------
test_pass() {
    echo -e "\n\t\t\t***TEST PASS***\n"
}

test_fail() {
    echo -e "\n\t\t\t***TEST FAIL***\n"
}
#---------------------------------------------------ip--------------------------------------------------------
display_connected_ips() {
    echo -e "Executing: ip neigh show\n"
    echo -e "    IP address           dev               MAC Address          status         HOSTNAME\n"
    ip neigh show | grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}' |
        awk 'BEGIN {OFS="\t"} {mac = ($5 == "" ? "FAILED" : $5); \
    host = "nslookup " $1 " | grep 'name' | awk -F= '\''{print $2}'\''"; \
    host | getline hostname; close(host); \
    split(hostname, parts, "."); \
    printf "%s, %-15s\t%-8s\t%-18s\t%-10s\t%s\n", \
    NR, $1, $3, mac, $NF, (parts[1] == "" ? "Unknown" : parts[1])}'
}

ip_ping() {
    if [ "$1" -eq 1 ]; then
        N=$(ip neigh show | grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}' | \
        awk 'END {print NR}')
        for choice in $(seq "$N"); do
            choice=$((choice + 4))
            ip_to_ping=$(display_connected_ips | awk -F',' -v num="$choice" 'NR==num {print $2}' | awk '{print $1}')
                if [ -n "$ip_to_ping" ]; then
                    echo "Pinging $ip_to_ping 4 times..."
                    if ping -c 4 "$ip_to_ping"; then
                        test_pass
                    else
                        sleep 2
                        echo " The host $ip_to_ping is unreachable."
                        test_fail
                    fi
                else
                    echo "Invalid line number."
                fi
        done
    return 
    fi

    while true; do
        echo ""
        read -p "Enter the line number to ping (0 to cancel): " choice
        choice=$((choice + 4))
        if [ "$choice" -eq 0 ]; then
            echo "Canceled ping."
        else
            ip_to_ping=$(display_connected_ips | awk -F',' -v num="$choice" 'NR==num {print $2}' | awk '{print $1}')
            if [ -n "$ip_to_ping" ]; then
                echo "Pinging $ip_to_ping 5 times..."
                if ping -c 5 "$ip_to_ping"; then
                    test_pass
                else
                    sleep 2
                    echo " The host $ip_to_ping is unreachable."
                    test_fail
                fi
            else
                echo "Invalid line number."
            fi
        fi

        read -p "You want to Test for another IP or EXIT (y/n to continue/exit): " user_input

        if [ "$user_input" = "n" ]; then
            echo "Exiting..."
            break
        elif [ "$user_input" = "y" ]; then
            user_input=0
            display_connected_ips
        else
            echo "Invalid input. Please enter 'y' to continue or 'n' to exit."
        fi
    done
}
#-----------------------------------------------cpu------------------------------------------------------------
display_cpu_details() {
    echo "Executing: cat /proc/cpuinfo"
    cat /proc/cpuinfo
}
#-----------------------------------------------wifi------------------------------------------------------------
display_wifi_info() {
    echo "Executing: iwconfig"
    a=$(iwconfig 2>/dev/null | awk '{if (p) print ""; p=1} p; /^$/ {p=0}' | sed '/^$/d')
    echo ""
    echo "$a"
}
#---------------------------------------------------phy--------------------------------------------------------
display_phy_details() {
    echo "Executing: iw dev"
    iw dev
}
#--------------------------------------------------flash memory---------------------------------------------------------
flash_memory_details() {
    echo "Executing: cat /proc/mtd "
    cat /proc/mtd
}
#-------------------------------------------------------memory----------------------------------------------------
memory() {
    echo "Executing: cat /proc/meminfo"
    cat /proc/meminfo
}
#----------------------------------------------------------led---------------------------------------------------------------
setup_gpio() {
    gpio_number=$1
    # Export GPIO
    echo $gpio_number >/sys/class/gpio/export
    echo "direction"
    cat /sys/class/gpio/gpio$gpio_number/direction
    # Set direction to "out"
    echo "out" >/sys/class/gpio/gpio$gpio_number/direction
}
# Function to perform read and write operations
perform_operations() {
    gpio_number=$1
    # Perform operations 5 times
    for i in $(seq 1 5); do
        echo "Iteration $i:"
        # Write "0" to the GPIO pin
        echo 0 >/sys/class/gpio/gpio$gpio_number/value
        echo "Written 0 to gpio$gpio_number"
        # Read the value from the GPIO pin
        value=$(cat /sys/class/gpio/gpio$gpio_number/value)
        echo "Read value from gpio$gpio_number: $value"
        # Write "1" to the GPIO pin
        echo 1 >/sys/class/gpio/gpio$gpio_number/value
        echo "Written 1 to gpio$gpio_number"
        # Read the value from the GPIO pin
        value=$(cat /sys/class/gpio/gpio$gpio_number/value)
        echo "Read value from gpio$gpio_number: $value"
        echo "----------------"

        if [ "$value" != "0" ] && [ "$value" != "1" ]; then
            test_fail
            value=111
            break
        fi
        sleep 2
    done

    if [ "$value" != "111" ]; then
        test_pass
    fi
}
led_test() {
    while true; do
        echo "1. WAN LAN1 LAN2 LAN3 pin NUMBER    504"
        if [ "$1" -eq 1 ]; then
            user_input=504
        else
            read -p "Enter GPIO number: " user_input
        fi
        echo "gpio current checking pin $user_input"
        # Call the setup_gpio function with user input
        setup_gpio $user_input
        # Call the perform_operations function with user input
        perform_operations $user_input
        echo $user_input >/sys/class/gpio/unexport
        if [ "$1" -eq 1 ]; then
            return
        fi
        read -p "Checking for Next GPIO PIN (y/n to continue/exit): " user_input
        if [ "$user_input" = "n" ]; then
            echo "Exiting..."
            break
        elif [ "$user_input" = "y" ]; then
            user_input=0
        else
            echo "Invalid input. Please enter 'y' to continue or 'n' to exit."
        fi
    done
}
#------------------------------------------------------MAIN-------------------------------------------------------------------
while true; do
    echo -e "\n+-----------------------------------------------+"
    echo -e "|\t\tSelect an option\t\t|"
    echo -e "+-----------------------------------------------+"
    echo -e "|1. Display connected system IPs\t\t|"
    echo -e "|2. Display CPU details\t\t\t\t|"
    echo -e "|3. Display WiFi information\t\t\t|"
    echo -e "|4. Display PHY details\t\t\t\t|"
    echo -e "|5. Memory details\t\t\t\t|"
    echo -e "|6. flash_memory_details\t\t\t|"
    echo -e "|7. led_test\t\t\t\t\t|"
    echo -e "|8. Test_all_peripheral\t\t\t\t|"
    echo -e "|9. Exit\t\t\t\t\t|"
    echo -e "+-----------------------------------------------+\n"
    read -p "Enter option (1/2/3/4/5/6/7/8/9): " choice
    echo ""

    case "$choice" in
    1)
        echo -e "\n+-----------------------------------------------+" 
        echo -e "|\tTesting For WAN LAN1 LAN2 LAN3 WIFI\t|"
        echo -e "+-----------------------------------------------+\n"
        display_connected_ips
        ip_ping
        ;;
    2)
        echo -e "\n+-----------------------------------------------+"  
        echo -e "|\t\tTesting For CPU\t\t\t|"
        echo -e "+-----------------------------------------------+\n"
        display_cpu_details
        test_pass
        ;;
    3)
        echo -e "\n+-----------------------------------------------+"
        echo -e "|\t\tTesting For WIFI\t\t|"
        echo -e "+-----------------------------------------------+\n"
        display_wifi_info
        test_pass
        ;;
    4)
        echo -e "\n+-----------------------------------------------+"
        echo -e "|\t\tTesting For PHY\t\t\t|"
        echo -e "+-----------------------------------------------+\n"
        display_phy_details
        test_pass
        ;;
    5)
        echo -e "\n+-----------------------------------------------+"
        echo -e "|\t\tTesting For Total Memory\t|"
        echo -e "+-----------------------------------------------+\n"
        memory
        test_pass
        ;;
    6)
        echo -e "\n\t\t\t/* --->  Testing For Flash Memory  <--- */\n"
        flash_memory_details
        test_pass
        ;;
    7)
        echo -e "\n\t\t\t/* --->  Testing For LED  <--- */\n"
        led_test
        ;;
    8)
        echo -e "\n\t\t\t/* --->  Testing For ALL pheripheral  <--- */\n"
        display_connected_ips 
        ip_ping 1
        sleep 4
        display_cpu_details
        test_pass
        sleep 4
        display_wifi_info
        test_pass
        sleep 4
        display_phy_details
        test_pass
        sleep 4
        flash_memory_details
        test_pass
        sleep 4
        led_test 1
        sleep 4
        ;;
    9)
        exit 0
        ;;
    *)
        echo "Invalid option. Please enter a valid option."
        ;;
    esac
done

============================================================================================================================






NFT(Network File Transfer)
==========================


Server (Linux) :
--------
step 1 : sudo apt-get install nfs-kernel-server
step 2 : mkdir /home/zumi/tftp
step 2 : sudo vim /etc/exports             ----> // insaid file we need do modify        /home/zumi/tftp 192.168.1.1(rw,sync,no_root_squash,no_subtree_check)     //change clint ip 
step 3 : sudo exportfs -ra

/home/zumi/tftp 192.168.0.172(rw,sync,no_root_squash,no_subtree_check)


check status
---------------
sudo systemctl status nfs-kernel-server
sudo systemctl start nfs-kernel-server
sudo exportfs -v



Check Firewall on Server:
sudo ufw allow from 192.168.0.141 to any port nfs

Restart the NFS Service:
sudo systemctl restart nfs-kernel-server

sudo ufw allow from 192.168.0.172 to any port 111  # For rpcbind
sudo ufw allow from 192.168.0.172 to any port 2049  # For NFS
sudo ufw allow from 192.168.0.172  # Allow all traffic from the client IP if needed
sudo ufw reload
sudo ufw status
sudo ufw allow 111
sudo ufw allow 2049



Client (OpenWrt) :
-----------------

step 1 : mkdir /mnt/remote2
step 2 : mount.nfs 192.168.1.10:/home/zumi/tftp /mnt/remote2 -o nolock             // change server ip 



mount -t nfs -o vers=3,nolock 192.168.0.141:/home/zumi/tftp /mnt/remote2
increasing size of tmpfs : mount -o remount,size=100M /tmp




======================================================================================================

root@OpenWrt:/mnt/remote2# 
root@OpenWrt:/mnt/remote2# ls -lh
-rw-rw-r--    1 1000     1000       45.3M Mar 20  2024 1.img
-rw-r--r--    1 1000     1000       42.2M Mar  5  2024 11.img
-rw-r--r--    1 1000     1000       42.2M Mar  5  2024 12.img
-rw-r--r--    1 1000     1000       42.2M Mar  5  2024 13.img
-rw-r--r--    1 1000     1000       42.2M Mar  5  2024 14.img
-rw-r--r--    1 1000     1000       42.4M Mar  5  2024 15.img
-rw-r--r--    1 1000     1000       42.4M Mar  6  2024 16.img
-rw-r--r--    1 1000     1000       42.4M Mar  6  2024 17.img
-rw-r--r--    1 1000     1000       42.4M Mar  6  2024 18.img
-rw-r--r--    1 1000     1000       42.2M Mar  6  2024 1_both_wifi_1_and_2_all_updated_package.img
-rw-r--r--    1 1000     1000       42.2M Mar  6  2024 1_wifi_1_all_updated_package.img
-rw-r--r--    1 1000     1000       38.3M Mar 22  2024 2.img
-rw-r--r--    1 1000     1000       42.2M Mar 11  2024 3.img
-rw-r--r--    1 1000     1000       36.8M Mar 15  2024 5.img
-rw-rw-r--    1 1000     1000       42.2M Mar 22  2024 abi
-rw-r--r--    1 1000     1000       42.4M Mar 15  2024 mani.img
-rw-r--r--    1 1000     1000       42.4M Mar 15  2024 mani1.img
-rw-r--r--    1 1000     1000       38.3M Apr  2  2024 nand-ipq5018-single.img
-rw-rw-r--    1 1000     1000       48.1M Apr  2  2024 norplusnand-ipq5018-single.img
-rw-r--r--    1 1000     1000       45.3M Apr  2  2024 norplusnand-ipq5018_1G_new6-single.img
-rw-r--r--    1 1000     1000       31.3M Mar 29  2024 out.bin
-rw-r--r--    1 1000     1000       31.3M Mar 29  2024 out.tar
-rw-rw-r--    1 1000     1000       45.3M Mar 13  2024 sir1.img
-rw-r--r--    1 1000     1000       42.4M Mar 13  2024 sir2.img
-rw-r--r--    1 1000     1000       38.8M Apr  3  2024 sudhakar.img
-rw-r--r--    1 1000     1000       39.1M Apr  3  2024 sudhakar1.img
-rw-r--r--    1 1000     1000       42.4M Mar 11  2024 suu.img
drwxrwxr-x    2 1000     1000       12.0K Mar  5  2024 test_binarys
root@OpenWrt:/mnt/remote2# 
root@OpenWrt:/mnt/remote2# 
root@OpenWrt:/mnt/remote2# 
root@OpenWrt:/mnt/remote2# 
root@OpenWrt:/mnt/remote2# 
root@OpenWrt:/mnt/remote2# ls
ls     lsblk  lsmod
root@OpenWrt:/mnt/remote2# ls
ls     lsblk  lsmod
root@OpenWrt:/mnt/remote2# cd /tmp/
root@OpenWrt:/tmp# ls
ls     lsblk  lsmod
root@OpenWrt:/tmp# ls
ls     lsblk  lsmod
root@OpenWrt:/tmp# ls -l
drwxr-xr-x    3 root     root            60 May 27 05:09 BT_FW
drwxr-xr-x    2 root     root            60 Jan  1  1970 IPQ5018
-rw-r--r--    1 root     root             4 May 27 05:09 TZ
srwxr-xr-x    1 root     root             0 May 27 05:10 acfg-app
-rw-r--r--    1 root     root           189 Jan  1  1970 board.json
-rw-r--r--    1 root     root             0 May 27 05:10 bootup_completed
-rw-r--r--    1 root     root            47 May 27 05:34 dhcp.leases
drwxr-xr-x    2 root     root            40 May 27 05:09 dnsmasq.d
drwxr-xr-x    4 root     root           100 May 27 05:34 etc
drwxr-xr-x    2 root     root            40 Jan  1  1970 extroot
-rw-r--r--    1 root     root             0 May 27 05:10 first_boot_done
-rw-r--r--    1 root     root             2 May 27 05:10 firstboot
-rw-r-----    1 root     root             0 May 27 05:09 hostapd.txt
drwxr-xr-x    2 root     root            60 May 27 05:34 hosts
-rw-r--r--    1 root     root             0 May 27 05:09 kmodloader_done
drwxr-xr-x    3 root     root            60 May 27 05:09 lib
drwxr-xr-x    2 root     root           500 May 27 05:12 lock
drwxr-xr-x    3 root     root           100 May 27 05:10 log
-rw-r--r--    1 root     root           216 May 27 05:34 mcs.conf
-rw-r--r--    1 root     root             2 May 27 05:09 no_qca_da
drwxr-xr-x    2 root     root            40 May 27 05:12 opkg-lists
drwxr-xr-x    2 root     root            40 Jan  1  1970 overlay
drwxr-xr-x    2 root     root            60 Jan  1  1970 qcn6122
drwxr-xr-x    2 root     root            60 Jan  1  1970 qcn9000
-rw-r--r--    1 root     root             0 May 27 05:10 qdss_sink_config_done
-rw-r--r--    1 root     root            32 May 27 05:34 resolv.conf
-rw-r--r--    1 root     root             0 May 27 05:09 resolv.conf.auto
drwxr-xr-x    7 root     root           420 May 27 05:34 run
drwxrwxrwt    2 root     root            40 Jan  1  1970 shm
drwxr-xr-x    2 root     root            60 May 27 05:10 state
drwxr-xr-x    2 root     root            80 Jan  1  1970 sysinfo
drwxr-xr-x    2 root     root            40 May 27 05:09 tmp
drwxr-xr-x    3 root     root            60 May 27 05:12 usr
-rw-r--r--    1 root     root       1048576 May 27 05:10 virtual_art.bin
root@OpenWrt:/tmp# df -h
Filesystem                Size      Used Available Use% Mounted on
/dev/mtdblock20          14.3M     14.3M         0 100% /rom
tmpfs                    77.1M      1.5M     75.6M   2% /tmp
/dev/ubi0_4              21.8M    180.0K     20.5M   1% /overlay
overlayfs:/overlay       21.8M    180.0K     20.5M   1% /
tmpfs                   512.0K         0    512.0K   0% /dev
/dev/mtdblock18           6.3M      6.3M         0 100% /lib/firmware/IPQ5018/WIFI_FW
192.168.1.10:/home/zumi/tftp
                        915.8G    782.6G     86.6G  90% /mnt/remote2















































CAN[1]
===============

1.normal can

   CAN Protocol:

		The CAN protocol, also known as "Classical CAN," is the original version of the CAN protocol that has been widely used in various 			industries for many years. It was initially developed for automotive applications but has since been adopted in other domains. 			The CAN protocol specifies the standard frame format, arbitration, error handling, and other fundamental aspects of communication.

		The CAN protocol uses a fixed data frame size of up to 8 bytes, with a maximum bit rate of 1 Mbps. It provides reliable and 			deterministic communication between nodes in a network, making it suitable for real-time and safety-critical applications.

  Standard CAN or Extended CAN


      standard can:  (1mpbs --- 11 bit identifier)(can 2.0 A)

         
                • SOF—The single dominant start of frame (SOF) bit marks the start of a message, and is
                  used to synchronize the nodes on a bus after being idle.

                • Identifier—The Standard CAN 11-bit identifier establishes the priority of the message. The
                  lower the binary value, the higher its priority

                • RTR—The single remote transmission request (RTR) bit is dominant when information is
		  required from another node. All nodes receive the request, but the identifier determines the
		  specified node. The responding data is also received by all nodes and used by any node
	          interested. In this way all data being used in a system is uniform.

	        • IDE—A dominant single identifier extension (IDE) bit means that a standard CAN identifier
     		  with no extension is being transmitted.	

		• r0—Reserved bit (for possible use by future standard amendment).

		• DLC—The 4-bit data length code (DLC) contains the number of bytes of data being
		  transmitted.

		• Data—Up to 64 bits of application data may be transmitted.

		• CRC—The 16-bit (15 bits plus delimiter) cyclic redundancy check (CRC) contains the
		  checksum (number of bits transmitted) of the preceding application data for error detection.

   		• ACK—Every node receiving an accurate message overwrites this recessive bit in the original
	          message with a dominate bit, indicating an error-free message has been sent. Should a
    	 	  receiving node detect an error and leave this bit recessive, it discards the message and the
  	 	  sending node repeats the message after rearbitration. In this way each node acknowledges
    	          (ACK) the integrity of its data. ACK is 2 bits, one is the acknowledgement bit and the second
	          is a delimiter.

		• EOF—This end-of-frame (EOF) 7-bit field marks the end of a CAN frame (message) and
   		  disables bit–stuffing, indicating a stuffing error when dominant. When 5 bits of the same logic
  	          level occur in succession during normal operation, a bit of the opposite logic level is stuffed
		  into the data.

                • IFS—This 7-bit inter-frame space (IFS) contains the amount of time required by the
	   	  controller to move a correctly received frame to its proper position in a message buffer area


     Extended CAN:(1mpbs --- 29 bit identifier)(can 2.0 B)


               • SRR—The substitute remote request (SRR) bit replaces the RTR bit in the standard 
                 message location as a placeholder in the extended format.

	       • IDE—A recessive bit in the identifier extension (IDE) indicates that there are more identifier	
 	         bits to follow. The 18-bit extension follows IDE.

	       • r1—Following the RTR and r0 bits, an additional reserve bit has been included ahead of the
	         DLC bit.




       Message Types

 		There are four different message types, or frames (Figures 2 and 3) that can be transmitted on a
 		CAN bus: the data frame, the remote frame, the error frame, and the overload frame. A
		message is considered to be error free when the last bit of the ending EOF field of a message is
		received in the error–free recessive state. A dominant bit in the EOF field causes the transmitter
		to repeat a transmission.
  The Data Frame

		The data frame is the most common message type, and is made up by the arbitration field, the
		data field, the CRC field, and the acknowledgement field. The arbitration field determines the
		priority of a message when two or more nodes are contending for the bus. The arbitration field
		contains an 11-bit identifier for CAN 2.0A in Figure 2 and the RTR bit, which is dominant for data
		frames. For CAN 2.0B in Figure 3 it contains the 29-bit identifier and the RTR bit. Next is the
		data field which contains zero to eight bytes of data, and the CRC field which contains the 16-bit
		checksum used for error detection. Lastly, there is the acknowledgement field. Any CAN
		controller that is able to correctly receive a message sends a dominant ACK bit that overwrites
		the transmitted recessive bit at the end of correct message transmission. The transmitter checks
		for the presence of the dominant ACK bit and retransmits the message if no acknowledge is
		detected.
  The Remote Frame

		The intended purpose of the remote frame is to solicit the transmission of data from another
		node. The remote frame is similar to the data frame, with two important differences. First, this
		type of message is explicitly marked as a remote frame by a recessive RTR bit in the arbitration
		field, and secondly, there is no data.

 The Error Frame

		The error frame is a special message that violates the formatting rules of a CAN message. It is
		transmitted when a node detects an error in a message, and causes all other nodes in the
		network to send an error frame as well. The original transmitter then automatically retransmits
		the message. There is an elaborate system of error counters in the CAN controller which
		ensures that a node cannot tie up a bus by repeatedly transmitting error frames.

 The Overload Frame

		The overload frame is mentioned here for completeness. It is similar to the error frame with
		regard to the format, and it is transmitted by a node that becomes too busy. It is primarily used to
		provide for an extra delay between messages.

 Error Checking and Fault Confinement

		The robustness of CAN may be attributed in part to its abundant error checking procedures. The
		CAN protocol incorporates five methods of error checking: three at the message level and two at
		the bit level. If a message fails with any one of these error detection methods, it is not accepted
		and an error frame is generated from the receiving nodes, causing the transmitting node to
		resend the message until it is received correctly. However, if a faulty node hangs up a bus by
		continuously repeating an error, its transmit capability is removed by its controller after an error
                limit is reached




----------------------------------------------------------

2.canfd
 
  CAN FD :
          *   CAN FD bit rate can be up to 8MBit/s with the right CAN SIC (Signal Improvement Capability) Transceiver and so up to 8 times faster
              than classic CAN with 1MBit/s data phase.

          *  CAN FD solves the bandwidth limitation problem by allowing bit-rates higher than 1 Mbit/s while also increasing the support of 		   payloads in a CAN FD message above the previous maximum of 8 bytes.  Many automotive companies are still looking at the bit-rates they 		   will use in the car, but some of the most common ones are 2 and 5 Mbit/s while others are looking at using up to 8 Mbit/s for bit
           applications like ECU flashing and transmitting long messages.  CAN FD formatted frames significantly increase the payload support by 
           allowing up to 64 bytes in a single message.

 CAN FD Protocol:
			The CAN FD (Flexible Data-Rate) protocol is an enhanced version of the CAN protocol. It was developed to meet the 				increasing demand for higher data rates and larger payload sizes in modern applications. CAN FD allows for flexible data 				rates and larger frame sizes, enabling faster and more efficient communication.

			Unlike the fixed frame size in the CAN protocol, CAN FD allows for payload lengths of up to 64 bytes. It also supports 				higher bit rates, reaching up to 5 Mbps or more. By increasing the payload size and data rates, CAN FD enables faster 				transmission of larger amounts of data, improving the efficiency and flexibility of communication in certain applications.






 Minimal Upgrade and Migration Costs :


   		Outside of CAN, there are other in-vehicle networks that have higher communication bandwidths than 1 Mbit/s.  However, these 			networks, like FlexRay and automotive Ethernet, are significantly different from the CAN physical layer, which means that making 			a change to support them instead of CAN is very expensive for the suppliers and OEMs. 

		CAN FD is also ideal for this problem because the physical layer is the same as high-speed CAN.  The only difference in the 			hardware is to use a new protocol controller with a qualified transceiver that allows the faster speeds.  Also, the software 			changes are minimal since the message format is very similar.  In fact, there are no software changes needed when using CAN FD 			messages at speeds up to 1 Mbit/s and 8 byte payloads.



   There are many similarities between a typical CAN message format and the format of a CAN FD message, but there are several key differences 
   that need to be taken into account.  The important additions and CAN FD message format specifications are outlined below:


         Extended Data Length (EDL): 
                                     the reserved bit after the IDE or after the RTR bit in a standard CAN frame that is transmitted recessive.

                          r1, r0,r1: 
                                     is reserved for future protocol expansion and r0 is used for resynchronization before the optional bit-rate
                                     switch.  Both bits are transmitted dominant.
 
              Bit Rate Switch (BRS):
                                     A dominant transmission means the bit-rate in the data phase is the same as the arbitration phase while a
                                     recessive transmission signifies a faster bit-rate for the data phase.

        Error State Indicator (ESI): 
                                     a dominant transmission for error active and recessive transmission for error passive.
  
             Data Length Code (DLC): 
                                     DLC values ranging from 1001 to 1111 are used to specify the data lengths of 12, 16, 20, 24, 32, 48, and 64
                                     bytes.

      Cyclic Redundancy Check (CRC): 
                                     The length of the CRC depends upon the length of the DLC and EDL. The CRC is 15-bits for CAN messages and  
                                     either 17 or 21-bits for CAN FD.


--------------------------------------

3,canj1939




     can j1939 Overview:

                       J1939 uses CAN (Controller Area Network, ISO11998) as physical layer. It is a recommended practice that
		       defines which and how the data is communicated between the Electronic Control Units (ECU) within a vehicle
		       network. Typical controllers are the Engine, Brake, Transmission, etc.

     The particular characteristics of J1939 are:
              
            • Extended CAN identifier (29 bit) 
 
            • Bit rate 250 kbit/s
            
            • Peer-to-peer and broadcast communication
 
            • Transport protocols for up to 1785 data bytes

            • Network management

            • Definition of parameter groups for commercial vehicles and others
          
            • Manufacturer specific parameter groups are supported
            
            • Diagnostics features


    Peer-to-peer (P2P) communication:
				      In a peer-to-peer communication system, multiple participants or nodes in a network can directly 					      communicate with each other without the need for a centralized server or authority. Each node can act as 					      both a client and a server, sharing and requesting resources directly from other nodes in the network.



    Parameter Groups:
			A parameter group is a set of parameters belonging to the same topic and sharing the same transmission rate. The
			definition of the application relevant parameter groups and parameters can be found in application layer document
			[9].

			The length of a parameter group is not limited to the length of a CAN frame. Usually a parameter group has a
			minimum length of 8 bytes up to 1785 bytes. Parameter groups with more than 8 bytes require a transport protocol
			for transmission.	


   Interpretation of the CAN Identifier:

			* The CAN identifier of a J1939 message contains Parameter Group Number (PGN), source address, priority, data
			  page bit, extended data page bit and a target address (only for a peer-to-peer PG).

                       •  With PDU format < 240 (peer-to-peer), PDU specific contains the target address. Global (255) can also be
                          used as target address. Then the parameter group is aimed at all devices. In this case, the PGN is formed
                          only from PDU format.

                       • With PDU format >= 240 (broadcast), PDU format together with the Group Extension in the PDU specific
                         field forms the PGN of the transmitted parameter group.


   Parameter Group Number:

                        * Each parameter group is addressed via a unique number – the PGN. For the PGN a 24 bit value is used that is
                         composed of the 6 bits set to 0, PDU Format (8 bits), PDU Specific (8 bits), Data Page (1 bit) and Extended Data
                         Page (1 bit).

                                    *>> There are two types of Parameter Group Numbers  <<*

			• Global PGNs identify parameter groups that are sent to all (broadcast). Here the PDU Format, PDU
			  Specific, Data Page and Extended Data Page are used for identification of the corresponding Parameter
			  Group. On global PGNs the PDU Format is 240 or greater and the PDU Specific field is a Group
			  Extension.

			• Specific PGNs are for parameter groups that are sent to particular devices (peer-to-peer). Here the PDU
		          Format, Data Page and Extended Data Pare are used for identification of the corresponding Parameter
			  Group. The PDU Format is 239 or less and the PDU Specific field is set to 0.



   Suspect Parameter Number (SPN):

			*  A suspect parameter number is assigned to each parameter of a parameter group or component. It is used for
		       	  diagnostic purpose to report and identify abnormal operation of a Controller Application (CA).

			*  The SPN is a 19 bit number and has a range from 0 to 524287. For proprietary parameters a range from 520192 to
			  524287 is reserved.




       *  1 >>> Bit rat calculation 


                 To calculate the bit rate in the CAN J1939 protocol, 

    			Baud Rate: Determine the desired baud rate for your communication. The baud rate represents the number of bits 				transmitted per second.

    		        Time Quantum: In the J1939 protocol, the time quantum (Tq) is typically fixed at 8, meaning each bit is divided into 8 				time segments. This value is specific to the J1939 protocol and may differ in other CAN implementations.

   		       Sample Point: The sample point is the point in time during each bit where the voltage level is sampled to determine the 			       bit value. In J1939, the sample point is commonly set to 75% of the bit time (Tq).

		       With these parameters, you can calculate the bit rate using the following formula:

                       Bit Rate = (1 / Total Bit Time) * Number of Bits in a Message

                       The Total Bit Time is calculated as follows:

                       Total Bit Time = (Sync Segment + Propagation Segment + Phase Segment 1 + Phase Segment 2) * Tq

                       In the J1939 protocol, the Sync Segment is fixed at 1 Tq, the Propagation Segment is typically set to accommodate the
                       physical layer characteristics, and Phase Segment 1 and Phase Segment 2 are adjusted to achieve the desired sample point.

                      The TQ is typically determined by the specific CAN controller and physical layer being used. It represents the smallest 			      time resolution or granularity that can be achieved in the CAN system. The duration of a TQ is calculated based on the CAN  controller's clock frequency and is usually specified in units of time, such as microseconds or nanoseconds.

For example, in the J1939 protocol, which is a specific application of the CAN protocol used in the automotive industry, the TQ is typically fixed at 8. This means that each bit is divided into 8 time segments, and the duration of each TQ is equal to one-eighth of the total bit time.

The TQ value is an important parameter in determining the timing and synchronization of the CAN communication system. It is used in conjunction with other timing parameters, such as the Sync Segment, Propagation Segment, and Phase Segments, to define the overall bit time and ensure reliable data transmission and reception in the CAN network.





                                               >>>>      SPN PGN FRAME    <<<<<<



                    Yes, in the J1939 protocol, Parameter Group Numbers (PGNs) and Suspect Parameter Numbers (SPNs) are used to form frames for communication. Let's break down the process of forming and detailing J1939 frames.

    Frame Structure:
        J1939 frames consist of an identifier and payload. The identifier contains information about the source address, destination address, priority, and PGN.
        The payload contains the data being transmitted, which may include SPNs representing specific parameters.

    PGN (Parameter Group Number):
        A PGN is a unique identifier used to categorize and group related messages in J1939.
        It is a 3-byte value that consists of an extended data page (EDP), PDU format (PF), and PDU specific (PS) fields.
        The EDP determines the data page, the PF identifies the message type or group, and the PS provides additional information specific to the PF.

    SPN (Suspect Parameter Number):
        An SPN represents a specific parameter or measurement within a PGN.
        It is a 19-bit identifier used to uniquely identify a parameter within a PGN.
        SPNs can represent various types of information, such as engine speed, coolant temperature, fuel level, etc.

    Frame Formation:
        To form a J1939 frame, the PGN and SPNs are utilized.
        The PGN is assigned to the frame based on the type of data being transmitted.
        The SPNs representing the specific parameters of interest are included in the payload of the frame.

    Frame Details:
        When a J1939 frame is received, its identifier is examined to determine the source address, destination address, priority, and PGN.
        The PGN helps identify the purpose and content of the frame.
        The SPNs within the payload can be extracted to retrieve specific parameter values or measurements.

It's important to note that the exact details of frame formation and decoding can vary depending on the specific implementation and the manufacturer's interpretation of the J1939 standard. However, the concepts described above provide a general understanding of how PGNs, SPNs, and frames are formed and utilized in the J1939 protocol.







                              >>>>>>> BIT Configration <<<<<<<



   Yes, J1939 defines a standard bit configuration for its data communication. The J1939 standard is a protocol used for communication and diagnostics among vehicle components in heavy-duty vehicles.

The J1939 standard specifies the use of a Controller Area Network (CAN) bus for communication. The CAN bus is a two-wire bus system that uses a differential voltage to transmit data. Each bit on the CAN bus is represented by a dominant or recessive state.

In J1939, the bit configuration follows the CAN specification, which uses non-return-to-zero (NRZ) coding. In NRZ coding, a dominant state is represented by a logical 0 (low voltage), and a recessive state is represented by a logical 1 (high voltage).

The physical layer of the J1939 network defines the baud rate, the electrical characteristics, and the signaling scheme. It specifies the bit timing and synchronization requirements for proper communication.

To summarize, the J1939 bit configuration follows the CAN specification, which uses non-return-to-zero (NRZ) coding, where a dominant state is represented by a logical 0 and a recessive state is represented by a logical 1. The physical layer of the J1939 network defines the specific bit timing and electrical characteristics for communication.





                               >>>>>>>  J1939 protocol, arbitration    <<<<<<<<<<

              



In the J1939 protocol, arbitration is the process by which multiple nodes on the network compete for access to the CAN bus to transmit their messages. The arbitration process ensures that only one node transmits at a time to avoid data collisions.

J1939 uses Carrier Sense Multiple Access with Collision Detection (CSMA/CD) as the arbitration mechanism. Here's how the arbitration process works:

    Priority-based Message IDs: Each J1939 message has a unique identifier called a Parameter Group Number (PGN), which consists of an 18-bit message identifier (CAN ID). The PGN is used to determine the priority of the message. Lower PGNs indicate higher priority.

    Bus Idle: When the bus is idle, any node that wants to transmit a message can begin.

    Start of Frame (SOF): The node that wants to transmit a message sends a Start of Frame (SOF) bit, which marks the beginning of the message and signals the start of arbitration.

    Message Identifier (CAN ID): After the SOF bit, the transmitting node sends its message identifier (CAN ID), which includes the PGN. The CAN ID is transmitted bit by bit.

    Bit Comparison: While transmitting its CAN ID, each node continuously monitors the CAN bus to detect if another node with a lower priority is transmitting at the same time. Nodes compare the transmitted bits on the bus with their own CAN ID bits.

    Dominant vs. Recessive Bits: In case of a conflict, where two nodes transmit bits of the same value simultaneously, the bit with a dominant state (logical 0) takes priority over a bit with a recessive state (logical 1). This is because a logical 0 is represented by a lower voltage level on the bus.

    Priority Decision: As nodes transmit their bits, they compare the dominant/recessive states of each bit. If a node detects a higher priority message (lower PGN) being transmitted by another node, it stops its transmission and waits for the bus to become idle again.

    Message Transmission: The node with the highest priority (lowest PGN) continues to transmit its message without interruption. Other nodes wait for their turn during the next idle bus state.

By following this arbitration process, J1939 ensures that messages with higher priority have precedence over lower priority messages, allowing for efficient and organized data transmission on the network.




                       >>>>   J1939, the claiming process      <<<<<




  In J1939, the claiming process is used by electronic control units (ECUs) on the network to obtain a unique address, known as a "Name" or "Source Address." The claiming process helps ensure that each ECU has a distinct identity on the J1939 network.

Here's how the J1939 claiming process works:

    Bus Initialization: When the J1939 network is powered up or reset, all ECUs start in an unclaimed state. At this stage, all ECUs have the same default address of 0x000.

    Claiming Address: An ECU that wants to join the network starts the claiming process by transmitting a message called a "Request for Address Claim" (RAC). The RAC message contains the desired address that the ECU wants to claim.

    Address Conflict Detection: Other ECUs on the network monitor the bus and detect the RAC message. If an ECU already has the same desired address, it will respond with a "Address Claimed" (AC) message to indicate that it currently occupies that address.

    Collision Resolution: If multiple ECUs attempt to claim the same address simultaneously, a collision occurs. In this case, the ECUs involved in the collision initiate a backoff algorithm, where they randomly delay their retransmission attempts. This random delay helps avoid repeated collisions and ensures fair access to the bus.

    Address Assignment: The ECU that successfully transmits the RAC message without encountering collisions receives an "Address Acknowledgment" (ACK) message from other ECUs on the network. This ACK message indicates that the desired address is available and has been assigned to the claiming ECU.

    Address Confirmation: The claiming ECU sets its source address to the newly assigned address received in the ACK message. From this point forward, the ECU uses this unique address for communication on the J1939 network.

By following the claiming process, ECUs on the J1939 network can establish unique addresses and avoid address conflicts. This ensures that each ECU can be identified and communicated with effectively on the network.




                                         >>>>>>>  can j1939 phase segments <<<<<<<<





In the context of J1939, phase segments are used in the bit timing of the CAN (Controller Area Network) bus. The phase segments determine the time allocation for different stages of data transmission on the bus. However, it's important to note that J1939 does not explicitly define or specify phase segments 1, 2, and 3. The specific bit timing parameters, including the length of phase segments, are typically defined by the physical layer implementation of the CAN bus.

In general, the bit timing of a CAN bus consists of several segments, including:

    Synchronization Segment (SYNC): This segment helps to synchronize all nodes on the bus and is typically a fixed length.

    Propagation Segment (PROP): The propagation segment accounts for the time taken by the electrical signals to travel along the bus. Its duration depends on the physical length of the bus and other factors.

    Phase Segment 1 (PS1): Phase segment 1 follows the propagation segment and allows for controlled sampling of the bus voltage to determine the bit value.

    Phase Segment 2 (PS2): Phase segment 2 follows PS1 and provides additional time for the receivers to stabilize and sample the bus voltage accurately.

    Resynchronization Jump Width (SJW): SJW determines the maximum allowed deviation in the synchronization between nodes. It specifies the number of time quanta by which the phase segments can be extended or reduced to maintain synchronization.

The lengths of the phase segments, as well as the SJW, are typically configurable parameters that can be adjusted based on the specific requirements of the network. The chosen bit timing parameters affect the overall bus speed, data integrity, and robustness of the communication system.

To implement J1939 communication, the CAN bus must adhere to the required bit timing parameters and synchronization rules, which are defined by the applicable physical layer specification (e.g., CAN High-Speed or CAN FD). The specific values for phase segments and other timing parameters should be determined based on the chosen physical layer implementation and the requirements of the J1939 application.




                                         >>>>> CAN J1939 prescaler  <<<<<<<






J1939 does not define specific prescaler values for the CAN bus. Prescaler values are part of the CAN controller's configuration, which is typically specific to the hardware implementation of the CAN bus.

The prescaler is a configurable parameter that determines the division factor applied to the system clock to derive the CAN bit timing parameters. It allows for adjusting the bit rate of the CAN bus to match the desired communication speed.

The actual prescaler values and their range depend on the specific hardware implementation of the CAN controller. Different CAN controllers may have different prescaler options available. The prescaler values are typically specified in terms of clock cycles or numerical values.

When working with J1939, the specific prescaler values need to be determined based on the chosen CAN controller or CAN transceiver being used in the implementation. The CAN controller or transceiver datasheet or manufacturer's documentation should provide guidance on the available prescaler options and their corresponding impact on the bit timing parameters.

It's worth noting that the J1939 standard does define requirements and guidelines for the CAN bus baud rate, synchronization, and other bit timing parameters. These requirements ensure proper communication and interoperability between J1939-compliant devices. However, the specific prescaler values are not standardized by J1939 itself and are implementation-specific




                                 >>>>>> CAN J1939 Protocol calculate the frequency <<<<<<<




To calculate the frequency for the J1939 protocol, you need to consider the bit rate or baud rate at which the CAN bus operates. The J1939 standard specifies a maximum baud rate of 250 kbps for the CAN bus.

The frequency calculation is straightforward:

Frequency = Baud Rate / Number of Bits per Message

For J1939, the baud rate is typically set at 250,000 bits per second (250 kbps). The number of bits per message depends on the specific message format and payload size.

In J1939, each message consists of a CAN ID (message identifier) and the data payload. The CAN ID is 29 bits long, and the data payload can vary in size depending on the specific message.

To calculate the frequency, you would need to determine the total number of bits in a J1939 message, including the CAN ID and the data payload.

Let's assume we have a J1939 message with a CAN ID of 29 bits and a data payload of 64 bits. The total number of bits per message would be:

Total Bits per Message = CAN ID + Data Payload
= 29 bits + 64 bits
= 93 bits

Now, you can calculate the frequency:

Frequency = Baud Rate / Total Bits per Message
= 250,000 bps / 93 bits
≈ 2688.17 Hz

So, in this example, the frequency for the J1939 message transmission would be approximately 2688.17 Hz.

It's important to note that this calculation assumes ideal conditions and doesn't take into account protocol overhead, error handling, or other factors that may affect the actual data throughput on the CAN bus. The actual effective data transfer rate may be lower due to factors such as bus utilization, acknowledgment frames, and error frames.





                                      >>>>>>>>> CAN J1939 protocol frame standardized   <<<<<<<






The J1939 protocol follows a specific frame format or message structure that is standardized within the J1939 specification. The J1939 frame format defines how data is organized and transmitted on the CAN bus within the context of the J1939 protocol.

The J1939 frame format consists of several components:

    Priority: The priority field determines the relative importance of the message. Lower numerical values indicate higher priority.

    Parameter Group Number (PGN): The PGN identifies the type and content of the message. It consists of an 18-bit identifier and helps receivers understand the meaning of the data.

    Data Page: The data page field indicates the specific page within a multi-page message. It is typically used for messages with large data payloads that require multiple frames.

    Extended Data Page: The extended data page field provides further extension to the data page field, allowing for an increased number of data pages in multi-page messages.

    Source Address: The source address identifies the transmitting node or Electronic Control Unit (ECU) on the J1939 network.

    Data Field: The data field contains the actual payload of the message. The size of the data field can vary depending on the specific message type and content.

    CRC (Cyclic Redundancy Check): The CRC field is used for error detection and ensures the integrity of the transmitted data.

The J1939 frame format allows for both broadcast messages, which are received by all nodes on the network, and point-to-point messages, which are intended for a specific recipient.

Additionally, J1939 defines different message types, such as the Parameter Group (PG) messages, which provide standardized data for specific functions, and the Address Claim (AC) message, which is used during the claiming process to establish unique source addresses.

The standardized frame format in J1939 enables interoperability and communication between different ECUs on the J1939 network. It ensures that messages are properly structured, identifiable, and can be correctly interpreted by receiving nodes.





                                 >>>>>>>> CAN J1939 protocol fram format  <<<<<<<<







The J1939 protocol follows a specific frame format for transmitting data over the CAN bus. The J1939 frame format consists of the following components:

    Start of Frame (SOF): The SOF bit marks the beginning of a J1939 message frame. It is a dominant (logical 0) bit.

    Priority: The priority field is 3 bits long and indicates the relative importance of the message. Lower values represent higher priority. The priority field determines the order in which messages are transmitted on the bus.

    Parameter Group Number (PGN): The PGN field is 18 bits long and identifies the type and content of the message. It indicates the purpose of the message and allows receiving nodes to interpret the data correctly.

    Data Page: The Data Page field is 1 bit long and is used for messages with large data payloads that require multiple frames. It indicates the current data page within a multi-page message.

    Extended Data Page: The Extended Data Page field is 1 bit long and provides further extension to the Data Page field. It allows for an increased number of data pages in multi-page messages.

    Protocol Data Unit (PDU) Format: The PDU Format field is 8 bits long and identifies the message format and structure. It determines whether the message is a request, a command, or a data message.

    Source Address: The Source Address field is 8 bits long and identifies the transmitting node or Electronic Control Unit (ECU) on the J1939 network. Each ECU is assigned a unique source address.

    Data Field: The Data Field contains the actual payload of the message. The size of the Data Field can vary depending on the specific message type and content. It can range from 0 to 1785 bits.

    Cyclic Redundancy Check (CRC): The CRC field is 16 bits long and provides error detection capability. It ensures the integrity of the transmitted data and allows receiving nodes to detect and discard corrupted messages.

    End of Frame (EOF): The EOF field marks the end of the J1939 message frame. It consists of 7 recessive (logical 1) bits.

The J1939 frame format ensures standardized communication and data interpretation among different ECUs on the J1939 network. It allows for the reliable transmission and reception of messages, ensuring accurate and consistent data exchange between vehicle components.






                              >>>>> can j1939 protocol read and writ data configurations <<<<<<<<




Certainly! Here is a more detailed explanation of reading and writing data configurations in J1939:

Reading Data Configuration:

    Identify the Parameter Group (PG) and its associated Parameter Group Number (PGN) that contains the data you want to read. The J1939 standard and relevant documentation for your application should provide a list of available PGNs and their descriptions.
    Construct a Request message with the appropriate PGN. The Request message is typically a broadcast message sent to all nodes on the network. Set the PGN field of the Request message to the desired PGN.
    Send the Request message on the CAN bus.
    The target ECU that receives the Request message and has data corresponding to the requested PGN will respond with a Data Transfer message. The Data Transfer message contains the requested data.
    Receive and interpret the Data Transfer message. Extract the relevant data fields based on the data structure defined for the specific PGN. Apply any scaling factors or unit conversions as specified in the J1939 standard or documentation.
    Process and use the received data for your intended purposes.

Writing Data Configuration:

    Identify the Parameter Group (PG) and its associated Parameter Group Number (PGN) that you want to write data to. The J1939 standard and relevant documentation for your application should provide a list of available PGNs and their descriptions.
    Construct a Data Transfer message with the appropriate PGN. Set the PGN field of the Data Transfer message to the desired PGN.
    Populate the data fields of the Data Transfer message with the values you want to write. Ensure that the values adhere to the data structure and format specified for the specific PGN.
    Transmit the Data Transfer message on the CAN bus. You can either send it to a specific target ECU or broadcast it to all nodes on the network, depending on your requirements.
    The receiving ECU that receives the Data Transfer message will process and apply the written configuration or values based on the specified PGN and data structure.
    Verify that the written data has been applied correctly by checking the relevant parameters or monitoring the system behavior.

It's important to consult the J1939 standard and relevant documentation specific to your application to determine the appropriate PGNs, their associated data structures, and any specific requirements or restrictions for reading and writing data configurations. Additionally, manufacturer's documentation or software tools for your J1939-compliant devices may provide further guidance and APIs for reading and writing data in a J1939 network.



**************************************************************************************************************************************





























imx8mm[2]
==================

1.office



Quick Start Guide for PICO-IMX8MM

PROPRIETARY NOTICE:
This document contains proprietary material for the sole use of the intended recipient(s). Do not read this document if you are not the intended recipient. Any review, use, distribution or disclosurenot the intended recipient (or authorized to receive for the recipient), you are herebynotified that any disclosure, copying distribution or use of any of the information contained within this document is STRICTLY PROHIBITED.


Thank you.

 

Table of Contents
INTRODUCTION	3
Building & Flashing ................................................. .	4
Peripherals/Functionality Validation	8
 



INTRODUCTION

Purpose and Scope
This document is to help the engineer to program the prebuilt binaries to the TechNexion PICO-IMX8MM platform and validate the peripherals/functionalities associated with TechNexion PICO-IMX8MM.

Acronyms
The following acronyms will be used throughout the document
 
 
Acronym 
Abbreviation 
gcc
Universal Serial Bus
GPIO
General Purpose Input Output
MAC
Media Access Control
UUU
  Universal Update Utility
OS 
  Operating System
SOM
System On Module
GSM
Global System for Mobile communication


Building & Flashing

    1. Download the Board requirements package
    • Download the Flashing package utility from the below link Download the UUU tool from our website:
https://download.technexion.com/development_resources/development_tools/installer/imx-mfg-uuu- tool_20210421.zip
Note: Extract a ZIP file named "imx-mfg-uuu-tool_20210421.zip"

 


    2. Download the Ubuntu Pre-built OS from the SOM module vendor site.
Download the image from the below link for the pico-imx8mm board EEEE

Index of /rescue/ (technexion.com)



       ◦ Click / go to “pico-imx8mm” link





        ◦ Click / go to “pi-dsi1280x720” link

        ◦ Download ubuntu20.04.xz





    3. Extracting files
Copy the ubuntu-20.04.xz into the folder /home/<UserName>/imx-mfg-uuu-tool_20210421/imx-mfg-uuu- tool.
Run the following command to extract the file.

$ xz -d ubuntu-20.04.xz

Following below screenshot will show the extracted image of ubuntu-20.04.xz





    4. Flashing the Image
     

   • Configure the board into flash mode using Jumper Setting. Please see the below image.



    • Before flashing you need to connect your PC to the Device.
       Note: You should remove the SD card from your device. 

    • Run the following command to flash the image

    • Go to the following path of your installed package folder ”/home/<UserName>/imx-mfg-uuu- tool_20210421/imx-mfg-uuu-tool”
$ cd /home/<PC UserName>/imx-mfg-uuu-tool_20210421/imx-mfg-uuu-tool

$ chmod 777 ./uuu/linux64/uuu

$ sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin ubuntu-20.04


 

    5. Booting
    • Once the flashing is completed.

    • Power off the board, Remove the boot jumpers from board.

    • Then Power on board, Boot log is coming from internal eMMC .

Testing Peripherals/Functionality below are
 
    1. GPIOs
    2. Audio Codec
    3. SD Card
    4. Ethernet
    5. GSM
    6. USB 
    7. RS485
    8. UART

Note: Before running the commands in the terminal, you have to follow the below one.

Note : The below command should be run in the “Putty” application.
$sudo -s 
Password: ubuntu

  
The following steps should be followed on newer board for one time.
 
Host : Ubuntu 
Copying files through the SD card into the board


Step - 1: Download the Release folder through the Released mail & copy the “Release” directory in the “Desktop” directory of your Ubuntu PC.

Step - 2: Connect the SD card in the Linux Ubuntu PC, then it will be detected as below the following image. In the Left side of below Image, “16GB volume” name will appears & click the option.
Note: Our SD card size is 16GB, this name will change depends on your SD card

 
Step - 3: In the above image window, click Right side of mouse and selects the “Open in terminal” and it displays the below screen.




 

Step - 4: Once the Step 3 image screenshot image appears, then run the below following commands. 

$ sudo cp -r ~/Desktop/Release .

$ sync

  Step - 5: Remove the SD card & connect in to the board & Power on the board.

Verification:

        1. Following screenshot will shows how to run the commands in the PC.

  
        2. Follow the Step & This screenshot should verify the “Release” directory is successfully copied into the SD card.






Host : Ubuntu 
Copying files through the ethernet into the board

Step 1:  From the Host PC, Press the Right click button in the mouse to select “Open a new terminal”  & it shows the command line interface in the host side.

Step 2:  The below following command to install the packages for copying files to the board through the ethernet.
$ sudo apt-get install openssh-server

      Step 3:  The following command to connecting the board through the Ethernet.

$ ssh ubuntu@192.168.0.130

Note: Please use the Advanced IP scanner application to find the Board IP address

Board login username: ubuntu
Board login Password: ubuntu

     Verification:-

zumi@zumi-Latitude-E7450:~$ ssh ubuntu@192.168.0.130
The authenticity of host '192.168.0.130 (192.168.0.130)' can't be established.
ECDSA key fingerprint is SHA256:ORHYJmrWerjrM0fTw2puKcSKrGo/Cd6ZCX6jCdXbpsI.
Are you sure you want to continue connecting (yes/no)? yes
Failed to add the host to the list of known hosts (/home/zumi/.ssh/known_hosts).
ubuntu@192.168.0.130's password: 
Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.10.72-2.2.0-next+g39d7cfd9350b aarch64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

This system has been minimized by removing packages and content that are
not required on a system that users do not log into.

To restore this content, you can run the 'unminimize' command.
Last login: Thu Dec  7 13:04:15 2023 from 192.168.0.133
ubuntu@picoimx8mm:~$ 


   




Connecting the Board through the Host Windows PC

Step 1: Connect the Ethernet cable to the Board & download the “Advanced IP scanner” application in the Windows PC using the below link & install into the PC.

 https://www.advanced-ip-scanner.com/

Step 2: Open the installed Application “Advanced IP scanner” from the Windows PC to click “scan” to get the board IP address such a below screenshot.


Step 3: Download the “Putty” application in the Windows PC using the below link & install into the PC.

https://www.putty.org/

Step 4: Open the “Putty” application & below the following steps should be followed.

    • Follow the Step7 & copy the IP address in the “Putty” application window like the below screenshot



    • After the above step click “Open” in the window & it goes to new window with “Username” & “Password”

Login :      ubuntu
Password : ubuntu


    •  Once the login completed, new window will be opened like the below screenshot.




Note : The below command should be run in the “Putty” application.
$sudo -s 
Password: ubuntu
Step - 5: Remove the display manager service by running the below command.
$ rm /lib/systemd/system/gdm.service

Step - 6: Install the following packages by running the below command.
$ apt-get update

$ apt-get install ifupdown libqmi-utils

Note: If you run the above two commands, the following below log appears, then please follow the below steps & resolve the issue to run the above two command successfully.

Log:-
root@picoimx8mm:/media/Release# sudo apt-get install ifupdown libqmi-utils
E: Could not get lock /var/lib/dpkg/lock-frontend. It is held by process 19547 (unattended-upgr)
N: Be aware that removing the lock file is not a solution and may break your system.
E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?
The below following steps to resolve the above issue

    • Run the below commands
$ rm /var/lib/dpkg/lock-frontend
$ dpkg --configure -a        
Step - 12: Insert SD card in your pico board & mount the device path in the /media directory

$ mount /dev/mmcblk1p1 /media/                        
       
             Step - 13: Copy the device tree, codec driver, codec configuration file & kernel Image files to the emmc boot file pat.
$ mount /dev/mmcblk2p1 /mnt/

$ cd /media/Release

$ cp Image /mnt/

$ cp imx8mm-pico-pi.dtb /mnt/

$ cp * /home/ubuntu/

$ cp wwan* /etc/network/interfaces.d/

$ sync


Step - 14: Once the above following steps are completed, then please Power OFF & Power ON the
board.






==============================

gpio



 
    1. GPIOs


Validating GPIOs Pins. LED will be turn ON and OFF based Enable and Disable the GPIOs
            

gpio blocks

ls /sys/class/gpio


cat /sys/kernal/debug/gpio




root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# 
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# 
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# 
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# ls /sys/class/gpio
export  gpiochip451  unexport
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# ls /sys/class/gpio/gpiochip451
base  device  label  ngpio  power  subsystem  uevent
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# cat b
cat: b: No such file or directory
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# cat base 
451
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# gpio
gpiodetect  gpiofind    gpioget     gpioinfo    gpiomon     gpioset     
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# gpio
gpiodetect  gpiofind    gpioget     gpioinfo    gpiomon     gpioset     
root@zumi-hp-z800-workstation:/sys/class/gpio/gpiochip451# gpioinfo 
gpiochip0 - 61 lines:
	line   0:      unnamed       unused   input  active-high 
	line   1:      unnamed       unused   input  active-high 
	line   2:      unnamed       unused  output  active-high 
	line   3:      unnamed       unused  output  active-high 
	line   4:      unnamed       unused  output  active-high 





DVR_PWR_ON - (P1)

Step -1 : To export the pin.

$ echo 80 > /sys/class/gpio/export

Step - 2: GPIO output

$ echo out > /sys/class/gpio/gpio80/direction

Step -3 : To enable the pin Low

$ echo 1 > /sys/class/gpio/gpio80/value

Step -4 : To enable the pin High

$ echo 0 > /sys/class/gpio/gpio80/value





   CAM1_4_PWR_ON- (P2, P6)

Step -1 : To export the pin.

$ echo 70 > /sys/class/gpio/export

Step - 2: GPIO output

$ echo out > /sys/class/gpio/gpio70/direction

Step -3 : To enable the pin low

$ echo 1 > /sys/class/gpio/gpio70/value

Step -4 : To enable the pin high

$ echo 0 > /sys/class/gpio/gpio70/value


SEN_PWR_ON - (P5)

Step -1 : To export the pin.

$ echo 73 > /sys/class/gpio/export

Step - 2: GPIO output

$ echo out > /sys/class/gpio/gpio73/direction

Step -3 : To enable the pin low

$ echo 1 > /sys/class/gpio/gpio73/value

Step -4 : To enable the pin high

$ echo 0 > /sys/class/gpio/gpio73/value






FAN_PWR_ON – (P3)

Step -1 : To export the pin.

$ echo 132 > /sys/class/gpio/export

Step - 2: GPIO output

$ echo out > /sys/class/gpio/gpio132/direction

Step -3 : To enable the pin low

$ echo 1 > /sys/class/gpio/gpio132/value

Step -4 : To enable the pin high

$ echo 0 > /sys/class/gpio/gpio132/value



LIGHT_PWR_ON (P4)

Step -1 : To export the pin.

$ echo 71 > /sys/class/gpio/export

Step - 2: GPIO output

$ echo out > /sys/class/gpio/gpio71/direction

Step -3 : To enable the pin low

$ echo 1 > /sys/class/gpio/gpio71/value

Step -4 : To enable the pin high

$ echo 0 > /sys/class/gpio/gpio71/value


 
    2. Audio Codec
 	 

Step - 1: Run the following command to load the codec driver

$ cd /home/ubuntu/

$ sh CodecSetting.sh

Step - 2: If you want any other audio file, then download the audio file .wav or .mp3 & copy in your SD card.

$ sh audioplayback.sh

$ aplay 44100_16_st.wav

          

 Verification: -

root@picoimx8mm:/home/ubuntu# sh audioplayback.sh Simple mixer control 'HP Left',0
Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [off]

Simple mixer control 'HP Right',0 Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [on]

Simple mixer control 'HP Driver',0 Capabilities: pvolume pswitch
Playback channels: Front Left - Front Right Limits: Playback 0 - 9
Mono:

Front Left: Playback 0 [0%] [0.00dB] [on] Front Right: Playback 0 [0%] [0.00dB] [on] Simple mixer control 'HP Analog',0 Capabilities: pvolume
Playback channels: Front Left - Front Right Limits: Playback 0 - 127
Mono:

Front Left: Playback 100 [79%] [-13.50dB]

Front Right: Playback 100 [79%] [-13.50dB] Simple mixer control 'Speaker',0
Capabilities: pswitch pswitch-joined

Playback channels: Mono Mono: Playback [off]
Simple mixer control 'Speaker Driver',0

Capabilities: pvolume pvolume-joined pswitch pswitch-joined Playback channels: Mono
Limits: Playback 0 - 3

Mono: Playback 0 [0%] [6.00dB] [off]

Simple mixer control 'Output Left From Left DAC',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [on]
Simple mixer control 'Output Right From Right DAC',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [on]
Simple mixer control 'Speaker Analog',0 Capabilities: pvolume pvolume-joined Playback channels: Mono
Limits: Playback 0 - 127

Mono: Playback 120 [94%] [-3.50dB] Simple mixer control 'DAC',0 Capabilities: pvolume
Playback channels: Front Left - Front Right Limits: Playback 0 - 175
Mono:

Front Left: Playback 150 [86%] [11.50dB]

Front Right: Playback 150 [86%] [11.50dB] root@picoimx8mm:/home/ubuntu# root@picoimx8mm:/home/ubuntu# aplay 44100_16_st.wav
Playing WAVE '44100_16_st.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo



Step - 3: If you want to record the audio file, then run the below following commands .

$ sh audiocapture.sh

$ arecord -f S16_LE -c2 -r44100 -d20 test.wav


Step - 4: If you want to playing the recorded audio file, then run the below following commands.

$ sh audioplayback.sh

$ aplay test.wav



Verification

root@picoimx8mm:/home/ubuntu# sh audiocapture.sh numid=2,iface=MIXER,name='ADC Capture Switch'
; type=BOOLEAN,access=rw	,values=1

: values=on

Simple mixer control 'ADC',0

Capabilities: cvolume cvolume-joined cswitch cswitch-joined Capture channels: Mono
Limits: Capture 0 - 64

Mono: Capture 64 [100%] [12.00dB] [on] Simple mixer control 'Mic PGA',0 Capabilities: cvolume cvolume-joined Capture channels: Mono

Limits: Capture 0 - 119

Mono: Capture 80 [67%] [40.00dB]

Simple mixer control 'Output Left From MIC1LP',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [off]
Simple mixer control 'Output Left From MIC1RP',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [off]
Simple mixer control 'Output Right From MIC1RP',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [off]
Simple mixer control 'MIC1LP P-Terminal',0 Capabilities: enum
Items: 'Off' 'FFR 10 Ohm' 'FFR 20 Ohm' 'FFR 40 Ohm'
Item0: 'FFR 10 Ohm' Simple mixer control 'DAC',0 Capabilities: pvolume
Playback channels: Front Left - Front Right Limits: Playback 0 - 175
Mono:

Front Left: Playback 0 [0%] [-63.50dB]

Front Right: Playback 0 [0%] [-63.50dB] Simple mixer control 'Speaker Analog',0

Capabilities: pvolume pvolume-joined Playback channels: Mono
Limits: Playback 0 - 127

Mono: Playback 0 [0%] [-63.50dB] Simple mixer control 'HP Analog',0 Capabilities: pvolume
Playback channels: Front Left - Front Right Limits: Playback 0 - 127
Mono:

Front Left: Playback 0 [0%] [-63.50dB]

Front Right: Playback 0 [0%] [-63.50dB] Simple mixer control 'HP Left',0 Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [off]

Simple mixer control 'HP Right',0 Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [off]

Simple mixer control 'HP Driver',0 Capabilities: pvolume pswitch
Playback channels: Front Left - Front Right Limits: Playback 0 - 9
Mono:

Front Left: Playback 0 [0%] [0.00dB] [off] Front Right: Playback 0 [0%] [0.00dB] [off]

Simple mixer control 'Output Left From Left DAC',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [off]
Simple mixer control 'Output Right From Right DAC',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [off]
root@picoimx8mm:/home/ubuntu# arecord -f S16_LE -c2 -r44100 -d20 test.wav Recording WAVE 'test.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo root@picoimx8mm:/home/ubuntu#
root@picoimx8mm:/home/ubuntu# sh audioplayback.sh Simple mixer control 'HP Left',0
Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [off]

Simple mixer control 'HP Right',0 Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [on]

Simple mixer control 'HP Driver',0 Capabilities: pvolume pswitch
Playback channels: Front Left - Front Right Limits: Playback 0 - 9
Mono:

Front Left: Playback 0 [0%] [0.00dB] [on]

Front Right: Playback 0 [0%] [0.00dB] [on] Simple mixer control 'HP Analog',0 Capabilities: pvolume
Playback channels: Front Left - Front Right Limits: Playback 0 - 127
Mono:

Front Left: Playback 100 [79%] [-13.50dB]

Front Right: Playback 100 [79%] [-13.50dB] Simple mixer control 'Speaker',0
Capabilities: pswitch pswitch-joined Playback channels: Mono
Mono: Playback [off]

Simple mixer control 'Speaker Driver',0

Capabilities: pvolume pvolume-joined pswitch pswitch-joined Playback channels: Mono
Limits: Playback 0 - 3

Mono: Playback 0 [0%] [6.00dB] [off]

Simple mixer control 'Output Left From Left DAC',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [on]
Simple mixer control 'Output Right From Right DAC',0 Capabilities: pswitch pswitch-joined
Playback channels: Mono Mono: Playback [on]
Simple mixer control 'Speaker Analog',0

Capabilities: pvolume pvolume-joined Playback channels: Mono
Limits: Playback 0 - 127

Mono: Playback 120 [94%] [-3.50dB] Simple mixer control 'DAC',0 Capabilities: pvolume
Playback channels: Front Left - Front Right Limits: Playback 0 - 175
Mono:

Front Left: Playback 150 [86%] [11.50dB]

Front Right: Playback 150 [86%] [11.50dB] root@picoimx8mm:/home/ubuntu# aplay test.wav
Playing WAVE 'test.wav' : Signed 16 bit Little Endian, Rate 44100 Hz, Stereo root@picoimx8mm:/home/ubuntu# 
    3. SD CARD

Step - 1: Connect the SD card to the board & following commands to mount the device.

$ mount /dev/mmcblk1p1 /media

$ cd /media

Step - 2: Writing a file into the SD card.

$ echo hi > test.txt

Step - 3: Reading a file from the SD card

$ cat test.txt

Note : “hi” data should be present in the file


             

Verification:

root@picoimx8mm:/media# cat test.txt hi
root@picoimx8mm:/media#



 

    4. Ethernet
 
 	Once you connect the ethernet cable to the board then follow the steps,

Step - 1: check the configuration.

$ ifconfig

Verification:

root@picoimx8mm:/media# ifconfig

eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500

inet 192.168.0.101 netmask 255.255.255.0 broadcast 192.168.0.255 inet6 fe80::31d7:e7e7:5fc6:3f6b prefixlen 64 scopeid 0x20<link> ether 00:1f:7b:1e:30:3b txqueuelen 1000 (Ethernet)
RX packets 1199 bytes 123565 (123.5 KB)

RX errors 0 dropped 0  overruns 0 frame 0

TX packets 49 bytes 6044 (6.0 KB)

TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0

Step - 2: Check network is working or not.

$ ping -I eth0 www.google.com

Verification:

root@picoimx8mm:/media# ping -I eth0 www.google.com

PING www.google.com (142.250.193.132) 56(84) bytes of data.

64 bytes from maa05s25-in-f4.1e100.net (142.250.193.132): icmp_seq=1 ttl=57 time=7.73 ms
64 bytes from maa05s25-in-f4.1e100.net (142.250.193.132): icmp_seq=2 ttl=57 time=7.79 ms
64 bytes from maa05s25-in-f4.1e100.net (142.250.193.132): icmp_seq=3 ttl=57 time=7.75 ms
3 packets transmitted, 3 received, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 7.733/7.757/7.793/0.025 ms
 
    5. GSM

         Step - 1: The following command to port 1 ON/OFF the GSM module                
         
         Port 1 GSM module - ON
                 
                $ sh GSM_ON.sh

            Note:(First,the gpio pin number 64 to give high and after 11s the gpio pin number 64   should give low.    Now,  port 1 GSM module is ON)
                       
       Port 1 GSM module - OFF

               $ sh GSM_OFF.sh   
            
        Note:(First,the gpio pin number 64 to give high and after 5 sec the gpio pin number should give low and to take 18s for  port 1 GSM module  is  OFF condition)
       
          
       Step - 2: The following command to port 2 ON/OFF the GSM module         
        
            Port 2 GSM module – ON

                 $ sh GSM_ON.sh
      
        Note:(First,the gpio pin number 65 to give high and after 11sec the gpio pin number 65   should give low.      Now,port 2 GSM module is ON)
             
          Port 2 GSM module – OFF

               $ sh GSM_OFF.sh   

       Note:(First,the gpio pin number 65 to give high and after 5 sec the gpio pin number  65 should give low and to take 18s for  port 2 GSM module  is  OFF condition)

             Step -3: The following command to detect the both GSM module
                    
$ cd /home/ubuntu
$ sh modemSetting.sh

            Step - 4 : To verify the USB port 1 GSM module connected or unconnected

$ dmesg | grep 1-1.1

Verification of GSM port1 connected:

root@picoimx8mm:/home/ubuntu# dmesg | grep 1-1.1
[    2.556818] hub 1-1:1.0: USB hub found
[    2.560789] hub 1-1:1.0: 4 ports detected
[    2.882404] usb 1-1.1: new high-speed USB device number 3 using ci_hdrc
[  596.600719] option 1-1.1:1.0: GSM modem (1-port) converter detected
[  596.601086] usb 1-1.1: GSM modem (1-port) converter now attached to ttyUSB1
[  596.603445] option 1-1.1:1.1: GSM modem (1-port) converter detected
[  596.607626] usb 1-1.1: GSM modem (1-port) converter now attached to ttyUSB2
[  596.610149] option 1-1.1:1.2: GSM modem (1-port) converter detected
[  596.610624] usb 1-1.1: GSM modem (1-port) converter now attached to ttyUSB3
[  596.612954] option 1-1.1:1.3: GSM modem (1-port) converter detected
[  596.618944] usb 1-1.1: GSM modem (1-port) converter now attached to ttyUSB4
[  596.621262] option 1-1.1:1.4: GSM modem (1-port) converter detected
[  596.621902] usb 1-1.1: GSM modem (1-port) converter now attached to ttyUSB5


Step -5 : To verify the USB port 2 GSM module connected or unconnected

$ dmesg | grep 1-1.2

Verification of GSM port 2 connected:

root@picoimx8mm:/home/ubuntu/Release# dmesg | grep 1-1.2
[    3.094133] usb 1-1.2: new high-speed USB device number 4 using ci_hdrc
[  596.624391] option 1-1.2:1.0: GSM modem (1-port) converter detected
[  596.625010] usb 1-1.2: GSM modem (1-port) converter now attached to ttyUSB6
[  596.627411] option 1-1.2:1.1: GSM modem (1-port) converter detected
[  596.628010] usb 1-1.2: GSM modem (1-port) converter now attached to ttyUSB7
[  596.629299] option 1-1.2:1.2: GSM modem (1-port) converter detected
[  596.630705] usb 1-1.2: GSM modem (1-port) converter now attached to ttyUSB8
[  596.630988] option 1-1.2:1.3: GSM modem (1-port) converter detected
[  596.632556] usb 1-1.2: GSM modem (1-port) converter now attached to ttyUSB9
[  596.632827] option 1-1.2:1.4: GSM modem (1-port) converter detected
[  596.634171] usb 1-1.2: GSM modem (1-port) converter now attached to ttyUSB10

            Step -6: The following command to run the at command test file for connecting and disconnecting the call.

    • If you want to test the Port 1 GSM module, then you should run the below command.


root@picoimx8mm:/home/ubuntu# ./attest /dev/ttyUSB3
argv:/dev/ttyUSB3

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 1

Wait for receive a call

1. Wait for call
2. Goto menu
Select an option: 1
Incoming call alert
AT Command Response: 
RING

RING response successfull
Do you want to accept the call? (yes/no): yes
Call accepted.

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 3
Ending the call

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 2
Enter the number: 9003537621

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 3
Ending the call

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 4
root@picoimx8mm:/home/ubuntu# 




    • If you want to test the Port 2 GSM module, then you should run the below command.

root@picoimx8mm:/home/ubuntu# ./attest /dev/ttyUSB8
argv:/dev/ttyUSB8

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 1

Wait for receive a call

1. Wait for call
2. Goto menu
Select an option: 1
Incoming call alert
AT Command Response: 
RING

RING response successfull
Do you want to accept the call? (yes/no): yes
Call accepted.

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 3
Ending the call





Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 2
Enter the number: 9003537621

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 3
Ending the call

Main menu : 
1. incoming call
2. Connect a call
3. End a Call
4. Close the application
Select an option: 4
root@picoimx8mm:/home/ubuntu# 






Note: Configure your APN settings by replacing the highlighted one in the below steps.

Step -7: The following command to replace your APN settings based on your network.

         
Port 1 GSM:-

$ cat /etc/network/interfaces.d/wwan0

iface wwan0 inet manual
     pre-up systemctl stop ModemManager   
     pre-up ifconfig wwan0 down
     pre-up echo Y > /sys/class/net/wwan0/qmi/raw_ip
     pre-up for _ in $(seq 1 10); do /usr/bin/test -c /dev/cdc-wdm0 && break; /bin/sleep 1; done
     pre-up for _ in $(seq 1 10); do /usr/bin/qmicli -d /dev/cdc-wdm0 --nas-get-signal-strength && break; /bin/sleep 1; done
     pre-up sudo qmicli -p -d /dev/cdc-wdm0 --device-open-net='net-raw-ip|net-no-qos-header' --wds-start-network="apn='airtelgprs.com',ip-type=4" --client-no-release-cid
     pre-up udhcpc -i wwan0
     post-down /usr/bin/qmi-network /dev/cdc-wdm0 stop


    • Edit the file by using the below command.

$ vi /etc/network/interfaces.d/wwan0

    • Editing the file by pressing the “i” in the keyboard to change your APN name in the above highlighted word  to save the file using the command “:wq!” 

Port 2 GSM:-

$ cat /etc/network/interfaces.d/wwan1

iface wwan1 inet manual
     pre-up systemctl stop ModemManager   
     pre-up ifconfig wwan1 down
     pre-up echo Y > /sys/class/net/wwan1/qmi/raw_ip
     pre-up for _ in $(seq 1 10); do /usr/bin/test -c /dev/cdc-wdm1 && break; /bin/sleep 1; done
     pre-up for _ in $(seq 1 10); do /usr/bin/qmicli -d /dev/cdc-wdm1 --nas-get-signal-strength && break; /bin/sleep 1; done
     pre-up sudo qmicli -p -d /dev/cdc-wdm1 --device-open-net='net-raw-ip|net-no-qos-header' --wds-start-network="apn='airtelgprs.com',ip-type=4" --client-no-release-cid
     pre-up udhcpc -i wwan0
     post-down /usr/bin/qmi-network /dev/cdc-wdm1 stop


    • Edit the file by using the below command.

$ vi /etc/network/interfaces.d/wwan1

    • Editing the file by pressing the “i” in the keyboard to change your APN name in the above highlighted word  to save the file using the command “:wq!” 



Verification:-
$ cat /etc/network/interfaces.d/wwan0

iface wwan0 inet manual
     pre-up systemctl stop ModemManager   
     pre-up ifconfig wwan0 down
     pre-up echo Y > /sys/class/net/wwan0/qmi/raw_ip
     pre-up for _ in $(seq 1 10); do /usr/bin/test -c /dev/cdc-wdm0 && break; /bin/sleep 1; done
     pre-up for _ in $(seq 1 10); do /usr/bin/qmicli -d /dev/cdc-wdm0 --nas-get-signal-strength && break; /bin/sleep 1; done
     pre-up sudo qmicli -p -d /dev/cdc-wdm0 --device-open-net='net-raw-ip|net-no-qos-header' --wds-start-network="apn='airtelgprs.com',ip-type=4" --client-no-release-cid
     pre-up udhcpc -i wwan0
     post-down /usr/bin/qmi-network /dev/cdc-wdm0 stop


$ cat /etc/network/interfaces.d/wwan1

iface wwan1 inet manual
     pre-up systemctl stop ModemManager   
     pre-up ifconfig wwan1 down
     pre-up echo Y > /sys/class/net/wwan1/qmi/raw_ip
     pre-up for _ in $(seq 1 10); do /usr/bin/test -c /dev/cdc-wdm1 && break; /bin/sleep 1; done
     pre-up for _ in $(seq 1 10); do /usr/bin/qmicli -d /dev/cdc-wdm1 --nas-get-signal-strength && break; /bin/sleep 1; done
     pre-up sudo qmicli -p -d /dev/cdc-wdm1 --device-open-net='net-raw-ip|net-no-qos-header' --wds-start-network="apn='airtelgprs.com',ip-type=4" --client-no-release-cid
     pre-up udhcpc -i wwan0
     post-down /usr/bin/qmi-network /dev/cdc-wdm1 stop

      



Step -8: The following command to run the gprs test in the both module

    • If you want to test the Port 1 GSM module, then you should run the below command.

$ ifup wwan0

$ ping -I wwan0 www.google.com -c 5


    • If you want to test the Port 2 GSM module, then you should run the below command.

$ ifup wwan1

$ ping -I wwan1 www.google.com -c 5

           

Verification:
                           
                         Port 1 GSM:-
                          root@picoimx8mm:/home/ubuntu# ifup wwan0
[/dev/cdc-wdm0] Successfully got signal strength
Current:
        Network 'lte': '-78 dBm'
RSSI:
        Network 'lte': '-78 dBm'
ECIO:
        Network 'lte': '-2.5 dBm'
IO: '-106 dBm'
SINR (8): '9.0 dB'
RSRQ:
        Network 'lte': '-14 dB'
SNR:
        Network 'lte': '3.6 dB'
RSRP:
        Network 'lte': '-114 dBm'
[/dev/cdc-wdm0] Network started
        Packet data handle: '2264352016'
[/dev/cdc-wdm0] Client ID not released:
        Service: 'wds'
            CID: '18'
udhcpc: started, v1.30.1
udhcpc: sending discover
udhcpc: sending select for 100.96.66.6
udhcpc: lease of 100.96.66.6 obtained, lease time 7200
root@picoimx8mm:/home/ubuntu#
root@picoimx8mm:/home/ubuntu# ping -I wwan0 www.google.com -c 5
PING  (142.250.67.36) from 100.96.66.6 wwan0: 56(84) bytes of data.
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=1 ttl=58 time=152 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=2 ttl=58 time=94.7 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=3 ttl=58 time=99.9 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=4 ttl=58 time=75.9 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=5 ttl=58 time=88.6 ms

---  ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4005ms
rtt min/avg/max/mdev = 75.894/102.220/151.964/26.133 ms

Port2 GSM:-
root@picoimx8mm:/home/ubuntu# ifup wwan1
[/dev/cdc-wdm1] Successfully got signal strength
Current:
        Network 'lte': '-83 dBm'
RSSI:
        Network 'lte': '-83 dBm'
ECIO:
        Network 'lte': '-2.5 dBm'
IO: '-106 dBm'
SINR (8): '9.0 dB'
RSRQ:
        Network 'lte': '-12 dB'
SNR:
        Network 'lte': '5.0 dB'
RSRP:
        Network 'lte': '-108 dBm'
[/dev/cdc-wdm1] Network started
        Packet data handle: '2264482304'
[/dev/cdc-wdm1] Client ID not released:
        Service: 'wds'
            CID: '18'
udhcpc: started, v1.30.1
udhcpc: sending discover
udhcpc: sending select for 100.81.227.96
udhcpc: lease of 100.81.227.96 obtained, lease time 7200
root@picoimx8mm:/home/ubuntu# 
root@picoimx8mm:/home/ubuntu# ping -I wwan1 www.google.com -c 5
PING  (142.250.67.36) from 100.81.227.96 wwan1: 56(84) bytes of data.
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=1 ttl=58 time=120 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=2 ttl=58 time=79.2 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=3 ttl=58 time=62.8 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=4 ttl=58 time=75.7 ms
64 bytes from maa05s12-in-f4.1e100.net (142.250.67.36): icmp_seq=5 ttl=58 time=94.7 ms

---  ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4006ms
rtt min/avg/max/mdev = 62.839/86.509/120.112/19.621 ms


 

    6. USB
 
Step - 1: Connect the USB pen drive to the board.

Step - 2: To verify the USB device connected or unconnected.

$ dmesg

Verification of USB port connected:

[ 673.498536] usb 1-1.3: new high-speed USB device number 5 using ci_hdrc [ 673.615486] usb-storage 1-1.3:1.0: USB Mass Storage device detected
[ 673.617455] scsi host0: usb-storage 1-1.3:1.0

[ 674.632634] scsi 0:0:0:0: Direct-Access	Generic Flash Disk	8.07 PQ: 0 ANSI: 4

[ 674.634490] sd 0:0:0:0: [sda] 62914560 512-byte logical blocks: (32.2 GB/30.0 GiB) [ 674.636159] sd 0:0:0:0: [sda] Write Protect is off
[ 674.636169] sd 0:0:0:0: [sda] Mode Sense: 23 00 00 00

[ 674.637119] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
[ 674.673508]  sda:

[ 674.677104] sd 0:0:0:0: [sda] Attached SCSI removable disk



7.	RS485
 
Step - 1: Connect the USB to RS485 connector between the board & PC.

Step - 2: To verify the RS485 USB port name which is connected to the Board.

$ dmesg | grep ttyUSB0

Verification of USB port whether connected in to the Board:

[	2.922816] usb 1-1.4: FTDI USB Serial Device converter now attached to ttyUSB0

Step - 3: To verify the USB port name which is connected to the PC.

    • Go to DeviceManager->Ports(COM & LPT)->USB-SERIAL CH340 (COM4)



Step - 4: In the Debug port terminal, Run the following commands to run the RS 485 test application.

Board Window

$ cd /home/ubuntu

$ ./rs485test

Enter the tty deiver to select

ttyUSB0	-> Type manually

|****BAUDRATE SELECT MENU****| 1)Baud Rate: 2400
        2) Baud Rate: 4800

        3) Baud Rate: 9600

        4) Baud Rate: 115200

        5) Baud Rate: 460800

115200	-> Type manually

open /dev/ttyUSB0 successfully! Set /dev/ttyUSB0 successfully! Baud rate: 115200
1. Write 2. Read 3. Exit


Steps to open the PC window:
    • Download & Install the  “teraterm” application in the PC & Open the application to set the serial port configuration.
    • In the teraterm application, Click  “File” option & select “new connection” 

    • In the above window, click “OK” & then select the “Setup” option to click the “Serial Port” & Changed the Speed to 115200. Once it is selected and choose “New setting” to close the window.






    • In the teraterm application, Click the “Setup” & select the “Terminal” to choose the option to enable  “Local echo” looks like the below screenshot.


    • Your PC window looks like the below screenshot


If you want to send the data from the board to the PC

Board Window:

1. Write 2. Read 3. Exit

1	=> Type manually

Enter the Data:

hello	=> Type manually

Write data: hello	=> This data will send to the PC RS485 end. Close
1. Write 2. Read 3. Exit
                      PC Window:
    • “hello” will be displayed in the PC window by the below following screenshot.



If you want to send the data from PC to the Board.

Board Window:

1. Write 2. Read 3. Exit

2	=> Type manually

Enter the 5 characters in another terminal end

< Wait for the data from the PC window > Read data from the PC:world
1. Write 2. Read 3. Exit


PC Window:

    • Before entering the word, Go to “Edit” and select “Clear Buffer” to do the belw steps.
    • Type five letters in the terminal like “world” in the below screenshot

                        
Verification :- Board Window:-
root@picoimx8mm:/home/ubuntu# ./rs485test Enter the tty deiver to select
ttyUSB0

|****BAUDRATE SELECT MENU****| 1)Baud Rate: 2400
    2) Baud Rate: 4800

    3) Baud Rate: 9600

    4) Baud Rate: 115200

    5) Baud Rate: 460800

115200

open /dev/ttyUSB0 successfully! Set /dev/ttyUSB0 successfully! Baud rate: 115200

    1. Write 2. Read 3. Exit 
                                                                                                                                                                         /* Send data to the PC */
1
Enter the Data:

hello

Write data: hello Close
    1. Write 2. Read 3. Exit
               /* Receive data from the PC */
 2
Enter the 5 characters in another terminal end Read data from the PC: world
1. Write 2. Read 3. Exit

PC Window:-
                               /* Receive data from the Board */

               /* Send data from the PC */




    7. UART
 
             Step - 1: The following command to test the UART port.

$ cd /home/ubuntu
$ ./uarttest /dev/ttymxc2
Enter a data in the UART port: hello

                         Loopback Test (/dev/ttymxc2): Bytes Written: 5, Write Success
                         Loopback Test (/dev/ttymxc2): Bytes Read: 5, Read Success
                         Loopback Test: Bytes Received: hello

            Step - 2: To verify the UART test port is working or not.

    • It shows the expected data received, then it is considered as testing PASS.
    • It shows the expected data not received, then it is considered as testing FAIL.

               Verification:-


-------------------------------------------------------------------------------------
                   
2.me


=========================================================================================================================
                                                             IMX8MM
========================================================================================================================

imx pre-build
============================================

                Boot Configurations of PICO-PI-IMX8M-MINI


1. packeage download link
Download the UUU tool from our website:
https://download.technexion.com/development_resources/development_tools/installer/imx-mfg-uuu-tool_20210421.zip
Then extract a ZIP file named "imx-mfg-uuu-tool_20210421.zip" and make changes to the extracted contents. 

Download the rescue file (only a test code.Its not an image)
https://download.technexion.com/rescue/pico-imx8mm/pi-dsi1280x720/rescue.xz
       
Then extract a ZIP file named "rescue.xz" and make changes to the extracted contents. 
2.download the Ubuntu OS
For pico-imx8mq board Download the image file of your 

1.choice from
Index of /rescue/ (technexion.com)

 

2.choice from
pico-imx8mq/  



3.choice from
pi-dsi1280x720/ 

Choose the image (we used ubuntu20.04.xz)
                                 /   xz -d filename.xz    /
 

3.Extract the files ubuntu20.04.xz and rescue.xz located inside the folder /Home/imx-mfg-uuu-tool_20210421/imx-mfg-uuu-tool 


Example command
sudo ./uuu/linux64/uuu -b emmc_img imx8mm/pico-imx8mm/pico-imx8mm-flash.bin <path/to/rescue>

Finel working command 
 sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin ubuntu-20.04

=======================================================


imx8mm build 

==============================================================================

                        1.Image Build  Procedure:

     

       1.More details  To refer the link otherwise flow the blow steps ;
             
            https://github.com/TechNexion/tn-imx-yocto-manifest

Install required packages
    • Update the host package list
                 $: sudo apt-get update					


Install required packages
$: sudo apt-get install gawk wget git git-core diffstat unzip texinfo gcc-multilib build-essential \
chrpath socat cpio python python3 python3-pip python3-pexpect \
python3-git python3-jinja2 libegl1-mesa pylint3 rsync bc bison \
xz-utils debianutils iputils-ping libsdl1.2-dev xterm \
language-pack-en coreutils texi2html file docbook-utils \
python-pysqlite2 help2man desktop-file-utils \
libgl1-mesa-dev libglu1-mesa-dev mercurial autoconf automake \
groff curl lzop asciidoc u-boot-tools libreoffice-writer \
sshpass ssh-askpass zip xz-utils zstd liblz4-tool kpartx vim screen

									
Install the repo tool
    • There are many respositories required. Google’s repo tool is used to manage this.
$: mkdir ~/bin
$: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo
$: chmod a+x ~/bin/repo
$: PATH=${PATH}:~/bin
Download the BSP source
    • Create the work directory
$: mkdir edm_yocto
$: cd edm_yocto
Initialize the repositories based on the release you wish to build:
$: repo init -u https://github.com/TechNexion/tn-imx-yocto-manifest.git -b kirkstone_5.15.y-stable -m imx-5.15.71-2.2.0.xml
Start to fetch source code
$: repo sync -j8
NOTE!
In case we encounter any warnings or errors in a lower version, you should download the updated version of the source code
LIKE this you get warnings
... A new version of repo (2.36) is available. ... You should upgrade soon:
solutions; 
         $;   sudo apt install repo


For PICO-IMX8MM
    • Ubuntu Gnome desktop
$: WIFI_FIRMWARE=y DISTRO=imx-desktop-xwayland MACHINE=pico-imx8mm source tn-setup-release.sh -b build-xwayland-pico-imx8mm

$: bitbake imx-image-desktop

  #bitbake -c imx-image-desktop
This is the final command. Afterward, you'll receive the binary image output to use for flashing the image."



                          
                              2 .Image flash Procedure



1.flash Procedure website link :

  https://developer.technexion.com/docs/using-uuu-to-flash-emmc



2. Packeage download link


Download the UUU tool from our website:

https://download.technexion.com/development_resources/development_tools/installer/imx-mfg-uuu-tool_20210421.zip 

Then extract a ZIP file named "imx-mfg-uuu-tool_20210421.zip" and make changes to the extracted contents. 


 
uuu has the ability to decompress Bzip2 (.bz2) compressed files during the flashing process, however an /* but be appended to the image filename. It does not have the ability to parse xzip (.xz) files
Execute uuu to start flashing process.

Example command  For .bz2 compressed images  ;
cd imx-mfg-uuu-tool

sudo ./uuu/linux64/uuu -b emmc_img imx8mm/pico-imx8mm-flash.bin <path-to-image-to-flash>/<image name>.wic.bz2/*
Final working command
sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin ../build-xwayland-pico-imx8mm/tmp/deploy/images/pico-imx8mm/imx-image-desktop-pico-imx8mm.wic.bz2


zumi@zumi:~/edm_yocto/imx-mfg-uuu-tool$ sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin ~/pico/edm_yocto/build-xwayland-pico-imx8mm/tmp/deploy/images/pico-imx8mm/imx-image-full-pico-imx8mm.wic.bz2

sudo ./uuu/linux64/uuu -b emmc_img ./imx8mm/pico-imx8mm/pico-imx8mm-flash.bin /home/zumi/pico/edm_yocto/build/tmp/deploy/images/pico-imx8mm/imx-image-desktop-pico-imx8mm.wic.bz2


-------------------------------------------------------------------------------------
IMX8MM rebuild
=======

WIFI_FIRMWARE=y DISTRO=imx-desktop-xwayland MACHINE=pico-imx8mm source tn-setup-release.sh -b build
bitbake -c clean linux-tn-imx
bitbake -C compile linux-tn-imx
bitbake -c menuconfig virtual/kernel
bitbake virtual/kernel
bitbake imx-image-desktop


----------------------------------------------------------------------------------

GSM

LINK 

https://andino.systems/4g-modem-sim7600/ppp
https://www.toradex.com/blog/how-to-use-gsm-3g-4g-in-embedded-linux-systems
https://firmware2android.wordpress.com/2013/01/07/gprs-connection-using-ppp-daemon-on-arm-linux-using-bluetoothusb-modem/

ppp configration

p=~/pico/edm_yocto/build/tmp/work/pico_imx8mm-fsl-linux/linux-tn-imx/5.10.72+gitAUTOINC+6660a7439a-r0/git/drivers/net/ppp


-----------------
AT


sudo  microcom -s 115200 -p /dev/ttyUSB3


AT+CNUM  //  number

AT+COPS? // network details

chmod +x dialscript connect_script_gsm




sudo apt-get install ppp
sudo vi /etc/ppp/peers/rnet
sudo vi /etc/chatscripts/gprs
sudo pon rnet
tail -n 30 /var/log/syslog
ifconfig
sudo route add default dev ppp0
ping 8.8.8.8
sudo poff rnet



sudo apt-get install modemmanager
sudo mmcli -L



--------------------------------------------------------
gsm 

AT program

arm gcc page link:




https://community.nxp.com/t5/i-MX-Processors-Knowledge-Base/i-MX-8-Hello-World-Linux-ArmV7a-32-bit-and-ArmV8a-64-bit/ta-p/1100128


gcc installtion terminal comment 



$ sudo apt-get install -y gcc-arm-linux-gnueabihf



gcc comment Build each application and use the static option to gcc to include run time libraries.

Build ArmV7a 32-bit application:

$ arm-linux-gnueabihf-gcc -static hello-sizeInt.c -o hello-armv7a‍-static


program



/*************************************************************/
/*  MoTalk - A "C" program for modem setup.                */
/*           This program is meant as an aid only and is   */
/*           not supported by IBM.                       */
/*                  compile:  cc -o motalk motalk.c       */
/*                  Usage:  motalk /dev/tty? [speed]      */
/*************************************************************/
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <termio.h>
FILE *fdr, *fdw;
int fd;
struct termio term_save, stdin_save;
void Exit(int sig)
{
   if (fdr) fclose(fdr);
   if (fdw) fclose(fdw);
   ioctl(fd, TCSETA, &term_save);
   close(fd);
   ioctl(fileno(stdin), TCSETA, &stdin_save);
   exit(sig);
}
main(int argc, char *argv[])
{
   char *b, buffer[80];
   char *atcmd = "AT\r\n";
   int baud=0, num;
   struct termio term, tstdin;
   if (argc < 2 || !strcmp(argv[1], "-?"))
   {
      fprintf(stderr, "Usage: motalk /dev/tty? [speed]\n");
      exit(1);
   }
   if ((fd = open(argv[1], O_RDWR | O_NDELAY)) < 0)
   {
      perror(argv[1]);
      exit(errno);
   }
   if (argc > 2)
   {
      switch(atoi(argv[2]))
      {
         case   300: baud = B300;
                     break;
         case  1200: baud = B1200;
                     break;
         case  2400: baud = B2400;
                     break;
         case  4800: baud = B4800;
                     break;
         case  9600: baud = B9600;
                     break;
         case 19200: baud = B19200;
                     break;
         case 38400: baud = B38400;
                     break;
         case 115200: baud = B115200;
                     break;
         default:    baud = 0;
                     fprintf(stderr, "%s: %s is an unsupported baud\n", argv[0],argv[2]);
                     exit(1);
         }
      }
   /* Save stdin and tty state and trap some signals */
   ioctl(fd, TCGETA, &term_save);
   ioctl(fileno(stdin), TCGETA, &stdin_save);
   signal(SIGHUP, Exit);
   signal(SIGINT, Exit);
   signal(SIGQUIT, Exit);
   signal(SIGTERM, Exit);
   /*  Set stdin to raw mode, no echo */
   ioctl(fileno(stdin), TCGETA, &tstdin);
   tstdin.c_iflag = 0;
   tstdin.c_lflag &= ~(ICANON | ECHO);
   tstdin.c_cc[VMIN] = 0;
   tstdin.c_cc[VTIME] = 0;
   ioctl(fileno(stdin), TCSETA, &tstdin);
   /*  Set tty state */
   ioctl(fd, TCGETA, &term);
   term.c_cflag |= CLOCAL|HUPCL;
   if (baud > 0)
   {
      term.c_cflag &= ~CBAUD;
      term.c_cflag |= baud;
   }
   term.c_lflag &= ~(ICANON | ECHO); /* to force raw mode */
   term.c_iflag &= ~ICRNL; /* to avoid non-needed blank lines */
   term.c_cc[VMIN] = 0;
   term.c_cc[VTIME] = 10;
   ioctl(fd, TCSETA, &term);
   fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NDELAY);
   /*  Open tty for read and write */
   if ((fdr = fopen(argv[1], "r")) == NULL )
   {
      perror(argv[1]);
      exit(errno);
   }
   if ((fdw = fopen(argv[1], "w")) == NULL )
   {
      perror(argv[1]);
      exit(errno);
   }
   /*  Talk to the modem */
   puts("Ready... ^C to exit");
   while (1)
   {
#if 0
      if ((num = read(fileno(stdin), buffer, 80)) > 0)
         write(fileno(fdw), buffer, num);
      if ((num = read(fileno(fdr), buffer, 80)) > 0)
         write(fileno(stdout), buffer, num);
      Exit (0);
#endif

	 printf("Sending %s Command \r\n", atcmd);
         write(fileno(fdw), atcmd, strlen(atcmd));
         read(fileno(fdr), buffer, 80);
	 printf("Received Response = %s \r\n", buffer);
	 sleep(1);

   }
} 

-------------------------------------------------------

imx gsm test


Testing Procedure for GSM Module :

1.GCC download link:

 https://community.nxp.com/t5/i-MX-Processors-Knowledge-Base/i-MX-8-Hello-World-Linux-  ArmV7a-32-bit-and-ArmV8a-64-bit/ta-p/1100128

GCC Installation Terminal Command IN DESKTOP;

$ sudo apt-get install -y gcc-arm-linux-gnueabihf

Desktop are laptop.



1. GCC Program Compilation Command.

      $ arm-linux-gnueabihf-gcc -static file_name.c -o outputfile_name


2. Copy the output file to pendrive using these commands.

      $ cp attest /media/zumi/UBUNTU\ 20_0/atstatic


3.Eject the pendrive from the desktop

      $ umount /media/zumi/UBUNTU\ 20_0 /dev/ttymxc2


pico imx8m bord 



  
 1. Insert the pendrive into the i.MX8M board, then execute these commands.
    
       $ sudo mount -t vfat /dev/sda1 /mnt/

2. Copy the binary file from the pendrive to the Pico i.MX8 board using these commands.
  
       $ cp /mnt/atstatic .

3. Program execute Command :

       $ sudo ./outputfile_name /dev/ttyUSB3 115200

4. Eject the pendrive from the Pico i.MX8M Mini board using these commands

       $ sudo umount /mnt 


--------------------------------------------------------------------------------------------------


ip static to dynamic

ubuntu@picoimx8mm:~$ cd /etc/NetworkManager/system-connections/                                                                                 i
[connection]mx8mm:/etc/NetworkManager/system-connections$ ls                                                                                    o
id=Wired connection 1mconnection'                                                                                                               n
uuid=0a9d987a-f5ac-477d-bdd1-eb9ca8bb6fcetem-connections$ cat Wired\ connection\ 1.nmconnection                                            ucat \
type=ethernetonnection 1.nmconnection': Permission denied scat Wired\ connection\                                                                
interface-name=eth0etc/NetworkManager/system-connections$ cat Wired\ connection\ 1.nmconnection 
permissions=
timestamp=1679940662

[ethernet]
mac-address-blacklist=

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto



------------------------------------------------------------------------------------------------


                         
=========================================================================================================================                         
                         
ssh connecting problem

ssh-keygen -f "/home/zumi/.ssh/known_hosts" -R "192.168.0.125"
                         
                         
                         
=====================================================================================================================                         
                         
                         







wps install
=============
sudo snap install wps-office




















*************************************************************************************************************

xlinix
=============

build processure

Xilinx Zync Ultrascale + MPSOC (3U VPX Modem Card)

                 Image build Flash and boot procedure



Introduction: 
   This article offers comprehensive, step-by-step instructions for constructing a Petalinux image tailored for the Xilinx Zynq Ultrascale+ MPSOC (3U VPX Modem Card) development board. For additional details and reference, you can visit the following website links:
    1. Xilinx Support - Building Petalinux Image for Zynq Ultrascale+ MPSOC
    2. Xilinx Support - Petalinux Workflow and Board Configuration
These resources will guide you through the process, ensuring that you successfully create a customized Petalinux image for your specific hardware configuration.



step 1 : Image build procedure:  (EMMC IMAGE)


System Requirements :

Ubuntu 20.04 Required :-(Note:- Ubuntu verson should not be 20.04.x)                                
********************PetaLinux Building Procedure*************
Step 1:-
Configure tftp server using below link:-https://linuxhint.com/install_tftp_server_ubuntu/
Step 2:-
To create one Directory:-
1)zumi@zumi-H110M-S2:~$ mkdir -p  ADTL
2)zumi@zumi-H110M-S2:~$ cd ADTL


3)zumi@zumi-H110M-S2:~/ADTL$ mkdir -p  Xilinx_zcu102


4)zumi@zumi-H110M-S2:~/ADTL$ cd Xilinx_zcu102



5)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ mkdir -p PetaLinux


    6 zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ sudo chmod -R 755 PetaLinux


7)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ mkdir -p Doc



Step3:-

Note 1:-
To download the (petalinux-v2022.1-04191534-installer.run) tool below link:-https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/2022-1.html
Note 2:-
To copy the petalinux-v2022.1-04191534-installer.run into the  Doc directory:-(this file is there in Download path so, i am going Downloads folder
8)zumi@zumi-H110M-S2:~$ cd Downloads/
9)zumi@zumi-H110M-S2:~/Downloads$ cp petalinux-v2022.1-04191534-installer.run /home/zumi/ADTL/Xilinx_zcu102/Doc
10)zumi@zumi-H110M-S2:~$ cd ADTL/Xilinx_zcu102

11)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ chmod 777 Doc/petalinux-v2022.1-04191534-installer.run 


12)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ sudo chown -R zumi:zumi PetaLinux/

13)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ cd Doc/

14)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/Doc$  sudo apt-get install gawk gcc net-tools xterm autoconf libtool texinfo zlib1g-dev gcc-multilib build-essential zlib1g libncurses5-dev libncursesw5-dev zlib1g:i386 
15)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/Doc$ ./petalinux-v2022.1-04191534-installer.run --dir ../PetaLinux --platform "arm aarch64"

 note :-
             PRESS ENTER
             PRESS q
(again its building)
Do you accept Xilinx End User License Agreement? [y/N] > Y
Do you accept Third Party End User License Agreement? [y/N] > Y


16)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/Doc$ cd ..

17)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$  mkdir -p PetaBSP
 Step 4:-
To Download (bsp) file below link:-
https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/2022-1.html

note:- (2022.1 -->size -->BSP (BSP - 804.98 MB))


18)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$  cp ~/Downloads/xilinx-zcu102-v2022.1-04191534.bsp ~/ADTL/Xilinx_zcu102/PetaBSP/

19)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102$ cd ~/ADTL/Xilinx_zcu102/PetaLinux
20)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux$ sudo dpkg-reconfigure dash 

note:-
(Configuring dash file is open -------> ENTER ---> NO)
Step 5:-
(SET Environmental variable)--->(PetaLinux directory)

21)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux$  source settings.sh 
Step 6:-

(To create a project )

22)zumi@zumi-H110M-S2:~/adtl/Xilinx_zcu102/PetaLinux$ petalinux-create --type project --template zynqMP --name  xilinx-zcu102-2022.1          <----------project name 
26)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux$ cd xilinx-zcu102-2022.1/
NOTE; 
             
Including the XSA file path that is generated into the Vivado tool for FPGA peripheral installation purposes, execute the following commands in the configuration terminal will open. There is no need to make any changes; simply save and exit:

27)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1$ petalinux-config—get-hw-description=/home/zumi/abinash/zcu102/working_image modem_handoff_18092023_0830



28)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1$ petalinux-build

Now create a boot image using the below command to get a .bif format. 
petalinux-package --boot --fsbl --fpga --pmufw --u-boot –force

29)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1$ petalinux-package --boot --fsbl --fpga --pmufw --u-boot –force


30)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/image/linux$  tail -c+73 < boot.scr > boot.txt


31)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/image/linux$ vi boot.txt

Please edit the file as shown in the reference image.


































32).zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/Emmc_image/build/tmp/work/zynqmp_generic-xilinx-linux/u-boot-xlnx/v2021.01-xilinx-v2022.2+gitAUTOINC+b31476685d-r0/recipe-sysroot-native/usr/bin$ mkimage -c none -A arm -T script -d ~/ADTL/Xilinx_zcu102/PetaLinux/Emmc_image/images/linux/boot.txt ~/EMMC/boot.scr


32)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/image/linux$ cp  bootgen.bif adtlboot.bif


33)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/image/linux$ vi adtlboot.bif

34)zumi@zumi-H110M-S2:~$ mkdir EMMC



Please edit the file as shown in the reference image.






34)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/image/linux$ bootgen -image adtlboot.bif -arch zynqmp -w -o /home/zumi/EMMC/BOOT.BIN



"We need two images: one located in the Emmc folder, which is ideal for BOOT.BIN, and another located in /home/alpha/ADTL/Xilinx_zcu102/PetaLinux/Emmc_image/images/linux, which is intended for the FSBL file. We will use these two images for creating BOOT.BIN and zynqmp_fsbl.elf for EMMC boot."
                                                        


  !!*****************************EMMC Build procedure is completed********************************!!



    

step 2 : Image build procedure:  for (QSPI IMAGE)


After completing the configuration steps for EMMC, you can follow the same process for QSPI by adapting the settings accordingly in your project. This will enable you to build the necessary configuration for QSPI boot.



20)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux$ sudo dpkg-reconfigure dash
note:-
(Configuring dash file is open -------> ENTER ---> NO)
Step 5:-

(SET Environmental variable)--->(PetaLinux directory)

21)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux$  source settings.sh 
Step 6:-

(To create a project )

22)zumi@zumi-H110M-S2:~/adtl/Xilinx_zcu102/PetaLinux$ petalinux-create --type project --template zynqMP --name  xilinx-zcu102-2022.1_qspi       ←---------create new project name 
26)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux$ cd xilinx-zcu102-2022.1_qspi/
NOTE; 
             
"Include the XSA file path generated by the Vivado tool for FPGA peripheral installation purposes. Execute the following commands in the configuration terminal to open it. We also need to make similar modifications for QSPI, as shown in the image below."
                                                                          
27)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1_qspi$ petalinux-config—get-hw-description=/home/zumi/abinash/zcu102/working_image modem_handoff_18092023_0830
                                                                    




























NOTE !

“We are seeking the exact configuration values in the following steps. Please refer to the image for better understanding.” 

 "Step 1: Select the following options in the menu:
    1. Subsystem AUTO Hardware Settings
    2. Flash Settings
Finally, make the necessary modifications as needed.

     Please edit the file as shown in the reference image.         




Step 2:  Select the following options in the menu:
1.u-boot Configuration,
2.u-boot script configuration,                                                                  
3.QSPI/OSPI image offsets,
Finally, make the necessary modifications as needed.

  



  Please edit the file as shown in the reference image.       


         

"After saving and exiting, proceed with the following steps:"
                                                                                                                 

NOTE :
Execute the following commands in the configuration terminal to open it. We also need to make similar modifications for QSPI, as shown in the image below."


28)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1_qspi$ petalinux-config -c u-boot


 Step 1: Select the following options in the menu: 
1. ARM architecture,
2. change the boot script offset value
    as shown in the image below."



Please edit the file as shown in the reference image.






"After saving and exiting, proceed with the following steps:"

The QSPI configuration values are as follows:
Step 1:
    • Select the following options in the menu:
        1. Subsystem AUTO Hardware Settings
        2. Flash Settings
    • Finally, make the necessary modifications as needed.
      Configuration values:
        1. qspi_boot = 0x1000000
        2. qspi_bootenv = 0x80000
        3. qspi_kernel = 0x2000000
        4. qspi_bootscr = 0x8000
Step 2:
    • Select the following options in the menu:
        1. u-boot Configuration
        2. u-boot script configuration
        3. QSPI/OSPI image offsets
    • Finally, make the necessary modifications as needed.
      Configuration values:
        1. QSPI_KERNEL_OFFSET = 0x1080000
        2. QSPI_FIT_IMAGE_SIZE = 0x2000000
Step 3:
    • Select the following options in the menu:
        1. ARM architecture
        2. Change the boot script offset value
    • Finally, make the necessary modifications as needed.
      Configuration value:
        1. Boot script offset = 0x3080000





28)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1_qspi$ petalinux-build





29)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1_qspi$ petalinux-package --boot --fsbl --fpga --pmufw --u-boot --force



30)zumi@zumi-H110M-S2:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1_qspi$ petalinux-package --boot --force --format BIN --fsbl --pmufw --u-boot --kernel images/linux/Image --offset 0x1080000 --cpu a53-0 --boot-script --offset 0x3080000 --add images/linux/rootfs.cpio.gz.u-boot --offset 0x4000000 --cpu a53-0 --file-attribute partition_owner=uboot



"After executing these commands, once the final output is obtained and located at /home/alpha/ADTL/Xilinx_zcu102/PetaLinux/Emmc_image/images/linux, we will use these two images to create BOOT.BIN and zynqmp_fsbl.elf for QSPI boot.



 !!*****************************QSPI Build procedure is completed********************************!!






















======================================================================
                                         Install the Xilinx_Unified software 
======================================================================
                                    


Install the Xilinx_Unified software for below link(IDE):-

https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis/2022-1.html 

(download this file version(2022.1) :Xilinx_Unified_2022.1_0420_0327_Lin64.bin )
1)zumi@zumi-H110M-S2:~/Downloads$ chmod 777 Xilinx_Unified_2022.1_0420_0327_Lin64.bin 
2)zumi@zumi-H110M-S2:~/Downloads$ sudo ./Xilinx_Unified_2022.1_0420_0327_Lin64.bin

Note:- 
One page is open you install it







=====================================================================================
                                                             Installation process is complete! 
=====================================================================================









=========================================
                              Image Flash procedure;
=========================================

step 1:

Vitis Application Creation
Purpose & Scope

The purpose of this document is to describe the steps involved in vitis Code build and board quick start process.

This document covers the application creation for different cores, application run over JTAG, program flash and Board setup.














   

  Procedure for flashing ;


1.    Project: Replace 'project' with the name of your project.

2.   Connection: Set it to 'Local.'

3.    Device: The device is automatically detected. If you're using JTAG, it will be
       detected automatically.

4.   Image file: Provide the path to the location where the BOOT.BIN file is located,
      then select that path.

5.   Offset: There's no need to select anything for this option.

6.    Flash type: Choose the memory type you want to flash. If you choose QSPI or
       eMMC, specify the   eMMC partition size as 2048.

7.    Init file: Provide the path to the location where the 'zynqmp_fsbl.elf' file is
       located, and then select that path.

8.    After completing all the above steps, proceed with the programming process."
    
    

Configure boot mode pins,









=============================================================================
                                                         Board Boot Procedure
=============================================================================

"After the flash process is finished, power off the board. Adjust the boot jumpers to select the memory from which you want to boot, and choose the desired boot mode using the boot switch. Apply power to the board, and it will boot into the selected mode.
To configure the board for booting from either QSPI or eMMC and access the terminal, follow these steps:"

We are currently testing a serial port using the software tool Minicom. Minicom is commonly
utilized for such tests and configurations


                    To use Minicom for serial port communication:


Step 1: Install Minicom
    • If Minicom isn't already installed, use your system's package manager to install it.
        ◦ Command: $ sudo apt-get install minicom
Step 2: Identify Your Serial Port
    • Find the serial port your device is connected to, either from documentation or by listing available serial ports.
        ◦ Command: $ ls /dev/ttyUSB
Step 3: Open Minicom Configuration
    • Launch Minicom's configuration mode.
        ◦ Command: $ sudo minicom -s
Step 4: Configure Minicom
    • In the configuration menu, set the serial port settings (path, baud rate, parity, data bits, and flow control options). Save this as the default setup.
Step 5: Access the Terminal
    • After configuring Minicom, reset your device or board to access the terminal for viewing boot logs and interaction.
These steps provide a straightforward guide for setting up and using Minicom for serial communication with your device.

OUTPUT LIKE THIS:

1.EMMC BOOT;


2.QSPI MODE;

--------------------------------------------------------------------------------------


project commant




                                         PETALINUX BUILD PROCEDURE
                                         
                                            11/9/2023
                                            
                                      
                                            
                                            

                     
========================================================================================================================================================================================                     
                     
                     
   alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux$ 
   source settings.sh
   
   alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux$ 
   petalinux-create -t project -n zcu102-test --template zynqMP
   cd zcu102-test
   
   alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux/zcu102-test$
   petalinux-config --get-hw-description=/home/alpha/file
                                         
   alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux/zcu102-test$
   petalinux-config -c u-boot
   
   alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux/zcu102-test$
   petalinux-build
                                         
                                         
                                         
========================================================================================================================================================================================

                                         26/9/2023           
                                         
                                         
                                         



emmc build


sudo dpkg-reconfigure dash 
source settings.sh 
petalinux-create --type project --template zynqMP --name cus_project
petalinux-config --get-hw-description=/home/alpha/abinash/zcu102/working_image/modem_handoff_18092023_0830
petalinux-build
petalinux-package --boot --fsbl --fpga --pmufw --u-boot --force



qspi build



sudo dpkg-reconfigure dash 

source settings.sh 

petalinux-create --type project --template zynqMP --name cus_project

petalinux-config --get-hw-description=/home/alpha/abinash/zcu102/working_image/modem_handoff_18092023_0830
petalinux-config --get-hw-description=/home/alpha/abinash/zcu102/working_image/modem_handoff_11102023_1000
petalinux-config --get-hw-description=/home/alpha/abinash/working_image/modem_handoff_12102023_1350
petalinux-config --get-hw-description=/home/alpha/abinash/working_image/modem_handoff_12102023_1620
petalinux-config --get-hw-description=/home/alpha/Desktop/modem_handoff_16102023_1620
petalinux-config --get-hw-description=/home/alpha/Desktop/modem_handoff_27102023_0715


petalinux-config -c u-boot

petalinux-config -c rootfs // attach externl file like ssh,xz,lrz

petalinux-build -x clean

petalinux-build

petalinux-package --boot --fsbl --fpga --pmufw --u-boot --force


petalinux-package --boot --force --format BIN --fsbl --pmufw --u-boot --kernel images/linux/Image --offset 0x1080000 --cpu a53-0 --boot-script --offset 0x3080000 --add images/linux/rootfs.cpio.gz.u-boot --offset 0x4000000 --cpu a53-0 --file-attribute partition_owner=uboot


-------------------------------------------------------------------------------------

                                      re_build
       we get all commants ;
       
petalinux-build -c clean devicetree   
petalinux-build -c compile kernel                            

git status 


kernal complile
=====================================

petalinux-build -c kernel -x cleansstate -f

petalinux-build -c kernel -x compile -f

petalinux-build -c kernel -x deploy -f

petalinux-build


device-tree complile
===============================================

petalinux-build -c device-tree -x cleansstate -f

petalinux-build -c device-tree -x compile -f

petalinux-build -c device-tree -x deploy -f

rootfs complile
=============================================
petalinux-build -c rootfs -x cleansstate 

petalinux-build -c rootfs -x compile 

petalinux-build -c rootfs


u-boot complile
===============================================
petalinux-build -c u-boot -x cleansstate -f

petalinux-build -c u-boot -x compile -f

petalinux-build -c u-boot -x deploy -f


Unable to connect to bitbake server we try these command
=============================================
pkill -f bitbake


u-boot soure file path
===========================================

~/ADTL/Xilinx_zcu102/PetaLinux/EMMC_IMAGE/build/tmp/work/zynqmp_generic-xilinx-linux/u-boot-xlnx/v2021.01-xilinx-v2022.2+gitAUTOINC+b31476685d-r0/git/drivers



BOOT image generated command 
==============================================

bootgen -image adtlboot.bif -arch zynqmp -w -o /home/alpha/EMMC/BOOT.BIN

bootgen -image adtlboot.bif -arch zynqmp -w -o /home/alpha/EMMC/BOOT.BIN;  cp zynqmp_fsbl.elf /home/alpha/EMMC/


machine understandable file(.dtb) to human understandable file(.dts)
===============================================

dtc -I dtb -O dts -f devicetree_file_name.dtb -o devicetree_file_name.dts

------------------------------------------------------------------------------------------------------------------------------------------

device-tree changes  
=========================================
 
 /ADTL/Xilinx_zcu102/PetaLinux/EMMC_IMAGE$ vim ./project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi
 
 after build

/ADTL/Xilinx_zcu102/PetaLinux/EMMC_IMAGE/build/tmp/work/zynqmp_generic-xilinx-linux/device-tree/xilinx-v2022.2+gitAUTOINC+24d29888d0-r0

 generat file 
   
 /ADTL/Xilinx_zcu102/PetaLinux/EMMC_IMAGE/build/tmp/work/zynqmp_generic-xilinx-linux/device-tree/xilinx-v2022.2+gitAUTOINC+24d29888d0-r0/device-tree-build$ vim system-top.dts.pp 
-------------------------------------------------------------------------------------------------------------------------------------------





=================================================================================================================================================================================                                         
                                         
                                                                                       
                                                                                       
                                                                       links;                                                         

build WEBSITE

https://support.xilinx.com/s/article/1276990?language=en_US
https://support.xilinx.com/s/article/000033588?language=en_US

vivado

https://support.xilinx.com/s/article/1216727?language=en_US


ZCU102 development board pdf 

https://www.xilinx.com/support/documents/boards_and_kits/zcu102/ug1182-zcu102-eval-bd.pdf


Emmc config file ;

https://support.xilinx.com/s/question/0D54U00006MniTxSAJ/how-to-pack-imageub-and-bootscr-into-bootbin-in-petalinux-20221?language=en_US

greap boot image website;

https://support.xilinx.com/s/article/1015804?language=en_US

serdes links:

https://support.xilinx.com/s/question/0D52E00006iHr3mSAC/serdes-initialization-timed-out?language=en_US
https://support.xilinx.com/s/question/0D52E00006hpRmLSAU/simulation-of-selectio-lvds-serdes-of-zynq-fpga?language=en_US


sgmii

https://support.xilinx.com/s/article/000035491?language=en_US


device tree extrenal file addted 
============================================================================
https://docs.xilinx.com/r/en-US/ug1144-petalinux-tools-reference-guide/Configuring-Device-Tree


Add /include/ "system-user-1.dtsi" in project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi. The file should look like the following:

/include/ "system-conf.dtsi"
/include/ "system-user-1.dtsi"
/ {
};

Add file://system-user-1.dtsi to project-spec/meta-user/recipes-bsp/device-tree/device-tree.bbappend. The file should look like this:

FILESEXTRAPATHS:prepend := "${THISDIR}/files:"
					
SRC_URI += "file://system-user.dtsi"
SRC_URI += "file://system-user-1.dtsi"

Recommended: It is not recommended to change anything in <plnx-proj-root>/components/plnx_workspace/device-tree/device-tree/.



====================================================================================================================================================================================


development board build AND FLASDH;
                                                                         


BOOT MODES( boot switch)
===========
QSPI 	-->   0010    on,on,off,on
JTAG	-->   0000    on,on,on,on
SDCARD  -->   1110    off,off,off,on


SD Card flash
==========================
Copy below files in boot partition of sd card (set 1gb)(fat32)
~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/images/linux$

BOOT.BIN
boot.scr
image.ub

alpha@alpha-S410:~$ cd /media/alpha/rootfs/
alpha@alpha-S410:/media/alpha/rootfs$ 
alpha@alpha-S410:/media/alpha/rootfs$ 
alpha@alpha-S410:/media/alpha/rootfs$ ls
lost+found  rootfs.tar.gz
alpha@alpha-S410:/media/alpha/rootfs$ 
alpha@alpha-S410:/media/alpha/rootfs$ sudo tar -xvzf rootfAdd /include/ "system-user-1.dtsi" in project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi. The file should look like the following:

/include/ "system-conf.dtsi"
/include/ "system-user-1.dtsi"
/ {
};

Add file://system-user-1.dtsi to project-spec/meta-user/recipes-bsp/device-tree/device-tree.bbappend. The file should look like this:

FILESEXTRAPATHS:prepend := "${THISDIR}/files:"
					
SRC_URI += "file://system-user.dtsi"
SRC_URI += "file://system-user-1.dtsi"

Recommended: It is not recommended to change anything in <plnx-proj-root>/components/plnx_workspace/device-tree/device-tree/.s.tar.gz 


Copy below file in rootfs partition of sd card and extract it using tar -xvzf command(rest)(ext4)

rootfs.tar.gz 

sudo tar -xvzf rootfs.tar.gz 


sudo cp BOOT.BIN boot.scr image.ub /media/alpha/boot/
[sudo] password for alpha: 
alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/images/linux$ sudo cp rootfs.tar.gz /media/alpha/rootfs/

alpha@alpha-S410:~/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/images/linux$ sync

                     umount /media/alpha/boot 
alpha@alpha-S410:~$ umount /media/alpha/rootfs 


JTAG BOOT
===================

PetaLinux/xilinx-zcu102-2022.1/images/linux$ petalinux-boot --jtag --u-boot u-boot.elf

QSPI FLASH FROM UBOOT(u-boot mode)
========================
copy below 4 filed from path /home/zumi/ADTL/Xilinx_zcu102/PetaLinux/xilinx-zcu102-2022.1/images/linux  to /tftp

1)BOOT.BIN
2)Image
3)rootfs.cpio.gz.u-boot
4)boot.scr

setenv ipaddr 192.168.0.20
setenv serverip 192.168.0.119
sf probe 0 0 0
sf erase 0x00 0x8000000
tftpboot 0x8000000 192.168.0.119:BOOT.BIN
sf write 0x8000000 0x0 0x87dcd0   //   we have to cahnge this hex size according to the memorty  (87dcd0)
tftpboot 0x8000000 192.168.0.119:Image
sf write 0x8000000 0xF00000 0x1497a00     //   we have to cahnge this hex size according to the memorty 
tftpboot 0x8000000 192.168.0.119:rootfs.cpio.gz.u-boot
sf write 0x8000000 0x4000000 0x1bd1fd1      //   we have to cahnge this hex size according to the memorty 
tftpboot 0x8000000 192.168.0.119:boot.scr
sf write 0x8000000 0x03e80000 0xad9         //   we have to cahnge this hex size according to the memorty 

reset

======================================================================================================================================================================================


                                     gread bOOT image 



pheriperal checking website


https://support.xilinx.com/s/article/1015804?language=en_US


vitis


creat boot image 

/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/emmc_check_system/_ide/bootimage/emmc_check_system.bif
/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/emmc_check_system/_ide/bootimage/emmc_check_system.bif
/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/emmc_check_system/_ide/bootimage/BOOT.bin

/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/system_top/export/system_top/sw/system_top/boot/fsbl.elf
/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/emmc_check/_ide/bitstream/system_top.bit
/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/emmc_check/Debug/emmc_check.elf



program flash memory

/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/system_top/export/system_top/sw/system_top/boot/BOOT.bin
/home/alpha/AlphaWorkspace/20-9-23/dev/flash3/system_top/export/system_top/sw/system_top/boot/fsbl.elf


127.0.0.1:3121





==================================================================================================================================================================================



sudo ethtool –s eth0 speed 1000 duplex full autoneg off
sudo ethtool –s eth0 speed 1000 duplex full autoneg on



==========================================================================================================================================

path

~/ADTL/Xilinx_zcu102/PetaLinux/EMMC_IMAGE/project-spec/meta-user/recipes-bsp/device-tree/files == > system-user.dtsi



/include/ "system-conf.dtsi"
/ {
};
&gem2 {
phy9: phy@9 {
status = "disabled";
};


#include "system-conf.dtsi"

/ {
};

&gem2 {
    status = "okay"; // Assuming you want to enable gem2

    phy9: phy@9 {
        status = "disabled";
    };
};


/include/ "system-conf.dtsi"
/ {
};

/*
&gem0 {
    phy-handle = <&phy0>;
 phy0: phy@0 {
                 reg = <0x09>;
                xlnx,phy-type = <0x5>;
                reset-gpios = <&gpio 78 0>;
        };
};
*/

&gem2 {
   phy-handle = <&phy9>;
 phy9: phy@9 {
    reset-gpios = <&gpio 79 0 &gpio 78 0>;
};
};
   




=======================================================================================================================================


ethernet

sudo ethtool -s eth0 autoneg off speed 1000 duplex full
sudo ethtool -s eth2 autoneg off speed 1000 duplex full
sudo ethtool -s eth0 advertise 0x002
sudo ethtool -s eth2 advertise 0x002
sudo ifconfig eth0 up
sudo ifconfig eth2 up

sudo ethtool -s eth0 private on
sudo ethtool -s eth2 private on

# Transmit data on eth0
echo "Hello, World!" | sudo tee /dev/eth0

# Receive data on eth0
sudo cat /dev/eth0

=====================================================================================================================================


petalinux output file explanation
===================================

   1.  adtlboot.bif:
        Purpose: This is a Boot Image Format (BIF) file. It specifies the components of the boot image, including the FSBL (First Stage Boot Loader), PMU Firmware, U-Boot, and the device tree.
        Usage: It is used as input to the bootgen tool during the creation of the BOOT.BIN file.


   2.  bootgen.bif:
        Purpose: Similar to adtlboot.bif, this is another Boot Image Format (BIF) file. It specifies the components of the boot image and their addresses in memory.
        Usage: It is processed by the bootgen tool to generate the BOOT.BIN file.


   3.  devicetree_file_name.dts:
        Purpose: This is a Device Tree Source (DTS) file. It describes the hardware configuration of the system.
        Usage: It is compiled into a Device Tree Blob (DTB) file, which is used by the Linux kernel during boot to understand the hardware layout.


    4.  pmufw.elf:
        Purpose: This file contains the Power Management Unit (PMU) Firmware. It manages power-related functions on the Zynq UltraScale+ MPSoC.
        Usage: Loaded onto the PMU of the Zynq device.


    5.  rootfs.cpio.gz:
        Purpose: This is the root filesystem image. It contains the file system structure that will be loaded onto the target device.
        Usage: Used by the Linux kernel during boot.


    6. rootfs.manifest:
        Purpose: This file contains a manifest of the root filesystem. It may list the files, versions, or other information about the contents of the root filesystem.
        Usage: Informational.


    7. u-boot.bin:
        Purpose: This is the U-Boot binary. U-Boot is a bootloader used in embedded systems. It initializes the hardware and loads the Linux kernel.
        Usage: Loaded onto the target device as part of the boot process.


    8. vmlinux:
        Purpose: This file is the Linux kernel image. It contains the compressed Linux kernel.
        Usage: Loaded by U-Boot during the boot process.

    9. zynqmp-qemu-multiarch-pmu.dtb:
        Purpose: Device Tree Blob (DTB) file for QEMU emulation with multiarch support, specifically for the PMU (Power Management Unit).
        Usage: Used in QEMU emulation.


    10. BOOT.BIN:
        Purpose: This is the final boot image file. It includes the FSBL, PMU Firmware, U-Boot, and other components.
        Usage: Loaded onto the target device for booting.

 
    11. bl31.bin, bl31.elf:
        Purpose: These files contain the Trusted Execution Environment (TEE) firmware for ARM platforms.
        Usage: Loaded onto the ARM Trusted Firmware (ATF) component of the system.


    12. boot.scr:
        Purpose: This is a U-Boot script file. It contains a sequence of U-Boot commands.
        Usage: Executed by U-Boot during the boot process.


    13.   Image, Image.gz:
        Purpose: These files are Linux kernel images.
        Usage: Loaded by U-Boot during the boot process.


    14.   pmu_rom_qemu_sha3.elf:
        Purpose: PMU ROM binary for QEMU emulation with SHA3 support.
        Usage: Used in QEMU emulation.


    15.  rootfs.cpio.gz.u-boot:
        Purpose: Similar to rootfs.cpio.gz, but modified for compatibility with U-Boot.
        Usage: Loaded by U-Boot during the boot process.

    16.  rootfs.tar.gz:
        Purpose: An archive of the root filesystem in tar.gz format.
        Usage: Used for creating the root filesystem.

    17. u-boot-dtb.bin, u-boot-dtb.elf, u-boot.elf:
        Purpose: Different formats of the U-Boot bootloader binary with Device Tree support.
         Usage: Loaded by the boot process.


    18. zynqmp_fsbl.elf:
        Purpose: This file contains the FSBL (First Stage Boot Loader) for the Zynq UltraScale+ MPSoC.
        Usage: Loaded onto the Processing System (PS) of the Zynq device.


    19. pxelinux.cfg:
        Purpose: Configuration directory for PXE booting.
        Usage: Used in PXE (Preboot Execution Environment) boot scenarios.

    20. rootfs.ext4, rootfs.jffs2:
        Purpose: Filesystem images in different formats (ext4, jffs2).
        Usage: Used for creating the root filesystem.

    21. system.bit, system.dtb:
        Purpose: Bitstream and Device Tree Blob (DTB) files for the hardware design.
        Usage: Used to configure the programmable logic (PL) of the Zynq device.

    22. zynqmp-qemu-arm.dtb, zynqmp-qemu-multiarch-arm.dtb:
        Purpose: Device Tree Blob (DTB) files for QEMU emulation.
        Usage: Used in QEMU emulation.

    23. image.ub:
        Purpose: U-Boot image containing the Linux kernel and device tree.
        Usage: Loaded by U-Boot during the boot process.









================================================= gpio =============================================


raspberrypi board

gpio readall
sudo apt install wiringpi
gcc light.c -lwiringPi




# echo 465 > /sys/class/gpio/export
cd /sys/class/gpio/gpio465^C

cd /sys/kernel/debug/gpio
ls

ls /sys/class/gpio/


cat /sys/kernel/debug/gpio
echo 495 > /sys/class/gpio/export
cat  /sys/class/gpio/gpio(number)/direction
echo out > /sys/class/gpio/gpio468/direction

echo 0 > /sys/class/gpio/gpio468/value







Power LED
Internet LED
WIFI LED

Switch LED

# Power LED
echo 465 > /sys/class/gpio/export
cd /sys/class/gpio/gpio465
echo 1 > value  # Turn on Power LED
echo 0 > value  # Turn off Power LED
echo 465 > /sys/class/gpio/unexport

ls                                                                                                                                  
                                                                                                                                     
cd gpio64                                                                                                                            
                                                                                                                                    
sudo su                                                                                                                              
                                                                                                                                    
cd gpio64                                                                                                                            
                                                                                                                                     
cat direction                                                                                                                        
                                                                                                                                     
echo out > direction                                                                                                                 
                                                                                                                                     
cat value                                                                                                                            
                                                                                                                                    
echo 1 > value                                                                                                                       
                                                                                                                                     
ls                                                                                                                                   
                                                                                                                                     
---------------------------------------------------------------------------------------------------------                            
________________________________________________________________________________________________________                             
                                                                                                                                    
                                                                                                                                     
# Export GPIO pin 17                                                                                                                 
echo 17 > /sys/class/gpio/export                                                                                                    
                                                                                                                                     
                                                                                                                                    
# Set the direction of GPIO pin 17 as output                                                                                         
echo out > /sys/class/gpio/gpio17/direction                                                                                          
                                                                                                                                    
# Set the value of GPIO pin 17 to high                                                                                               
echo 1 > /sys/class/gpio/gpio17/value                                                                                                
                                                                                                                                     
# Delay for a while                                                                                                                  
                                                                                                                                    
# Set the value of GPIO pin 17 to low                                                                                                
echo 0 > /sys/class/gpio/gpio17/value                                                                                                
                                                                                                                                     
# Unexport GPIO pin 17                                                                                                               
echo 17 > /sys/class/gpio/unexport                                                                                                   
                                                                                                                                    
_________________________________________  
    
gpio conrol
--------------------------------------
    

sys/kernel/debug

cat. gpio




/sys/class/gpio

echo 64 > export

cd gpio64

gpio64 > cat direction 
gpio64 > echo out > direction

gpio64  > cat value

gpio64 > echo i > value
    
    
    
    
    
anydesk
==============



dpkg -l | grep anydesk

sudo apt remove --purge anydesk


https://download.anydesk.com/linux/

sudo dpkg -i anydesk_6.3.2-1_amd64.deb

sudo apt-get install -f

sudo service anydesk restart




https://download.anydesk.com/linux/

sudo dpkg -i anydesk_6.3.2-1_amd64.deb

sudo apt-get install -f


sudo service anydesk restart

sudo vi /etc/gdm3/custom.conf 

need do change     
    
    
    
    
    
 
    
    
genral commants
=================================

inatsll lib externely 

sudo dpkg -i /path/to/libconfig9.deb


onther way 

cd /media/Abi/libconfig9

sudo cp libconfig.so.11 /usr/lib

sudo ldconfig


    
increase root file system 


#!/bin/bash
parted -a optimal /dev/mmcblk0 resizepart 2 15GB
resize2fs /dev/mmcblk0p2
    
















wifi driver update
================================

https://askubuntu.com/questions/1430148/ubuntu-22-04-1-ltsjammy-jellyfish-installing-wifi-driver








					*******************
                                        * Linux comments  *
                                        *******************



===================================
| general comments in programming |
===================================

1.echo "echo" is a command that is used to display text or values on the terminal

2.cat "cat" command when you want to quickly view the contents of a file, display the contents of multiple files sequentially,

3.sudo "sudo" stands for "superuser do" or "substitute user do."    perform tasks that require administrative permissions, such as installing software, modifying system files, configuring services, or performing other system-level operations.

4.sudo su  "sudo su"is needed when you need to perform administrative tasks that require root privileges. This might include tasks like installing system-wide software, modifying system configuration files, or troubleshooting system issues.

5.rm -rf -rm -rf is a command used in Linux to forcefully and completely delete files and directories, including their contents.

6.mv ( sourefile destinationfile ) okey rm -rf i need one line answer simple and easy understating answer

7.df 'df' command in Linux is used to display information about disk space usage on your system
( df -a,df -h,df -i,df -hT,df -T)





                                              
================================================(1)=======================================================
					       (gpio)        


 1./sys/class/gpio directory is a part of the sysfs virtual filesystem. It provides an interface for   user-space programs to interact with the General Purpose Input/Output (GPIO) pins on a computer's hardware platform

1.1 Exporting GPIO Pins: Before you can use a GPIO pin, you need to export it by writing its pin number to the /sys/class/gpio/export file. This notifies the system that you want to control that specific GPIO pin.

1.2 Configuring Direction: After exporting a GPIO pin, you need to specify whether it will be used for input or output. This is done by writing either "in" or "out" to the /sys/class/gpio/gpioN/direction file, where N is the pin number.

1.3 Performing GPIO Operations: Once the direction is set, you can read or write to the /sys/class/gpio/gpioN/value file to read the current state (for input pins) or set the state (for output pins) of the GPIO pin.

1.4 Unexporting GPIO Pins: When you're done using a GPIO pin, you should unexport it by writing its pin number to the /sys/class/gpio/unexport file. This frees up the resources associated with that GPIO pin.

-------------------------------------------------------------------------------------------------------


make kernel_menuconfig






















intro

1.CAN
2.imx8mm




TWR-LS1021A


Operating System


cat /etc/*-release



https://forum.digikey.com/t/debian-getting-started-with-the-twr-ls1021a/12709











debug prints
==============


void debug_print(const char* func, int line) {
    printf("Zumi Fun: %s Line: %d\r\n", func, line);
}

// Macro to simplify usage of the debug_print function
#define p() debug_print(__func__, __LINE__)


p();

void debug_print(conat char* file, const char* func, int line) {
    printk("Zumi FILE: %s Fun: %s Line: %d\r\n",file, func, line);
}

// Macro to simplify usage of the debug_print function
#define  p() debug_print(__FILE__, __func__, __LINE__)




other file 

#include <stdio.h>

// Declare the function as extern
extern void debug_print(const char* func, int line);

// Macro to simplify usage of the debug_print function
#define p() debug_print(__func__, __LINE__)

// Your other code here...




void debug_print(const char* file, const char* func, int line);

void debug_print(const char* file, const char* func, int line) {
    // Extract the file name from the full path
    const char *file_name = strrchr(file, '/');
    if (file_name) {
        file_name++;  // Move past the '/'
    } else {
        file_name = file;  // If no '/' is found, use the entire string
    }

    printk("\tFile: %s, Function: %s, Line: %d\r\n\n", file_name, func, line);
}

#define  p() debug_print(__FILE__, __func__, __LINE__)

















pci 0 long
pci 1 long
pci 2 long
pci 3 long


pci 0 enum
pci 1 enum
pci 2 enum
pci 3 enum


pci header 01.01.00





=================
mount commant

mount -t debugfs none /mnt




./qca-wifi/cmn_dev/hif/src/dispatcher/multibus_pci.c





printk("\n\tZumi calling %d time\n",ii++);

printk("\tZumi1 handover_issued: %d\n",q6->handover_issued);

printk("\tZumi2 remote_id: %d\n",q6->remote_id);

printk("\tZumi3 crash_reason: %d\n",q6->crash_reason);

printk("\nZumi4 running: %d\n",q6->running);

printk("\tZumi5 stop_bit: %d\n",q6->stop_bit);

printk("\tZumi6 shutdown_bit: %d\n",q6->shutdown_bit);

printk("\tZumi7 spawn_bit: %d\n",q6->spawn_bit);

printk("\nZumi8 wdog_irq: %d\n",q6->wdog_irq);

printk("\tZumi9 fatal_irq: %d\n",q6->fatal_irq);

printk("\tZumi10 ready_irq: %d\n",q6->ready_irq);

printk("\tZumi11 handover_irq: %d\n",q6->handover_irq);

printk("\tZumi12 stop_irq: %d\n",q6->stop_irq);

printk("\tZumi13 spawn_irq: %d\n",q6->spawn_irq);

printk("\tZumi14 initial name of the device: %s\n",q6->rproc->name);

printk("\tZumi15 device_type: %s\n",q6->rproc->firmware);

printk("\tZumi16 initial name of the device: %s\n",q6->dev->init_name);

printk("\tZumi17 device_type: %s\n",q6->dev->type->name);


printk("\n\t\t\t   print  DONE    \n");


















printk("\n\tZumi calling %d time\n",ii++);

printk("\tZumi1 Name: %s\n",pdev->name);

printk("\tZumi2 ID: %d\n",pdev->id);

printk("\tZumi3 ID auto: %d\n",pdev->id_auto);

//printk("\tZumi4 platform_device_id: %s\n",pdev->id_entry->name);

//printk("\tZumi5 driver_data: %ld\n",pdev->id_entry->driver_data);

printk("\tZumi6 Driver name to force a match: %s\n",pdev->driver_override);

printk("\tZumi7 initial name of the device: %s\n",pdev->dev.init_name);

printk("\tZumi8 device_type: %s\n\n",pdev->dev.type->name);






































/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13

/home/zumi/CUSTOM-12.2/qcom_setup_workspace_v1/MPL/256_0323/qca-networking-2022-spf-12-2_qca_oem-r12.2.r3_00009.0-aab7111e0243158695d5c2f4d3d044355f309b13/common/build/ipq_x64/ipq5018 vim flash_partition/nand-partition.xml



3.1

wifi_fw_ipq5018_qcn9000

3.3

wifi_fw_ipq5018_qcn9000_qcn6122


apss_proc/out/meta-scripts/pack_hk.py
grep "nand device 0 && nand erase" * -r













lakshmi folder

AP.MP-logs/Steps-to-Build-And-Flash.txt


usb flash

usb start
fatload usb 0:1 0x44000000 norplusnand-ipq5018-single.img  && imgaddr=$fileaddr && source $imgaddr:script







========================


				CUSTOM BOARD ENVIRONMENT
==============================================================================================================
24 JAN 2024
=============
COMPILATION STEPS
====================
Go to qsdk directory:
----------------------
make V=s -j5 2>&1| tee log.txt
if error occurs
	=> Check ethernet from zumi
	=> make V=s -j1 2>&1| tee log.txt

ONCE COMPILATION IS SUCCESS 

Go to qsdk directory:
-------------------------
cp -f bin/targets/ipq50xx/ipq50xx_32/openwrt-ipq50* ../common/build/ipq

cd ../common/build/

export BLD_ENV_BUILD_ID=P (If profile is not selected then only execute this command)
=================================================
To enable to LM256 Profile:
export BLD_ENV_BUILD_ID=LM256
=================================================
RUN THE BELOW COMMAND IN BUILD DIRECTORY: (EXAMPLE: /common/build/)

python update_common_info.py

ONCE SINGLE IMAGE IS GENERATED, COPY IT TO THE TFTP FOLDER (EXAMPLE: /home/zumi/tftp)
cd bin/
cp nand-ipq5018-single.img /home/zumi/tftp/nand-C7.img

Power cycle the Custom board and stop at u-boot prompt then execute the below commands in custom board terminal:
================================================================

setenv ipaddr 192.168.1.1
setenv serverip 192.168.1.10
tftpb nand-C5.img && imgaddr=$fileaddr && source $imgaddr:script
================================================================
tftpb norplusnand-ipq5018-single.img && imgaddr=$fileaddr && source $imgaddr:script

tftpb norplusnand-L4.img && imgaddr=$fileaddr && source $imgaddr:script
tftpb norplusnand-ref-29.img && imgaddr=$fileaddr && source $imgaddr:script
tftpb norplusnand-revert-256.img && imgaddr=$fileaddr && source $imgaddr:script 
tftpb norplusnand-Sw-dbg.img && imgaddr=$fileaddr && source $imgaddr:script 
tftpb norplusnand-gmac1-cfg.img && imgaddr=$fileaddr && source $imgaddr:script 
	=> (Flashed on 3 Feb with gmac1 commented in u-boot dts)
	=> Switch Link is up (Port Status LED is ON)

tftpb norplusnand-updated-ddr-memory.img && imgaddr=$fileaddr && source $imgaddr:script 













c-code dts working 
==============================


dts
====
/dts-v1/;
/ {
    compatible = "example,config";

    config {
        delay = <1000>;  // Delay in milliseconds
        increment = <10>; // Increment value
        abi = <66>; // Increment value
    };
};

--------------------------------------------
dtc -I dts -O dtb -o config.dtb config.dts
sudo apt-get install libfdt-dev
gcc -o config_reader config_reader.c -lfdt
sudo ./config_reader
--------------------------------------------


c-code
=========

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <libfdt.h>

// Function to read an integer property from the Device Tree
int read_int_from_dtb(void *fdt, const char *path, const char *property) {
    int offset = fdt_path_offset(fdt, path);
    if (offset < 0) {
        fprintf(stderr, "Failed to find node %s\n", path);
        return -1;
    }

    const int *value = fdt_getprop(fdt, offset, property, NULL);
    if (!value) {
        fprintf(stderr, "Failed to get property %s\n", property);
        return -1;
    }

    return fdt32_to_cpu(*value);
}

int main() {
    // Load the DTB file
    const char *dtb_path = "config.dtb";
    int fd = open(dtb_path, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open DTB file");
        return 1;
    }

    // Get the size of the DTB file
    off_t fdt_size = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);

    // Load the DTB into memory
    void *fdt = malloc(fdt_size);
    if (!fdt) {
        perror("Failed to allocate memory for DTB");
        close(fd);
        return 1;
    }

    if (read(fd, fdt, fdt_size) != fdt_size) {
        perror("Failed to read DTB file");
        free(fdt);
        close(fd);
        return 1;
    }

    close(fd);

    // Read configuration values from the DTB
    int delay = read_int_from_dtb(fdt, "/config", "delay");
    int increment = read_int_from_dtb(fdt, "/config", "increment");

    if (delay < 0 || increment < 0) {
        free(fdt);
        return 1;
    }

    printf("Delay: %d ms, Increment: %d\n", delay, increment);

    // Use the configuration values in a loop
    int value = 0;
    while (1) {
        printf("Value: %d\n", value);
        value += increment;
        usleep(delay * 1000); // Delay in microseconds
    }

    free(fdt);
    return 0;
}






=========================================

apt issues

sudo apt install vim
ps aux | grep apt
sudo kill -9 <PID>
sudo pkill -9 -f <PID>

sudo rm /var/lib/dpkg/lock-frontend
sudo rm /var/lib/apt/lists/lock
sudo rm /var/cache/apt/archives/lock

sudo dpkg --configure -a







file operation in c 

c

    FILE *file = fopen("file.txt", "a+");

Summary Table
Mode	Description	File Existence	Data Preservation
"r"	Open for reading	Must exist	None
"w"	Open for writing (truncate)	Create or truncate	Existing data lost
"a"	Open for appending	Create or append	Existing data preserved
"r+"	Open for reading and writing	Must exist	None
"w+"	Open for reading and writing (truncate)	Create or truncate	Existing data lost
"a+"	Open for reading and writing (append)	Create or append	Existing data preserved




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

google drive 
================

sudo apt update
apt list --upgradable
sudo apt install rclone
rclone config 

rclone config
2024/08/31 12:02:57 NOTICE: Config file "/home/zumi/.config/rclone/rclone.conf" not found - using defaults
No remotes found - make a new one
n) New remote
r) Rename remote
c) Copy remote
s) Set configuration password
q) Quit config
n/r/c/s/q> 
n/r/c/s/q> n
name> Abinash
Type of storage to configure.
Choose a number from below, or type in your own value
 1 / Amazon Drive
   \ "amazon cloud drive"
 2 / Amazon S3 (also Dreamhost, Ceph, Minio)
   \ "s3"
 3 / Backblaze B2
   \ "b2"
 4 / Dropbox
   \ "dropbox"
 5 / Encrypt/Decrypt a remote
   \ "crypt"
 6 / Google Cloud Storage (this is not Google Drive)
   \ "google cloud storage"
 7 / Google Drive
   \ "drive"
 8 / Hubic
   \ "hubic"
 9 / Local Disk
   \ "local"
10 / Microsoft OneDrive
   \ "onedrive"
11 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH)
   \ "swift"
12 / SSH/SFTP Connection
   \ "sftp"
13 / Yandex Disk
   \ "yandex"
Storage> 7
Google Application Client Id - leave blank normally.
client_id> 
Google Application Client Secret - leave blank normally.
client_secret> 
Remote config
Use auto config?
 * Say Y if not sure
 * Say N if you are working on a remote or headless machine or Y didn't work
y) Yes
n) No
y/n> y
If your browser doesn't open automatically go to the following link: http://127.0.0.1:53682/auth
Log in and authorize rclone for access
Waiting for code...
Got code
--------------------
[Abinash]
client_id = 
client_secret = 
token = {"access_token":"ya29.a0AcM612wMsWoMlZKOHhZFypxiWABBF8qy2fSCMfF7jvIlw_1-E8sfHF_y2M5qAI5BnuK-Ty3MxkjjP1ENBA0QwZ7X_tWOZhHoWlI1ijLh94yEiMbGDJ1xHlSIKa4_HpWUv9UZWgkJ2D-Ig8xuKCo53TLZrnArlU72pZc8EfEBaCgYKAd8SARASFQHGX2MiQHwGnLfYoyJVHyzvjvdRvw0175","token_type":"Bearer","refresh_token":"1//0gaxxNqE54MMJCgYIARAAGBASNwF-L9IruyFnvj86bC5bni-UECf3onKwnrdNf-nJ1hDnf8jrHAjkNZwiJfqBckxnFuuhFnkopiA","expiry":"2024-08-31T13:07:08.665130608+05:30"}
--------------------
y) Yes this is OK
e) Edit this remote
d) Delete this remote
y/e/d> y
Current remotes:

Name                 Type
====                 ====
Abinash              drive

e) Edit existing remote
n) New remote
d) Delete remote
r) Rename remote
c) Copy remote
s) Set configuration password
q) Quit config
e/n/d/r/c/s/q> q

==============================

next time refrash 

curl https://rclone.org/install.sh | sudo bash



=============================


















ls commant

rclone lsd Abinash:

rclone mkdir Abinash:/new-directory

rclone copy resize.sh Abinash:/new-directory

rclone delete Abinash:/path/to/file

rclone copy localfile.txt Abinash:/myfiles/


rclone move localfile.txt Abinash:/myfiles/

rclone move Abinash:/myfiles/oldname.txt Abinash:/myfiles/newname.txt


rclone delete Abinash:/myfiles/filetodelete.txt

rclone sync /local/directory Abinash:/remote/directory

rclone purge Abinash:/path/to/directory

rclone sync /local/path Abinash:/remote/path

rclone purge Abinash:/old-folder

rclone delete Abinash:/path/to/directory --rmdirs

rclone copy ~/Abinash/workspase/ABINASH-LINUX.txt Abinash:/cmd





rclone mkdir Abinash:/sw-update/new-update



https://bitbucket.org/prod-engg/fw-update-ti-am4376/src/main/



git clone https://zaid13@bitbucket.org/prod-engg/fw-update-ti-am4376.git


git diff ..>>  change verify 






"
git status


git pull origin  main (branch name)

git add .

git commit -sm "Commit Message"

git push origin main (branchname) 



git log --oneline


after to before 
================

git log --oneline

git reset --hard HEAD^1 


before to after 
===============

git pull

git status 



zaid





git rm --cached fw-update-ti-am4376


git commit -sm "SRS Documnet Added"


git config --global user.name "Zaid"
git config --global user.email "zaid@kemsys.com"
"


abinash








clean c file commants line single code and multiline code using python script 
=======================================================


singl file
---------


import re

def remove_comments(file_path):
    with open(file_path, 'r') as file:
        code = file.read()

    # Remove single-line comments (// ...)
    code = re.sub(r'//.*', '', code)

    # Remove multi-line comments (/* ... */)
    code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)

    # Optionally, remove any trailing whitespace
    code = re.sub(r'\s*\n', '\n', code)  # Clean up empty lines
    code = code.strip()  # Remove leading/trailing whitespace

    return code

def main():
    input_file = '1.c'  # Replace with your input file
    output_file = 'Main_cleaned.c'  # Replace with your desired output file

    cleaned_code = remove_comments(input_file)

    with open(output_file, 'w') as file:
        file.write(cleaned_code)

    # Using standard string formatting for compatibility
    print('Cleaned code saved to {}'.format(output_file))

if __name__ == "__main__":
    main()

=============================================================================

total folder
--------------

def remove_comments(file_path):
    with open(file_path, 'r') as file:
        code = file.read()

    # Remove single-line comments (// ...)
    code = re.sub(r'//.*', '', code)

    # Remove multi-line comments (/* ... */)
    code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)

    # Clean up empty lines and strip whitespace
    code = re.sub(r'\s*\n', '\n', code)  # Clean up empty lines
    code = code.strip()  # Remove leading/trailing whitespace

    return code

def main():
    # Get the current directory
    directory = '.'  # Change this if needed

    # Loop through all files in the directory
    for filename in os.listdir(directory):
        if filename.endswith('.c') or filename.endswith('.h'):
            file_path = os.path.join(directory, filename)
            cleaned_code = remove_comments(file_path)

            # Save the cleaned code back to the original file
            with open(file_path, 'w') as file:
                file.write(cleaned_code)

            print('Cleaned code saved to {}'.format(file_path))

if __name__ == "__main__":
    main()


 

===========================
search and copy all the hear file and copy into single folder 
============================================================

import os
import shutil
import filecmp

# Define the target directory where header files should be copied
target_dir = "./headers"

# Create the target directory if it doesn't exist
if not os.path.exists(target_dir):
    print(f"Target directory '{target_dir}' does not exist. Creating it...")
    os.makedirs(target_dir)

# Walk through the current directory and all subdirectories
for root, dirs, files in os.walk("."):
    for file in files:
        # Check if the file has a .h extension
        if file.endswith(".h"):
            # Define the full file path
            file_path = os.path.join(root, file)
            
            # Define the target file path (in the 'headers' directory, without folder structure)
            target_file_path = os.path.join(target_dir, file)

            # If the file already exists at the target, compare contents to avoid overwriting identical files
            if not os.path.exists(target_file_path):
                # Copy the file if it doesn't already exist in the target directory
                shutil.copy(file_path, target_file_path)
                print(f"Copied: {file_path} to {target_file_path}")
            else:
                # If file already exists, compare contents to avoid copying the same file
                if not filecmp.cmp(file_path, target_file_path, shallow=False):
                    shutil.copy(file_path, target_file_path)
                    print(f"Copied: {file_path} to {target_file_path}")
                else:
                    print(f"Skipped: {file_path} as it already exists and is identical.")

print("All header files have been copied to the 'headers' directory.")




-----------------------------------------------------------------------------------------------------
insaid filese modify all files heaters
---------------------------------------------------------------------------------------------------
import os

# Define the target directory where the header files are located
target_dir = "./"  # The current directory (change if needed)

# Function to modify includes in a file
def modify_includes(file_path):
    # Open the file with a more lenient encoding (ISO-8859-1 or errors='ignore')
    with open(file_path, 'r', encoding='ISO-8859-1', errors='ignore') as file:
        lines = file.readlines()

    modified = False
    with open(file_path, 'w', encoding='ISO-8859-1') as file:
        for line in lines:
            # Check if the line contains an include directive
            if '#include ' in line:
                # If the include uses angle brackets <>
                if '<' in line and '>' in line:
                    start_index = line.find('<') + 1
                    end_index = line.find('>')
                    include_file = line[start_index:end_index]

                    # Print the full path of the file being included (for debugging)
                    print(f"Found include: {include_file}")

                    # Extract just the file name from the path
                    include_file_name = os.path.basename(include_file)

                    # Print the base file name (for debugging)
                    print(f"Base file name: {include_file_name}")

                    # Check if the file exists in the current directory
                    if os.path.exists(os.path.join(target_dir, include_file_name)):
                        # Modify the line to use double quotes instead of angle brackets
                        line = line.replace(f'#include <{include_file}>', f'#include "{include_file_name}"')
                        modified = True

            # Write the (possibly modified) line back to the file
            file.write(line)

    return modified

# Walk through all files in the target directory
for file in os.listdir(target_dir):
    if file.endswith((".c", ".h")):  # Check if it's a C or header file
        file_path = os.path.join(target_dir, file)

        # Modify the include statements in the file
        if modify_includes(file_path):
            print(f"Modified: {file_path}")
        else:
            print(f"No modification needed: {file_path}")

print("Completed modifying the #include directives in C and header files.")



---------------------------------------------------------------------------------------------------------------------------
include all heaters in single file 
----------------------------------------------------------------------------------------------------------------------------

import os

# Define the target directory where the header files are located
target_dir = "/home/zumi/ti/headers"  # Change this to your target directory

# Define the output file where all #include statements will be written
output_file = "all_includes.h"

# Open the output file for writing
with open(output_file, 'w') as outfile:
    # Walk through all files in the target directory
    for file_name in os.listdir(target_dir):
        if file_name.endswith(".h"):  # Check if it's a header file (.h)
            # Full path to the header file
            file_path = os.path.join(target_dir, file_name)

            # Write the #include statement to the output file
            outfile.write(f'#include "{file_path}"\n')

print(f"All header files have been included in {output_file}.")





---------------------------------------------------------------------------------------------------

line chage 
------------------------------------------------------------------------------------------------------

import os
import re

# Define the target directory where the header files are located (current directory)
target_dir = "."  # Current directory (change if needed)

# Function to modify include directives in a file
def modify_includes(file_path):
    # Open the file with a more lenient encoding (ISO-8859-1 or errors='ignore')
    with open(file_path, 'r', encoding='ISO-8859-1', errors='ignore') as file:
        lines = file.readlines()

    modified = False
    with open(file_path, 'w', encoding='ISO-8859-1') as file:
        for line in lines:
            # Search for any # include (with varying spaces)
            if re.search(r'#\s*include', line):  # Regex to match # include with spaces
                # Modify the line to have no spaces between '#' and 'include'
                line = re.sub(r'#\s*include', '#include', line)
                modified = True

            file.write(line)

    return modified

# Walk through all files in the target directory
for file in os.listdir(target_dir):
    if file.endswith((".c", ".h")):  # Check if it's a C or header file
        file_path = os.path.join(target_dir, file)

        # Modify the include statements in the file
        if modify_includes(file_path):
            print(f"Modified: {file_path}")
        else:
            print(f"No modification needed: {file_path}")

print("Completed modifying the #include directives in C and header files.")

-------------------------------------------------------------------------------------------------------------------------------------

import os

# Define the target directory where the header files are located
target_dir = "./"  # The current directory (change if needed)

# Function to modify includes in a file
def modify_includes(file_path):
    # Open the file with a more lenient encoding (ISO-8859-1 or errors='ignore')
    with open(file_path, 'r', encoding='ISO-8859-1', errors='ignore') as file:
        lines = file.readlines()

    modified = False
    with open(file_path, 'w', encoding='ISO-8859-1') as file:
        for line in lines:
            # Check if the line contains an include directive
            if '#include ' in line:
                # If the include uses angle brackets <>
                if '<' in line and '>' in line:
                    start_index = line.find('<') + 1
                    end_index = line.find('>')
                    include_file = line[start_index:end_index]

                    # Print the full path of the file being included (for debugging)
                    print(f"Found include (angle brackets): {include_file}")

                    # Modify the line to use double quotes instead of angle brackets
                    line = line.replace(f'<{include_file}>', f'"{include_file}"')
                    modified = True

                # If the include uses double quotes ""
                elif '"' in line:
                    start_index = line.find('"') + 1
                    end_index = line.find('"', start_index)
                    include_file = line[start_index:end_index]

                    # Print the full path of the file being included (for debugging)
                    print(f"Found include (quotes): {include_file}")

                    # Extract just the file name (in case it's a full path)
                    include_file_name = os.path.basename(include_file)

                    # Modify the line to use double quotes (in case it wasn't already)
                    line = line.replace(f'"{include_file}"', f'"{include_file_name}"')
                    modified = True

            # Write the (possibly modified) line back to the file
            file.write(line)

    return modified

# Walk through all files in the target directory
for file in os.listdir(target_dir):
    if file.endswith((".c", ".h")):  # Check if it's a C or header file
        file_path = os.path.join(target_dir, file)

        # Modify the include statements in the file
        if modify_includes(file_path):
            print(f"Modified: {file_path}")
        else:
            print(f"No modification needed: {file_path}")

print("Completed modifying the #include directives in C and header files.")




=================================











hz  friquency
===================

50hz

50 pulses in 1 sec

50 pulses in 1000 milli sec

20 milli sec for 1 pulse



Basic Frequency (Hertz)

1 Hz means 1 pulse per second.

    If you have a 1 Hz signal, there's 1 pulse in 1 second.

50 Hz Example (as you mentioned)

    50 Hz = 50 pulses per second.
    Therefore, each pulse takes 1000 
                                 50   =20ms

Kilohertz (kHz)

1 kHz (kilohertz) is 1,000 Hz, or 1,000 pulses per second.

    So, at 1 kHz, each pulse occurs in:
    1000 ms1000=1 ms
    10001000 ms​=1 ms
    This means 1 pulse every millisecond.

Megahertz (MHz)

1 MHz (megahertz) is 1,000,000 Hz, or 1 million pulses per second.

    At 1 MHz, each pulse occurs in:
    1000 ms1,000,000=0.001 ms=1 μs (microsecond)
    1,000,0001000 ms​=0.001 ms=1 μs (microsecond)
    Here, each pulse takes just 1 microsecond.

Gigahertz (GHz)

1 GHz (gigahertz) is 1,000,000,000 Hz, or 1 billion pulses per second.

    At 1 GHz, each pulse occurs in:
    1000 ms1,000,000,000=0.000001 ms=1 ns (nanosecond)
    1,000,000,0001000 ms​=0.000001 ms=1 ns (nanosecond)
    Each pulse lasts only 1 nanosecond.


1 second = 1,000 milliseconds (ms)
1 millisecond = 1,000 microseconds (µs)
1 microsecond = 1,000 nanoseconds (ns)
1 nanosecond = 1,000 picoseconds (ps)




50khz 
======

To determine the time per pulse for a frequency of 50 kHz, you can use the formula:
Time per pulse=1Frequency
Time per pulse=Frequency1​

    Given: 50 kHz = 50,000 Hz

    Calculate:
    Time per pulse=150,000 seconds=0.00002 seconds
    Time per pulse=50,0001​seconds=0.00002seconds

    Convert to milliseconds:
    0.00002 seconds=0.02 ms
    0.00002seconds=0.02ms

Answer:

At 50 kHz, each pulse takes 0.02 milliseconds (ms) or 20 microseconds (µs).





open pdf file using command line
================================

evince Industrial_Protocol_Package_Getting_Started_Guide.pdf


gmake issues 
---------------
sudo ln -s /usr/bin/make /usr/bin/gmake

TI Forums quary
===========

https://e2e.ti.com/


ti account 
===========
Abinash@zumisolutions.com

Abinash@123


nxp account 
===========
Abinash@zumisolutions.com

Abinash@123


git account 
===========
abinash@zumisolutions.com

Abinash@123a

username
------------
Abinash204-ai

git ai
-----
https://github.com/copilot/c/14d18afa-0e03-40a1-a620-da40b4bb5bde




chatgpt office
==============
abinash@zumisolutions.com

Abinash@123


team viewer
==========
abinash@zumisolutions.com

Abinash@123

board bringup total project
===========================

karthikeyan021199@gmail.com

Karthikeyan9791$


outlook kemsys
================

projects@kemsys.com

J$585844205412uc


DeepSeek. ai chat 
=============
abinash882@gmail.com

Abinash@143


Abinash@143ABI



same like google drive easy to shere your file file shere 
---------------------------------------------------------
https://www.file.io/




auto variable and register variable defrandecs
==============================================

#include <stdio.h>
#include <time.h>

#define LOOP_COUNT 1000000000  // Adjust for significant execution time

int main() {
    clock_t start, end;
    double time_auto, time_register;
    volatile int i;  // Volatile to prevent compiler optimization

    // Auto variable loop
    start = clock();
    auto int auto_var = 0;
    for (i = 0; i < LOOP_COUNT; i++) {
        auto_var += i;
    }
    end = clock();
    time_auto = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Execution time with auto variable: %f seconds\n", time_auto);

    // Register variable loop
    start = clock();
    register int reg_var = 0;
    for (i = 0; i < LOOP_COUNT; i++) {
        reg_var += i;
    }
    end = clock();
    time_register = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Execution time with register variable: %f seconds\n", time_register);

    return 0;
}



MLO ddr test code
====================

#define TEST_PATTERN 0xA5A5A5A5
//#define DDR_SIZE 0x100000 // Size of memory to test (example: 4KB)
#define DDR_SIZE 0x10000000 // Size of memory to test (example: 4KB)

// DDR memory test function
int ddr_read_write_test(uint32_t *ddr_base_addr, size_t size) {
    printf("Starting DDR memory test...\n");

    // Step 1: Write the test pattern to the DDR memory
    for (size_t i = 0; i < size / sizeof(uint32_t); i++) {
        ddr_base_addr[i] = TEST_PATTERN;
         if(i%1024==0)
          printf("iter = %x \r\n", &ddr_base_addr[i]);

    }
    printf("\r\nVerify the test pattern in DDR memory \r\n");
    // Step 2: Verify the test pattern in DDR memory
    for (size_t i = 0; i < size / sizeof(uint32_t); i++) {
        if (ddr_base_addr[i] != TEST_PATTERN) {
            printf("DDR test failed at address 0x%p. Expected: 0x%X, Got: 0x%X\n",
                   (ddr_base_addr + i), TEST_PATTERN, ddr_base_addr[i]);
            return -1; // Return error on failure
        }
         if(i%1024==0)
          printf("R");
    }

    printf("\r\nDDR memory test passed successfully.\n");
    return 0; // Success
}

main(){

  printf("Test DDR\r\n");

      int result = ddr_read_write_test(0x80000000, DDR_SIZE);

}



if our build is you change anythink manualy you using this commant to reinstall the org file
============================================================================================

git status
git checkout -- arch/arm/dts/am437x-sk-evm.dts
git status


git fetch origin
git checkout origin/master -- arch/arm/dts/am437x-sk-evm.dts




MLO file binary to human understandel
===================================

sudo apt-get install binutils

arm-none-eabi-objdump -D -b binary -m arm MLO > MLO_disassembled.txt

strings MLO > MLO_strings.txt



linux interrupt function trace kernel debug Abinash
==================================================
dump_stack();

printk(KERN_INFO "Hello, World! Abinash\n\n\n");
int x = -1;
WARN_ON(x < 0); // Prints warning and stack trace if x is negative

1. dump_stack()

    Purpose: Prints the current call stack for debugging.
    Use Case: Diagnosing kernel panics, oops, or detecting null pointer dereferences.
    Example:

    pr_err("Unexpected condition! Printing stack trace.\n");
    dump_stack();

    Output: Prints function calls leading to the error.

2. WARN() and WARN_ON()

    Purpose: Triggers a warning with a backtrace if a condition is false.
    Use Case: Useful for checking unexpected behavior without crashing the kernel.
    Example:

    int x = -1;
    WARN_ON(x < 0); // Prints warning and stack trace if x is negative

    Output: Logs a warning and stack trace without crashing the system.

3. BUG() and BUG_ON()

    Purpose: Immediately crashes the kernel if a critical error is detected.
    Use Case: When a scenario must never happen in production.
    Example:

    int val = -1;
    BUG_ON(val < 0); // Crashes if val is negative

    Output: Kernel panic with a full stack trace.

4. printk()

    Purpose: Prints kernel messages to the system log (dmesg).
    Use Case: For general logging, state tracking, or tracing during development.
    Example:

    printk(KERN_INFO "Device initialized successfully\n");

    Output: Logs a formatted message to /var/log/kern.log.

5. pr_debug()

    Purpose: Similar to printk() but used for debugging with controlled verbosity.
    Use Case: For temporary debug messages with conditional compilation (#define DEBUG).
    Example:

    pr_debug("Debug: Variable x = %d\n", x);

    Output: Only visible if kernel debugging is enabled.

6. dev_err(), dev_warn(), dev_info()

    Purpose: Logs device-specific messages.
    Use Case: For device drivers to print relevant messages.
    Example:

    dev_err(dev, "Device failed to initialize.\n");

    Output: Error message tagged with the device name.

7. show_stack()

    Purpose: Prints the stack trace of a specific task.
    Use Case: Debugging kernel threads or processes.
    Example:

    struct task_struct *task = current;
    show_stack(task, NULL);

    Output: Stack trace of the current process.

8. trace_printk()

    Purpose: High-performance trace logging using ftrace.
    Use Case: Used when tracing kernel function execution with low overhead.
    Example:

    trace_printk("Trace: Function %s called with arg %d\n", __func__, arg);

    Output: Logged to /sys/kernel/debug/tracing/trace.

9. dump_page()

    Purpose: Dumps information about a memory page.
    Use Case: For debugging memory management issues.
    Example:

    struct page *page = virt_to_page(ptr);
    dump_page(page, "Memory corruption suspected");

    Output: Detailed information about the page.

10. oops()

    Purpose: Simulates a kernel Oops for testing.
    Use Case: To generate artificial kernel panics for testing handlers.
    Example:

    oops();

    Output: Logs kernel Oops and stack trace.







nand boot ubi error but rootfs boot from sdcard rootfs
===================================================


1)lsblk
e.g/dev/sdX (replace X with your actual device).

Create two partitions:
Partition 1 (FAT32): For bootloader or other files if needed.
Partition 2 (ext4): For the root filesystem.
Use fdisk:

2)sudo fdisk /dev/sdX

Press o to create a new partition table.
Press n to create the first partition.
Set it to primary, partition number 1, and size (e.g., +100M for 100MB).
Press t and select c to set the partition type to W95 FAT32 (LBA).
Press n to create the second partition.
Set it to primary, partition number 2, and size (use the remaining space).
Press w to write the changes and exit.

3)

sudo mkfs.vfat -F 32 /dev/sdb1
sudo mkfs.ext4 /dev/sdb2

sudo mkdir -p /mnt/rootfs
sudo mount /dev/sdb2 /mnt/rootfs

sudo tar -xvf tisdk-base-image-am437x-evm.rootfs.tar.xz -C /mnt/rootfs

sudo sync
sudo umount /mnt/rootfs


==try no working====

sudo mount /dev/sdb2 /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/manual/iproute

sudo sync

sudo umount /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/manual/iproute

in u-boot env 
===============

set nandroot "/dev/mmcblk0p2 rw"
set nandrootfstype "ext4 rootwait=10"



✅ Fix 1: Check for Physical Write Protection

    Some USB drives have a physical write-protection switch. Ensure it is not enabled.

✅ Fix 2: Remount the Drive as Read-Write

    First, unmount the device:

sudo umount /dev/sdb1

    Then remount it with read-write permissions:

sudo mount -o rw /dev/sdb1 /media/zumi/ZUMI

✅ Fix 3: Check and Repair File System Errors

    Sometimes the file system might have errors, causing it to mount as read-only. You can check and repair it using fsck:

sudo fsck -a /dev/sdb1


more usefull cmt for sdcard getting issue use this one 
======================================================
audo matically give a fix

sudo fsck -a /dev/sdb1



✅ Step 1: Identify What is Using the Drive

Run the following command to check which processes are using the device:

✅ Step 2: Kill the Processes

Once you find the process IDs (PIDs) using the SD card, you can terminate them:

sudo kill <PID>

If the process doesn't stop, force kill it using:

sudo kill -9 <PID>

✅ Step 3: Try Unmounting Again

After killing the processes, try unmounting:

sudo umount /media/zumi/ZUMI


sudo lsof /media/zumi/ZUMI

✅ Step 4: Force Unmount if Necessary

If the device is still busy, you can force unmount it:

sudo umount -l /media/zumi/ZUMI

✅ Step 5: Eject the Device

After successful unmounting, you can safely eject the SD card:

sudo eject /dev/sdb1










how to flash tar file into the nand becase of low memory space
==============================================================

sudo tar -xOf your_ubifs.tar | sudo nandwrite -o /dev/mtd2




udp pack not reciveing means 
===================================

dynamic
========
sudo ufw allow proto udp from any to any


manual
=======
sudo ufw allow 5555/udp
sudo ufw allow 8080/udp


===================================am4376 

list out

root@am437x-evm:~# cat /sys/kernel/debug/gpio 



root@am437x-evm:~# cat config_phy_reset.sh
echo 29 > /sys/class/gpio/export
echo 45 > /sys/class/gpio/export

echo out > /sys/class/gpio/gpio29/direction 
echo 0 > /sys/class/gpio/gpio29/value
sleep 1
echo 1 > /sys/class/gpio/gpio29/value

echo out > /sys/class/gpio/gpio45/direction 
echo 0 > /sys/class/gpio/gpio45/value
sleep 1
echo 1 > /sys/class/gpio/gpio45/value


root@am437x-evm:~# cat reset_phy.sh                                                                                                           
#!/bin/sh

rmmod pruss
sleep 1
echo 0 > /sys/class/gpio/gpio45/value
sleep 1
echo 1 > /sys/class/gpio/gpio45/value 

echo 0 > /sys/class/gpio/gpio29/value
sleep 1
echo 1 > /sys/class/gpio/gpio29/value 
sleep 1
insmod /lib/modules/pruss.ko




root@am437x-evm:~# cat reset_phy.sh                                                                                                           
#!/bin/sh

rmmod pruss
sleep 1
echo 0 > /sys/class/gpio/gpio45/value
sleep 1
echo 1 > /sys/class/gpio/gpio45/value 

echo 0 > /sys/class/gpio/gpio29/value
sleep 1
echo 1 > /sys/class/gpio/gpio29/value 
sleep 1
insmod /lib/modules/pruss.ko




&pruss1_mdio {
        pinctrl-0 = <&pruss1_mdio_default>;
        pinctrl-names = "default";
        status = "okay";


        reset-delay-us = <2>;   /* PHY datasheet states 1uS min */

        pruss1_eth0_phy: ethernet-phy@0 {
                reg = <0>;
                reset-gpios = <&gpio0 29 GPIO_ACTIVE_LOW>;
                rx-internal-delay-ps=<3500>;
                tx-internal-delay-ps=<3500>;
        };

        pruss1_eth1_phy: ethernet-phy@1 {
                reg = <1>;
                reset-gpios = <&gpio1 13 GPIO_ACTIVE_LOW>;
                rx-internal-delay-ps=<3500>;
                tx-internal-delay-ps=<3500>;
        };
};

gpio in linux
=============

you get the information
------------------------
cat /sys/kernel/debug/gpio 
==========================

calcluted
===============

GPIO number = (controller - 1) * 32 + pin

GPIO number for <&gpio5 9> = (5 - 1) * 32 + 9 = 137

To set as input:
gpio setdir 137 out

To set as input:
gpio setdir 137 in

To set the GPIO pin high:
gpio set 137

To set the GPIO pin low:
gpio clear 137

Read GPIO State:
gpio input 137




gpio set 132  









gpio0 bank 0-32
===============

gpiochip0: GPIOs 0-31, parent: platform/44e07000.gpio, gpio-0-31:
 gpio-7   (                    |rts                 ) out lo 
 gpio-22  (                    |sysfs               ) in  lo 
 gpio-23  (                    |sysfs               ) in  lo 
 gpio-25  (                    |sysfs               ) out lo 


reset-gpios = <&gpio0 29 GPIO_ACTIVE_LOW>;   total 32 bin gpio0 bank 

but bin count start with 0 to 31
==================================

if we need do accusse that 29 pin --> 29+0 =29

echo 29 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio29/direction 
echo 0 > /sys/class/gpio/gpio29/value   //off
echo 1 > /sys/class/gpio/gpio29/value   //on


gpio1 bank 32-63
================

gpiochip1: GPIOs 32-63, parent: platform/4804c000.gpio, gpio-32-63:
 gpio-45  (                    |PHY reset           ) out hi ACTIVE LOW
 gpio-46  (                    |sysfs               ) in  lo 
 gpio-47  (                    |sysfs               ) in  lo 



reset-gpios = <&gpio1 13 GPIO_ACTIVE_LOW>;   total 32 bin gpio1 bank 

but bin count start with 32 to 63
===================================

if we need do accusse that 13 pin -->   13+32 =45

echo 45 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio45/direction 
echo 0 > /sys/class/gpio/gpio45/value   //off
echo 1 > /sys/class/gpio/gpio45/value   //on



linux gpio tiny for am4376 board for led control

echo 113 > /sys/class/gpio/export
echo 114 > /sys/class/gpio/export
echo 116 > /sys/class/gpio/export
echo 106 > /sys/class/gpio/export

echo out > /sys/class/gpio/gpio113/direction 
echo out > /sys/class/gpio/gpio114/direction 
echo out > /sys/class/gpio/gpio116/direction 
echo out > /sys/class/gpio/gpio106/direction 


echo 1 > /sys/class/gpio/gpio113/value   
echo 1 > /sys/class/gpio/gpio114/value  
echo 1 > /sys/class/gpio/gpio116/value   
echo 1 > /sys/class/gpio/gpio106/value


echo 0 > /sys/class/gpio/gpio113/value   
echo 0 > /sys/class/gpio/gpio114/value  
echo 0 > /sys/class/gpio/gpio116/value   
echo 0 > /sys/class/gpio/gpio106/value      




echo 0 > /sys/class/gpio/gpio113/value
sleep 1   
echo 1 > /sys/class/gpio/gpio113/value   

echo 0 > /sys/class/gpio/gpio114/value   
sleep 1
echo 1 > /sys/class/gpio/gpio114/value  

echo 0 > /sys/class/gpio/gpio116/value
sleep 1   
echo 1 > /sys/class/gpio/gpio116/value   

echo 0 > /sys/class/gpio/gpio106/value
sleep 1   
echo 1 > /sys/class/gpio/gpio106/value    


gpio114
gpio115
gpio116
gpio117




manual load kernel form u-boot
=================================


=> nand write 0x82000000 NAND.kernel 0x487882

NAND write: device 0 offset 0x300000, size 0x487882
 4749442 bytes written: OK




=> nand read 0x80800000 NAND.kernel 0x487882

NAND read: device 0 offset 0x300000, size 0x487882
 4749442 bytes read: OK
=> help bootm


nand read 0x80800000 NAND.kernel 0x487882
bootm 0x80800000




auto login getty ti board am4376
================================


swupdate
=========

vi etc/inittab 

S:2345:respawn:/sbin/getty 115200 ttyS0 -n -l /bin/autologin
#S0:12345:respawn:/bin/start_getty 115200 ttyS0 vt102

  vi bin/autologin 
  
#!/bin/sh
exec /bin/login -f root
     
       chmod +x bin/autologin
       reboot  
       
       
       
board bringup auto login pearl ethernet
===========================       
system/getty.target.wants/serial-getty@ttyS0.service       

manual
------
ExecStart=-/sbin/agetty -8 -L %I 115200 $TERM

auto
-------
ExecStart=-/sbin/agetty -a root -8 -L %I 115200 $TERM
 







this is assable code debug print conspet  
=====================================================


	.globl	reset
	.globl	uart_putc
	.globl	save_boot_params_ret
	.type   save_boot_params_ret,%function
#ifdef CONFIG_ARMV7_LPAE
	.global	switch_to_hypervisor_ret
#endif


#if 1
.equ DELAY_COUNT, 0xFFFFFF   /* Define constant for delay count */

delay:
    ldr r0, =DELAY_COUNT     /* Load constant into r1 using ldr */
delay_loop:
    subs r0, r0, #1          /* Subtract 1 from r1 */
    bne delay_loop           /* If r1 is not zero, keep looping */
    bx lr                    /* Return from delay function */
#endif
reset:

#if 1
    mov r0, #'A'              /* Load ASCII value of 'A' into r0 */
    bl uart_putc              /* Call uart_putc function to transmit 'A'*/
    bl delay                  /* Call delay function */
    mov r0, #'B'              /* Load ASCII value of 'B' into r0*/
    bl uart_putc              /* Call uart_putc function to transmit 'B'*/
    bl delay                  /* Call delay function */
    mov r0, #'E'              /* Load ASCII value of 'C' into r0 */
    bl uart_putc              /* Call uart_putc function to transmit 'C'*/
    bl delay                  /* Call delay function */
    mov r0, #'F'              /* Load ASCII value of 'D' into r0 */
    bl uart_putc              /* Call uart_putc function to transmit 'D'*/
    bl delay                  /* Call delay function */
#endif

bl	_main

/* UART function: uart_putc
 Transmits a character via UART0 at address 0x44E09000
*/
uart_putc:
    push {lr}                 /* Save the link register*/
    ldr r1, =0x44E09000       /* Load UART0 base address into r1*/

wait_tx_ready:
    ldr r2, [r1, #0x18]       /* Read UART status register (offset 0x18)*/
    tst r2, #0x20             /* Check TX FIFO empty bit (bit 5)*/
    beq wait_tx_ready         /* If not ready, loop */

    strb r0, [r1, #0x0]       /* Write the character (r0) to UART TX register (offset 0x0)*/

    pop {lr}                  /* Restore the link register*/
    bx lr                     /* Return to the caller */

ENTRY(c_uart_putc)
    push {lr}                 /* Save the link register*/
    ldr r1, =0x44E09000       /* Load UART0 base address into r1*/

wait_tx_ready1:
    ldr r2, [r1, #0x18]       /* Read UART status register (offset 0x18)*/
    tst r2, #0x20             /* Check TX FIFO empty bit (bit 5)*/
    beq wait_tx_ready1         /* If not ready, loop */

    strb r0, [r1, #0x0]       /* Write the character (r0) to UART TX register (offset 0x0)*/

    pop {lr}                  /* Restore the link register*/
    bx lr                     /* Return to the caller */

ENDPROC(c_uart_putc)


================================================================================================================================
early_print in linux early printk.c
-----------------------------------
./kernel/printk/printk.c

1)make menuconfig

Enable the following options:

Kernel hacking  --->

arm Debugging  --->

[*] Kernel low-level debugging functions //via UART

(0x44e09000) physical base address of debug uart   //that address is UART0 0x44E0_9000 0x44E0_9FFF 4KB UART0 Registers 

Enable Low-Level Debugging
==============================


based on kernle vartion 5.4
=============================

extern void printascii(char *);                              // add this

/* Must be called under logbuf_lock. */
int vprintk_store(int facility, int level,
		  const char *dict, size_t dictlen,
		  const char *fmt, va_list args)
{
	static char textbuf[LOG_LINE_MAX];
	char *text = textbuf;
	size_t text_len;
	enum log_flags lflags = 0;

	/*
	 * The printf needs to come first; we need the syslog
	 * prefix which might be passed-in as a parameter.
	 */
	text_len = vscnprintf(text, sizeof(textbuf), fmt, args);

	/* mark and strip a trailing newline */
	if (text_len && text[text_len-1] == '\n') {
		text_len--;
		lflags |= LOG_NEWLINE;
	}

	/* strip kernel syslog prefix and extract log level or control flags */
	if (facility == 0) {
		int kern_level;

		while ((kern_level = printk_get_level(text)) != 0) {
			switch (kern_level) {
			case '0' ... '7':
				if (level == LOGLEVEL_DEFAULT)
					level = kern_level - '0';
				break;
			case 'c':	/* KERN_CONT */
				lflags |= LOG_CONT;
			}

			text_len -= 2;
			text += 2;
		}
	}
printascii(text);                                                                          //add this 
	if (level == LOGLEVEL_DEFAULT)
		level = default_message_loglevel;

	if (dict)
		lflags |= LOG_NEWLINE;

	return log_output(facility, level, lflags,
			  dict, dictlen, text, text_len);
}


based on kernle vartion 5.10 fun name is diff
=============================================

extern void printascii(char *);                              // add this

static u16 printk_sprint(char *text, u16 size, int facility, enum log_flags *lflags,
                         const char *fmt, va_list args)
{
        u16 text_len;

        text_len = vscnprintf(text, size, fmt, args);

        /* Mark and strip a trailing newline. */
        if (text_len && text[text_len - 1] == '\n') {
                text_len--;
                *lflags |= LOG_NEWLINE;
        }

        /* Strip log level and control flags. */
        if (facility == 0) {
                u16 prefix_len;

                prefix_len = parse_prefix(text, NULL, NULL);
                if (prefix_len) {
                        text_len -= prefix_len;
                        memmove(text, text + prefix_len, text_len);
                }
        }
printascii(text);
        return text_len;
}



=====================================================================================================================================================================
am437x custom board
===================

uart consol debug uart 
----------------------
uart0

k25 rx pin 
j24 tx pin

refrance manual
---------------

search under this topic 
------------------------

ARM Cortex-A9 Memory Map
========================
uart0

UART0 0x44E0_9000 0x44E0_9FFF 4KB UART0 Registers



this is debug assable file to c code entery in u-boot 
=====================================================


#define UART0_BASE_ADDR  0x44E09000      // UART0 base address
#define UART_TX_OFFSET   0x00           // Transmit register offset
#define UART_STATUS_OFFSET 0x18         // Status register offset
#define UART_TX_EMPTY    (1 << 5)       // TX FIFO Empty bit (bit 5)

void zdelay()
{
        volatile int index;
        volatile int delay = 0xFFFFF;
        for(index=0; index<delay; index++)
        {
        }
}
// Function to transmit a character via UART0
void zuart_putc(char c) {
    volatile uint32_t *uart_tx_reg = (uint32_t *)(UART0_BASE_ADDR + UART_TX_OFFSET);
    volatile uint32_t *uart_status_reg = (uint32_t *)(UART0_BASE_ADDR + UART_STATUS_OFFSET);

    // Wait until the UART TX FIFO is empty
    while (!(*uart_status_reg & UART_TX_EMPTY)) {
        // Busy wait
    }

    // Write the character to the TX register
    *uart_tx_reg = c;
}

extern void c_uart_putc (char ch);
void board_init_f(ulong dummy)
{
        zdelay();
        zuart_putc('Z');
        zdelay();
        zuart_putc('u');
        zdelay();
        zuart_putc('m');
        zdelay();



git org file 
=================
git restore arch/arm/kernel/head.S
git checkout -- arch/arm/kernel/head.S




/git$ git status
On branch ti-u-boot-2020.01
Your branch is behind 'origin/ti-u-boot-2020.01' by 17 commits, and can be fast-forwarded.
  (use "git pull" to update your local branch)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   arch/arc/lib/bootm.c
	modified:   arch/arm/dts/am437x-gp-evm.dts
	modified:   arch/arm/lib/bootm.c
	modified:   arch/nds32/lib/bootm.c
	modified:   board/ti/am43xx/board.c
	modified:   board/ti/am43xx/mux.c
	modified:   common/spl/spl.c
	modified:   include/configs/am43xx_evm.h
	modified:   include/wdt.h

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	1.sh

no changes added to commit (use "git add" and/or "git commit -a")



  (use "git restore <file>..." to discard changes in working directory)
	modified:   arch/arm/boot/dts/am437x-gp-evm-hdmi.dts
	modified:   arch/arm/boot/dts/am437x-gp-evm.dts
	modified:   arch/arm/kernel/early_printk.c
	modified:   arch/arm/kernel/setup.c
	modified:   drivers/misc/eeprom/Makefile
	modified:   drivers/misc/eeprom/at25.c
	modified:   drivers/net/phy/Makefile
	modified:   drivers/watchdog/Makefile
	modified:   init/main.c
	modified:   kernel/printk/printk.c

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	1
	arch/arm/boot/dts.zip
	arch/arm/boot/dts/am4372.dtsi-org
	arch/arm/configs/tisdk_am437x-evm_defconfig



-==========================================

command line in linux tcp udp test command 
----------------------------------------
TCP protocol
-------------

server

nc -l -p 12345

clint 

nc <server-ip> 12345

then You can type messages in the client terminal, which will be sent to the server.



UDP protocol
-------------

server

nc -u -l -p 12345

clint 

nc -u 192.168.0.141 12345

then You can then type messages in the client terminal, which will be sent to the server.


==============
windose os we need do 

Alternatively, you can temporarily disable the firewall to test if it’s causing the issue:

Open a Command Prompt as Administrator and 

run: netsh advfirewall set allprofiles state off

static ip address 

netsh interface ip set address name="Ethernet" static 192.168.0.10 255.255.255.0 192.168.0.1



spl gpio control mlo MOU
===================

gpio5_9
GPIO number = (5 - 1) * 32 + 9 = 137
gpio 137 
========

in ref manual search GPIO5 u get the base address 

like this
===========
GPIO5 0x4832_2000 0x4832_2FFF 4KB GPIO5 Registers


set 

    *(unsigned int *)0x44e10a3c = 0x08040007;
    *(unsigned int *)0x48322134 = 0xfffffdff;
    *(unsigned int *)0x4832213c = 0x00000200;

control

int ztoggle = 1;
static void spl_wdreset()
{
    if(ztoggle == 0)
    {
        ztoggle = 1;
	*(unsigned int *)0x4832213c = 0x00000000;
    }
    else
    {
        ztoggle = 0;
	*(unsigned int *)0x4832213c = 0x00000200;
    }
}



spl ddr test  common/spl/spl.c  
===============

#define TEST_PATTERN 0xA5A5A5A5
#define DDR_SIZE 0x20000000 // Size of memory to test 512mb

// DDR memory test function
int ddr_read_write_test(uint32_t *ddr_base_addr, size_t size) {
    printf("Starting DDR memory test...\n");

    // Step 1: Write the test pattern to the DDR memory
    for (size_t i = 0; i < size / sizeof(uint32_t); i++) {

        if ((0x81f00000 <= &ddr_base_addr[i]) && (0x82000000 >= &ddr_base_addr[i]))
        {
         if(i%(1024*1024*5)==0)
            printf("Skipping word = %d, addr = %x \r\n",i, &ddr_base_addr[i]);
            continue;
        }
        ddr_base_addr[i] = TEST_PATTERN;
         if(i%(1024*1024*5)==0)
              printf("word = %d, addr = %x \r\n",i, &ddr_base_addr[i]);

    }
    printf("\r\nVerify the test pattern in DDR memory \r\n");
    // Step 2: Verify the test pattern in DDR memory
    for (size_t i = 0; i < size / sizeof(uint32_t); i++) {

        if ((0x81f00000 <= &ddr_base_addr[i]) && (0x82000000 >= &ddr_base_addr[i]))
        {
         if(i%(1024*1024*5)==0)
            printf("Skipping word = %d, addr = %x \r\n",i, &ddr_base_addr[i]);
            continue;
        }

        if (ddr_base_addr[i] != TEST_PATTERN) {
            printf("DDR test failed at address 0x%x. Expected: 0x%x, Got: 0x%x\n",
                   (ddr_base_addr + i), TEST_PATTERN, ddr_base_addr[i]);
            return -1; // Return error on failure
        }
         if(i%(1024*1024*5)==0)
          printf("Reading word = %d, addr = %x \r\n",i, &ddr_base_addr[i]);
    }

    printf("\r\nDDR memory test passed successfully.\n");
    return 0; // Success
}



calling place // boot_from_devices
============== 
       printf("Test DDR\r\n");

       int result = ddr_read_write_test(0x80000000, DDR_SIZE);



static inline bool gpio_is_valid(int number)            // check validity of GPIO number (max on BBB is 127)
static inline int  gpio_request(unsigned gpio, const char *label)        // allocate the GPIO number, the label is for sysfs
static inline int  gpio_export(unsigned gpio, bool direction_may_change) // make available via sysfs and decide if it can change from input to output and vice versa
static inline int  gpio_direction_input(unsigned gpio)  // an input line (as usual, return of 0 is success)
static inline int  gpio_get_value(unsigned gpio)        // get the value of the GPIO line
static inline int  gpio_direction_output(unsigned gpio, int value)       // value is the state
static inline int  gpio_set_debounce(unsigned gpio, unsigned debounce)   // set debounce time in ms (platform dependent)
static inline int  gpio_sysfs_set_active_low(unsigned gpio, int value)   // set active low (invert operation states)
static inline void gpio_unexport(unsigned gpio)         // remove from sysfs
static inline void gpio_free(unsigned gpio)             // deallocate the GPIO line
static inline int  gpio_to_irq(unsigned gpio)           // associate with an IRQ




copy with sympolic link
============================
sudo cp -rL zlib/ /media/zumi/hello/





dcan pins and dts configration am4376
==============================
can


GPIO0[17] c13 rx  = (data sheet) mii1_txd2 dcan0_rx 0x1 search c13  // (ref manual) 920h CTRL_CONF_MII1_TXD2   search this mii1_txd2
GPIO0[16] c16 tx  = (data sheet) mii1_txd3 dcan0_tx 0x1 search c16  // (ref manual) 91Ch CTRL_CONF_MII1_TXD3   search this mii1_txd3


&dcan0 {
        pinctrl-names = "default", "sleep";
        pinctrl-0 = <&dcan0_default>;
        pinctrl-1 = <&dcan0_sleep>;
        status = "okay";
};


&am43xx_pinmux {

  dcan0_default: dcan0_default_pins {
                pinctrl-single,pins = <
                        AM4372_IOPAD(0x91C, PIN_OUTPUT | MUX_MODE1)             /* mii1_txd3.d_can0_tx */
                        AM4372_IOPAD(0x920, PIN_INPUT_PULLUP | MUX_MODE1)       /* mii1_txd2.d_can0_rx */
                >;
        };

        dcan0_sleep: dcan0_sleep_pins {
                pinctrl-single,pins = <
                        AM4372_IOPAD(0x91C, PIN_INPUT_PULLUP | MUX_MODE7)       /* mii1_txd3.gpio0_17 */
                        AM4372_IOPAD(0x920, PIN_INPUT_PULLUP | MUX_MODE7)       /* mii1_txd2.gpio0_16 */
                >;
        };

}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

linux driver led config led control
===================================

dts
===

&pruss1_mdio {
        pinctrl-0 = <&pruss1_mdio_default>;
        pinctrl-names = "default";
        status = "okay";


        reset-delay-us = <100>; /* PHY datasheet states 1uS min */



        pruss1_eth0_phy: ethernet-phy@0 {
                reg = <0>;
                reset-gpios = <&gpio0 29 GPIO_ACTIVE_LOW>;
                rx-internal-delay-ps=<3500>;
                tx-internal-delay-ps=<3500>;
                link-status-phy0= <&gpio4 17 GPIO_ACTIVE_LOW>;
                link-status-phy1= <&gpio4 18 GPIO_ACTIVE_LOW>;
                link-data-phy0= <&gpio4 20 GPIO_ACTIVE_LOW>;
                link-data-phy1= <&gpio4 10 GPIO_ACTIVE_LOW>;
        };

        pruss1_eth1_phy: ethernet-phy@1 {
                reg = <1>;
                reset-gpios = <&gpio1 13 GPIO_ACTIVE_LOW>;
                rx-internal-delay-ps=<3500>;
                tx-internal-delay-ps=<3500>;
                link-status-phy0= <&gpio4 17 GPIO_ACTIVE_LOW>;
                link-status-phy1= <&gpio4 18 GPIO_ACTIVE_LOW>;
                link-data-phy0= <&gpio4 20 GPIO_ACTIVE_LOW>;
                link-data-phy1= <&gpio4 10 GPIO_ACTIVE_LOW>;
        };

};


c-code
======

static int dp83822_of_init(struct phy_device *phydev)
{


#ifdef __LED_STATUS__

	if (0 == read_dts)
	{
            printk("Reading GPIO pin from the DTS %s \r\n", np->name);
            link_status_phy0 = of_get_named_gpio(np, "link-status-phy0", 0);
            link_status_phy1 = of_get_named_gpio(np, "link-status-phy1", 0);
            link_data_phy0 = of_get_named_gpio(np, "link-data-phy0", 0);
            link_data_phy1 = of_get_named_gpio(np, "link-data-phy1", 0);
            printk("Link Phy0 Status GPIO = %d \r\n", link_status_phy0); 
            printk("Link Phy1 Status GPIO = %d \r\n", link_status_phy1); 
            printk("Link Phy0 Data GPIO = %d \r\n", link_data_phy0); 
            printk("Link Phy1 Data GPIO = %d \r\n", link_data_phy1); 


	    devm_gpio_request_one(dev, link_status_phy0,
                                        GPIOF_OUT_INIT_HIGH, "phy0 link status");
	    devm_gpio_request_one(dev, link_status_phy1,
                                        GPIOF_OUT_INIT_HIGH, "phy1 link status");
	    devm_gpio_request_one(dev, link_data_phy0,
                                        GPIOF_OUT_INIT_HIGH, "phy0 data");
	    devm_gpio_request_one(dev, link_data_phy1,
                                        GPIOF_OUT_INIT_HIGH, "phy1 data");
	    read_dts = 1;
	}
#endif	


}

gpio_set_value(link_status_phy0, 1); //on
gpio_set_value(link_status_phy0, 0); //off


---------------------------------------------------------------------------------------------------------------------------------------------------------

kernel file ko moduls sample code compile and run 
===================================================


hello.c
-------
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple Hello World Kernel Module");

static int __init hello_init(void) {
    printk(KERN_INFO "Hello, World! Abinash\n");
    return 0;
}

static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye, World!\n");
}

module_init(hello_init);
module_exit(hello_exit);


Makefile
---------

obj-m += hello.o

all:
	# Use a tab before the make command
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	# Use a tab before the make command
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean


reame.txt
=========

uname -r

check
====
5.4.0-204-generic

sudo apt update
sudo apt install linux-headers-$(uname -r)

ls -l /lib/modules/$(uname -r)/build


running
=======

sudo insmod hello.ko

dmesg | tail -n 10

[INFO] Hello, World!

sudo rmmod hello

dmesg | tail -n 10

[INFO] Goodbye, World!

automatic load from board booting time 
======================================
If you want the module to load automatically at boot, you can copy the .ko file to /lib/modules/$(uname -r)/kernel/ and run:

sudo depmod -a

echo "hello" | sudo tee -a /etc/modules

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------




c code getting error means using trace lib find out 
====================================================


strace -f -e trace=all ./a.out



auto scritp run after login 
==============================

zumi@zumi-pc:~/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/pearl/rootfs$ ls
bin  boot  dev  etc  home  init  lib  linuxrc  media  mnt  proc  run  sbin  sys  tmp  usr  var
zumi@zumi-pc:~/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/pearl/rootfs$ cd home/root/
zumi@zumi-pc:~/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/pearl/rootfs/home/root$ vi .profile 


run without print in app in c code
==================================
client > /dev/null 2>&1 &
a.out  > /dev/null 2>&1 &




linux soure code how to creat user thread succefully working 
============================================================



// Abinash

#include <linux/kthread.h>  // For kernel threads
#include <linux/sched.h>    // For task_struct and related functions
#include <linux/delay.h>    // For msleep

int abi(void);  

static struct task_struct *continuous_task;
static int aa = 0; // Flag to track the execution

/*
 *Function to stop the kernel thread
 */
 void stop_continuous_task(void)
{
    printk("Abinash im task_thread End 1\n");

    if (continuous_task) 
    {
        kthread_stop(continuous_task);
        continuous_task = NULL;
    }

}

/*
 *Kernel thread function
 */
 static int continuous_task_thread(void *data)
{
    static int count = 0;

    while (!kthread_should_stop()) 
    {
        printk("Abinash im continuous_task_thread count %d \n", ++count);

        /*
	 *Stop the task after 10 iterations
         */
	if (count == 10)
            stop_continuous_task();

        msleep(500);  // Sleep for 500 ms to avoid tight loop
    }

    return 0;
}

/*
 *Function to start the kernel thread
 */
int abi(void)
{
    printk("Abinash im task_thread start\n");

    // Create the kernel thread
    if (!continuous_task) {
        continuous_task = kthread_run(continuous_task_thread, NULL, "dp83822_continuous_task");
        if (IS_ERR(continuous_task)) {
            pr_err("Failed to create kernel thread\n");
            return PTR_ERR(continuous_task);
        }
    }

    return 0;
}

this is org linux fun hear control is comming we creat a thread hear 
===================================================================

static int dp83822_read_status(struct phy_device *phydev)
{       
      
	struct dp83822_private *dp83822 = phydev->priv;
	int status = phy_read(phydev, MII_DP83822_PHYSTS);
	int ctrl2;
	int ret;
	static int prev_lstatus[2] = {-1, -1};
	int lstatus = 1;

	if(aa == 0)
	{
	   abi(); // Ensure abi() is only called once
	   aa=1;
	}
}


====================== same like this is u-boot thread fun like =====================

#include <cyclic.h>

unsigned char toggle = 0;

static void cyclic_demo(void *ctx)
{
        //printf("Cyclic Demo \n");
        if(toggle == 0)
        {
                toggle = 1;
                gpio_set_value(137,0);
        }
        else
        {
        toggle = 0;
        gpio_set_value(137,1);
        }
}



int board_init(void)
{
#ifdef __PEARL_ETHERNET__
        struct cyclic_info *cyclic;


 
        cyclic = cyclic_register(cyclic_demo, 1000 * 1000, "cyclic_demo", NULL);
        if (!cyclic)
            printf("PG : Boot Watchdog Reset fail : warning - Board might reset during reprogram \n");


}

=====================================================================================================================================================================================

if you get the one more interface in ifconfig like only 2 ether port is there but 3 interface is showing we need do remove the &mac
-----------------------------------------------------------------------------------------------------------------------------------  

&mac {
	slaves = <1>;
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&cpsw_default>;
	pinctrl-1 = <&cpsw_sleep>;
	status = "okay";
};


===================================================================================================================================================================================


team viewer install command(connect to the client pc application)
===========================



# Download the latest TeamViewer .deb package
wget https://download.teamviewer.com/download/linux/teamviewer_amd64.deb

# Update package lists
sudo apt update

# Install required dependencies
sudo apt install -f -y

# Install TeamViewer
sudo dpkg -i teamviewer_amd64.deb

# Fix missing dependencies if needed
sudo apt --fix-broken install

# Start the TeamViewer daemon
sudo systemctl start teamviewerd

# Enable TeamViewer to start on boot
sudo systemctl enable teamviewerd

# Check TeamViewer status
teamviewer


search and copy the files  .sh  // libxml2
=============================
#!/bin/bash

# Define the destination path
DEST_PATH="/media/zumi/hi/"

# List of required MRP and Ethernet-related .ko files
KO_FILES=(
    "hsr.ko"
    "mrp.ko"
    "llc.ko"
    "stp.ko"
    "bridge.ko"
    "pruss.ko"
    "pru_rproc.ko"
    "irq-pruss-intc.ko"
    "prueth.ko"
    "icss_mii.ko"
    "vxlan.ko"
    "garp.ko"
    "8021q.ko"
)

# Ensure the destination path exists
#mkdir -p "$DEST_PATH"

# Search in the current directory and subdirectories
for file in "${KO_FILES[@]}"; do
    FILE_PATH=$(find . -type f -name "$file" 2>/dev/null)
    
    if [[ -n "$FILE_PATH" ]]; then
        echo "Found: $FILE_PATH"
        cp "$FILE_PATH" "$DEST_PATH"
        echo "Copied $file to $DEST_PATH"
    else
        echo "Not found: $file"
    fi
done

echo "Operation completed."



search the files  .sh   // libxml2*
======================
#!/bin/bash

# List of libraries without version numbers
libs=(
    "cifs-utils"
    "lldpd"
    "golang-runtime"
    "expat"
    "libxml2"
    "mbed_tls"
    "ntp"
    "glibc"
    "systemd"
    "glib"
    "net-snmp"
    "libarchive"
    "elfutils"
    "libpcap"
    "less"
    "openssl"
    "libexif"
    "jvm-hotspot-oracle"
    "vsftpd"
    "zlib"
    "libflac"
    "xz"
    "iperf"
    "libcap"
    "libwebp"
)

# Search for each library
for lib in "${libs[@]}"; do
    echo "Searching for: $lib"
    find . -type f -name "$lib*"
done


search and copy finding files the files  .sh  // libxml2*
================================= 

#!/bin/bash

# Destination folder
DEST_PATH="/home/zumi/hi/"

# List of libraries without version numbers
libs=(
    "cifs-utils"
    "lldpd"
    "golang-runtime"
    "expat"
    "libxml2"
    "mbed_tls"
    "ntp"
    "glibc"
    "glib"
    "net-snmp"
    "libarchive"
    "elfutils"
    "libpcap"
    "less"
    "openssl"
    "libexif"
    "jvm-hotspot-oracle"
    "vsftpd"
    "zlib"
    "libflac"
    "xz"
    "iperf"
    "libcap"
    "libwebp"
)

# Ensure destination exists
mkdir -p "$DEST_PATH"

# Search and copy files
for lib in "${libs[@]}"; do
    echo "Searching for: $lib"
    
    # Find files and copy them directly
    find . -type f -name "$lib*" | while IFS= read -r file; do
        echo "Copying: $file"
        cp "$file" "$DEST_PATH"
    done
done

echo "Search and copy completed."



================================================================================================================================================================================================= 

/*********************************************

#!/bin/bash

SOURCE_FILE="source.txt"    # Change this to your source file
DEST_FILE="destination.txt" # Change this to your destination file

while true; do
    cp "$SOURCE_FILE" "$DEST_FILE"
    sleep 1  # Adjust the sleep time as needed to avoid excessive CPU usage
done

*************************************************/


cpu getting more load 
=======================
top 

echo "0" > /sys/kernel/debug/sched/nohz


above one not working use blowe one in u-boot

fw_setenv bootargs "your_existing_bootargs nohz=off"

 
nohz=off

=============================================
search for this avelable are not
 apt --help
 apt search
 apt show



=====================================
Link:  
https://github.com/microchip-ung/cfm.git  

Inside README.adoc  

Ensure libcfm_netlink.a is Installed  
ls ~/Downloads/cfm-master/build/libcfm_netlink.a  

Install CFM Library System-Wide  
cd ~/Downloads/cfm-master/build  
sudo make install  

Verify Library Installation  
ls /usr/local/lib/libcfm_netlink.a  

Update Library Cache  
sudo ldconfig  

=============================  
MRP Cross Compile  
=============================  

Building and Installing Dependencies for MRP on ARM  

Run the following command:  

sudo apt update && sudo apt install -y \  
    cmake \  
    build-essential \  
    crossbuild-essential-armhf \  
    pkg-config \  
    git \  
    wget \  
    unzip  

Dependencies:  
- libnl (Netlink library)  
- libmnl (Minimal Netlink Library)  
- libev (Event Library)  
- libcfm_netlink (Custom Netlink Library for MRP)  

2.1 Install libnl (Netlink library)  

cd ~/Downloads  
wget https://www.infradead.org/~tgr/libnl/files/libnl-3.2.25.tar.gz  
tar xvf libnl-3.2.25.tar.gz  
cd libnl-3.2.25  

./configure --host=arm-linux-gnueabihf --prefix=/home/zumi/arm-libs/libnl  
make -j$(nproc)  
make install  

2.2 Install libmnl (Minimal Netlink Library)  

cd ~/Downloads  
wget https://netfilter.org/pub/libmnl/libmnl-1.0.5.tar.bz2  
tar xvf libmnl-1.0.5.tar.bz2  
cd libmnl-1.0.5  

./configure --host=arm-linux-gnueabihf --prefix=/home/zumi/arm-libs/libmnl  
make -j$(nproc)  
make install  

2.3 Install libev (Event Library)  

cd ~/Downloads  
wget http://dist.schmorp.de/libev/libev-4.33.tar.gz  
tar xvf libev-4.33.tar.gz  
cd libev-4.33  

./configure --host=arm-linux-gnueabihf --prefix=/home/zumi/arm-libs/libev  
make -j$(nproc)  
make install  



==============  
Build  
==============  

CFM Build  libcfm
=========  =======

https://github.com/microchip-ung/cfm.git  

	cmake .. -DCMAKE_SYSTEM_NAME=Linux \  
         -DCMAKE_SYSTEM_PROCESSOR=arm \  
         -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc \  
         -DCMAKE_PREFIX_PATH="/home/zumi/arm-libs/libnl;/home/zumi/arm-libs/libmnl;/home/zumi/arm-libs/libev"  
    

(or use like this)

cmake .. -DCMAKE_SYSTEM_NAME=Linux -DCMAKE_SYSTEM_PROCESSOR=arm -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc -DCMAKE_PREFIX_PATH="/home/zumi/arm-libs/libnl;/home/zumi/arm-libs/libmnl;/home/zumi/arm-libs/libev"



make -j$(nproc)  



https://github.com/microchip-ung/mrp.git  

MRP Build  
=========  

cmake .. -DCMAKE_SYSTEM_NAME=Linux \  
    -DCMAKE_SYSTEM_PROCESSOR=arm \  
    -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc \  
    -DCMAKE_PREFIX_PATH="/home/zumi/arm-libs/libnl;/home/zumi/arm-libs/libmnl;/home/zumi/arm-libs/libev"  

make -j$(nproc)  

Expected Output:  

[100%] Linking C executable mrp_server  
[100%] Built target mrp_server  

4. Deploy and Run MRP on ARM Target  

4.1 Transfer to ARM Board  

scp mrp_server root@<ARM_IP>:/home/root/  

4.2 Run on ARM  

On the ARM board:  

chmod +x /home/root/mrp_server  
/home/root/mrp_server  

Summary of Steps:  
- Install Required Packages: crossbuild-essential-armhf, cmake, pkg-config, git  
- Download & Compile Dependencies: libnl, libmnl, libev, libcfm_netlink  
- Configure and Compile MRP using CMake and make  
- Deploy and Run on ARM Board  



Runtime Issue:  

./mrp_server: error while loading shared libraries: libev.so.4: cannot open shared object file: No such file or directory  

Check Library:  

zumi@zumi-pc:~/arm-libs/libev/lib$ ls  
libev.a  libev.la  libev.so  libev.so.4  libev.so.4.0.0  

Solution: Copy this library from PC to the board’s lib folder  

--------------------------------  

==============  
Static Build  
==============  



cd ~/Downloads  
git clone https://github.com/thom311/libnl.git  
cd libnl  
autoreconf -iv  
./configure --host=arm-linux-gnueabihf --enable-static --disable-shared  
make -j$(nproc)  
make install DESTDIR=/home/zumi/arm-libs/libnl

cd ~/Downloads  
git clone https://git.netfilter.org/libmnl  
cd libmnl  
autoreconf -iv  
./configure --host=arm-linux-gnueabihf --enable-static --disable-shared  
make -j$(nproc)  
make install DESTDIR=/home/zumi/arm-libs/libmnl  

cd ~/Downloads  

wget http://dist.schmorp.de/libev/Attic/libev-4.33.tar.gz  
tar xvf libev-4.33.tar.gz  
cd libev-4.33  
./configure --host=arm-linux-gnueabihf --enable-static --disable-shared CFLAGS="-static" LDFLAGS="-static -lm"
make -j$(nproc)  
make install DESTDIR=/home/zumi/arm-libs/libev  



'''''''''''

Understanding CFLAGS="-static" and LDFLAGS="-static -lm"

These are environment variables that modify how your program is compiled and linked.

    CFLAGS="-static"
        Forces the compiler to generate code that links only static libraries.
        Example: gcc -static -o my_app my_app.c → Ensures my_app is fully self-contained.

    LDFLAGS="-static -lm"
        -static → Forces the linker to use static libraries (.a files) instead of shared ones (.so).
        -lm → Explicitly links the math library (libm.a), which is required for functions like sin(), cos(), sqrt(), etc.


arm-linux-gnueabihf-gcc: Cross-compiler for ARM architecture.
-o modbus_can: Output file name.
modbus_can.c: Source file.
-I/home/zumi/.../include: Tells the compiler where to find modbus.h and other header files.
-L/home/zumi/.../lib: Tells the linker where to find libmodbus.a or libmodbus.so.
-static: Statically links all libraries (so that the executable does not depend on shared libraries).
-lmodbus: Links against libmodbus.a or libmodbus.so.
-lm: Links against the math library (libm.so or libm.a).


''''''''''''''''''

CFM Build  libcfm
=========  =======

https://github.com/microchip-ung/cfm.git  

cmake .. -DCMAKE_SYSTEM_NAME=Linux \
         -DCMAKE_SYSTEM_PROCESSOR=arm \
         -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc \
         -DCMAKE_PREFIX_PATH="/home/zumi/arm-libs/libnl/usr/local;/home/zumi/arm-libs/libev/usr/local;/home/zumi/arm-libs/libmnl/usr/local" \
         -DCMAKE_EXE_LINKER_FLAGS="-static -lm" \
         -DCMAKE_FIND_LIBRARY_SUFFIXES=".a" \
         -DCMAKE_SKIP_RPATH=TRUE \
         -DCMAKE_C_STANDARD_LIBRARIES="-lm"



make -j$(nproc)  




https://github.com/microchip-ung/mrp.git  

MRP Build  
=========  


cmake .. -DCMAKE_SYSTEM_NAME=Linux \
         -DCMAKE_SYSTEM_PROCESSOR=arm \
         -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc \
         -DCMAKE_PREFIX_PATH="/home/zumi/arm-libs/libnl/usr/local;/home/zumi/arm-libs/libev/usr/local;/home/zumi/arm-libs/libmnl/usr/local" \
         -DCMAKE_EXE_LINKER_FLAGS="-static" \
         -DCMAKE_FIND_LIBRARY_SUFFIXES=".a" \
         -DCMAKE_SKIP_RPATH=TRUE \
         -DCMAKE_C_STANDARD_LIBRARIES="-lm -pthread"


make -j$(nproc)  



backend run
===========

./mrp_server -m -l 7 & 







========================================================================================================================================================================================

Here is the full document in plain text format that you can copy and save:

Understanding Makefile, CMake, and Cross-Compilation



1. Compiling a Simple C Program (Without Makefile)
For small projects, we can compile a C program using a single command.

Example: hello.c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}

Compiling and Running the Program:
gcc hello.c -o hello
./hello

This method works for simple programs but is inefficient for large projects.

2. Using Makefile for Compilation
When a project has multiple source files, manually specifying them every time is inefficient. A Makefile automates the process.

Example: Makefile
CC = gcc
CFLAGS = -Wall -Wextra

all: hello

hello: hello.o
	$(CC) $(CFLAGS) hello.o -o hello

hello.o: hello.c
	$(CC) $(CFLAGS) -c hello.c

clean:
	rm -f hello hello.o

Usage:
To compile the program:
make

To clean the compiled files:
make clean

3. Understanding Makefile Stages (Preprocessor, Compiler, Assembler, Linker)
When compiling a program, the process goes through four stages.

Stage 1: Preprocessing
gcc -E hello.c -o hello.i

Stage 2: Compilation
gcc -S hello.i -o hello.s

Stage 3: Assembly
gcc -c hello.s -o hello.o

Stage 4: Linking
gcc hello.o -o hello

4. Makefile vs. CMake
Makefile is good for simple projects but difficult to manage for large projects. CMake is used for complex projects with cross-platform support.

Example: Basic CMakeLists.txt

cmake_minimum_required(VERSION 3.10)
project(MyProject)

add_executable(myprogram main.c helper.c)

Usage:
mkdir build
cd build
cmake ..
make

5. Cross-Compilation (Building for a Different Architecture)
To compile for another architecture (e.g., ARM):
cmake .. -DCMAKE_SYSTEM_NAME=Linux     -DCMAKE_SYSTEM_PROCESSOR=arm     -DCMAKE_C_COMPILER=arm-linux-gnueabihf-gcc    // board
cmake .. -DCMAKE_SYSTEM_NAME=Linux     -DCMAKE_SYSTEM_PROCESSOR=arm     -DCMAKE_C_COMPILER=gcc                        // pc

To run on the target device:
scp hello_arm user@target:/home/user/
ssh user@target ./hello_arm

6. Summary:
Use Makefile for small projects.
Use CMake for large, cross-platform projects.
Use cross-compilation for embedded systems.



==========================================================================================================================================================================================
verify the output file is dynamically linked are statically linked 

cat hello.c 

#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}

dynamic
=======

gcc hello.c 

file a.out 

a.out: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9f7d4101d70b6eaf2df80ff658b98a6e98df91be, for GNU/Linux 3.2.0, not stripped

ldd a.out 

	linux-vdso.so.1 (0x00007ffcd1309000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd920fb3000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fd9211c8000)



static
======
gcc -static hello.c -o a.out

file a.out 

        a.out: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=9bc19746c15adb148fef6f642ec574fafc2af555, for GNU/Linux 3.2.0, not stripped

ldd a.out 

	not a dynamic executable
 
=================================================================================================================================================================================================
To compile a fully static binary that can run on any system without dependencies


cd ~/Downloads  

wget http://dist.schmorp.de/libev/Attic/libev-4.33.tar.gz  
tar xvf libev-4.33.tar.gz  
cd libev-4.33  
./configure --host=arm-linux-gnueabihf --enable-static --disable-shared CFLAGS="-static" LDFLAGS="-static -lm"
make -j$(nproc)  
make install DESTDIR=/home/zumi/arm-libs/libev


Verify with a Test Program

test_ev.c

#include <ev.h>
#include <stdio.h>

int main() {
    struct ev_loop *loop = ev_default_loop(0);
    printf("Libev Static Test Successful\n");
    return 0;
}

Compile it statically using the built libev.a:


arm-linux-gnueabihf-gcc -o test_ev test_ev.c /home/zumi/arm-libs/libev/usr/local/lib/libev.a -static -lm

root@am437x-evm:~# ./test_ev 
Libev Static Test Successful

without -lm
===========

arm-linux-gnueabihf-gcc -o test_ev test_ev.c /home/zumi/arm-libs/libev/usr/local/lib/libev.a -static 

/usr/lib/gcc-cross/arm-linux-gnueabihf/9/../../../../arm-linux-gnueabihf/bin/ld: /home/zumi/arm-libs/libev/usr/local/lib/libev.a(ev.o): in function `periodic_recalc':
ev.c:(.text+0xba): undefined reference to `floor'
collect2: error: ld returned 1 exit status



pro tips 

nm -u /home/zumi/arm-libs/libev/usr/local/lib/libev.a



================================================================================================================================

mplab install steps in linux
===============================

https://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide#tabs

download linux package 

MPLABX-v6.20-linux-installer.tar  like this 

tar -xvf MPLABX-v6.20-linux-installer.tar

chmod +x MPLABX-v6.20-linux-installer.sh

sudo ./MPLABX-v6.20-linux-installer.sh



after we need do setup



make -f nbproject/Makefile-default.mk
make -f nbproject/Makefile-default.mk SUBPROJECTS= .build-conf
make clean
make -f nbproject/Makefile-default.mk
make -f nbproject/Makefile-default.mk dist/default/production/EnigmaCommsCase.X.production.hex
/opt/microchip/xc8/v3.00/bin/xc8-cc -mcpu=18LF6520 -c -o build/default/production/Eep.o ../Eep.c

	
===========================================


remove this for all .c .h file   string // Enigma Compact

#!/bin/bash

# Find all .c and .h files in current directory and subdirectories
find . -type f \( -name "*.c" -o -name "*.h" \) | while read -r file; do
    # Remove lines that contain "// Enigma Compact"
    sed -i '/\/\/ Enigma Compact/d' "$file"
    echo "Processed: $file"
done

echo "✅ All matching comments removed."
	


==========================================================================================================

Step 1: Verify Linux Kernel Support for MRP
-----------------------------------------------

Your Linux kernel should support MRP (Media Redundancy Protocol). Run:

zcat /proc/config.gz | grep MRP




redraction 
=====================================================
This will capture all outputs, including errors, for analysis.



commants   > log.txt 2>&1
	

gmake
===========================================
	
sudo ln -s /usr/bin/make /usr/bin/gmake


========================================================================================================================================================
mrp quary TI fourm 

https://e2e.ti.com/support/processors-group/processors/f/processors-forum/1475871/am4376-implementing-the-media-redundancy-protocol-mrp-on-am437x


*********************************************************************************************************************************************************************************


To track which line is causing the issue in your projectCreate.sh script
========================================================================
bash -x ./projectCreate.sh AM437x arm profinet_slave_IRT

bash -x ./projectCreate.sh AM437x arm profinet_slave_IRT 2>&1 | tee debug.log


# Enable strict error handling
set -e  # Exit on any error
set -u  # Treat unset variables as an error
set -x  # Print each command before executing (for debugging)

help set

set -o


example script 
----------------
#!/bin/bash

set -e  # Exit on any error
set -u  # Treat unset variables as an error
set -x  # Print each command before executing

echo "Start script..."

# Uncomment the next line to see an error due to an unset variable
# echo "Unset variable test: $UNDEFINED_VAR"

# Uncomment the next line to simulate an error and exit immediately
# false  

echo "This will not print if an error occurs above."



===================================================================================================================================================================
use like this  for tree command

tree

tree -L 2


======================================================================================================================================================
To check which sites your system is accessing and then block/unblock specific ones, follow these
-------------------------------------------------------------------------------------------------

Step 1: Monitor Active Connections  
To see which websites your system is accessing, run:  

```
netstat -tunp | grep ESTABLISHED
```
or  
```
lsof -i -P -n | grep ESTABLISHED
```
If you want to track real-time DNS queries:  

```
sudo tcpdump -i any port 53
```
This will show domain names as they are queried.  

---

Step 2: Extract and List Unique Domains  
Run this to list all accessed domains:  

```
sudo tcpdump -i any -l -nn port 53 | awk '{print $8}' | sort | uniq
```

---

Step 3: Block Sites Using /etc/hosts  
Edit the `/etc/hosts` file:  

```
sudo nano /etc/hosts
```
Add entries like:  

```
127.0.0.1 example.com
127.0.0.1 www.example.com
```
Save and exit, then restart networking:  

```
sudo systemctl restart networking
```

---

Step 4: Block Sites Using iptables  
For a stricter block, use iptables:  

```
sudo iptables -A OUTPUT -p tcp --dport 80 -d example.com -j REJECT
sudo iptables -A OUTPUT -p tcp --dport 443 -d example.com -j REJECT
```
To unblock:  

```
sudo iptables -D OUTPUT -p tcp --dport 80 -d example.com -j REJECT
sudo iptables -D OUTPUT -p tcp --dport 443 -d example.com -j REJECT
```
To save the rules permanently:  

```
sudo iptables-save | sudo tee /etc/iptables.rules
```

---

Step 5: Block Sites Using ufw (Uncomplicated Firewall)  

```
sudo ufw deny out to example.com
```
To unblock:  

```
sudo ufw delete deny out to example.com
```
Check the rules:  

```
sudo ufw status
```

---

This method will allow you to detect, block, and unblock websites efficiently. Let me know if you need a script to automate this!  









========================================================================================================================================================================
To calculate the Round Trip Time (RTT) for a ping request in C,

ping test
-----------

C Code to Calculate Ping RTT
This code:
✅ Sends ICMP Echo Request
✅ Records timestamps
✅ Calculates RTT in milliseconds


gcc -o ping_rtt ping_rtt.c
sudo ./ping_rtt 8.8.8.8


##########################

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/ip_icmp.h>

#define PACKET_SIZE 64

// Function to calculate checksum
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2)
        sum += *buf++;
    if (len == 1)
        sum += *(unsigned char *) buf;

    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <IP_ADDRESS>\n", argv[0]);
        return 1;
    }

    char *target_ip = argv[1];
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0) {
        perror("Socket creation failed");
        return 1;
    }

    struct sockaddr_in target_addr;
    target_addr.sin_family = AF_INET;
    target_addr.sin_addr.s_addr = inet_addr(target_ip);

    struct icmphdr icmp_packet;
    memset(&icmp_packet, 0, sizeof(icmp_packet));
    icmp_packet.type = ICMP_ECHO;
    icmp_packet.un.echo.id = getpid();
    icmp_packet.un.echo.sequence = 1;
    icmp_packet.checksum = checksum(&icmp_packet, sizeof(icmp_packet));

    struct timeval start_time, end_time;

    gettimeofday(&start_time, NULL); // Start time before sending packet

    if (sendto(sockfd, &icmp_packet, sizeof(icmp_packet), 0, 
               (struct sockaddr *)&target_addr, sizeof(target_addr)) < 0) {
        perror("Send failed");
        return 1;
    }

    char buffer[PACKET_SIZE];
    struct sockaddr_in response_addr;
    socklen_t addr_len = sizeof(response_addr);

    if (recvfrom(sockfd, buffer, sizeof(buffer), 0, 
                 (struct sockaddr *)&response_addr, &addr_len) < 0) {
        perror("Receive failed");
        return 1;
    }

    gettimeofday(&end_time, NULL); // End time after receiving reply

    // Calculate RTT in milliseconds
    double rtt = (end_time.tv_sec - start_time.tv_sec) * 1000.0 + 
                 (end_time.tv_usec - start_time.tv_usec) / 1000.0;

    printf("Ping to %s: RTT = %.3f ms\n", target_ip, rtt);

    close(sockfd);
    return 0;
}


===========speed test =============

gcc -o ping_rtt ping_rtt.c
sudo ./ping_rtt 8.8.8.8

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/ip_icmp.h>

#define PACKET_SIZE 64
#define TEST_DURATION 10 // Test duration in seconds

// Function to calculate checksum
unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2)
        sum += *buf++;
    if (len == 1)
        sum += *(unsigned char *) buf;

    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <IP_ADDRESS>\n", argv[0]);
        return 1;
    }

    char *target_ip = argv[1];
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0) {
        perror("Socket creation failed");
        return 1;
    }

    struct sockaddr_in target_addr;
    target_addr.sin_family = AF_INET;
    target_addr.sin_addr.s_addr = inet_addr(target_ip);

    struct timeval start_time, end_time, current_time;
    gettimeofday(&start_time, NULL);

    int packet_count = 0;
    long total_bytes = 0;

    while (1) {
        struct icmphdr icmp_packet;
        memset(&icmp_packet, 0, sizeof(icmp_packet));
        icmp_packet.type = ICMP_ECHO;
        icmp_packet.un.echo.id = getpid();
        icmp_packet.un.echo.sequence = packet_count++;
        icmp_packet.checksum = checksum(&icmp_packet, sizeof(icmp_packet));

        if (sendto(sockfd, &icmp_packet, sizeof(icmp_packet), 0, 
                   (struct sockaddr *)&target_addr, sizeof(target_addr)) < 0) {
            perror("Send failed");
            return 1;
        }

        char buffer[PACKET_SIZE];
        struct sockaddr_in response_addr;
        socklen_t addr_len = sizeof(response_addr);

        if (recvfrom(sockfd, buffer, sizeof(buffer), 0, 
                     (struct sockaddr *)&response_addr, &addr_len) > 0) {
            total_bytes += PACKET_SIZE;
        }

        gettimeofday(&current_time, NULL);
        double elapsed_time = (current_time.tv_sec - start_time.tv_sec) +
                              (current_time.tv_usec - start_time.tv_usec) / 1e6;
        if (elapsed_time >= TEST_DURATION)
            break;
    }

    gettimeofday(&end_time, NULL);
    double total_time = (end_time.tv_sec - start_time.tv_sec) +
                        (end_time.tv_usec - start_time.tv_usec) / 1e6;

    double speed_mbps = (total_bytes / (1024.0 * 1024.0)) / total_time;
    printf("\nTest completed!\n");
    printf("Total Data Transferred: %.2f MB\n", total_bytes / (1024.0 * 1024.0));
    printf("Average Speed: %.2f MB/s\n", speed_mbps);

    close(sockfd);
    return 0;
}


##########################



sudo lynis audit system

lynis audit system 



The National Vulnerability Database (NVD) 

https://nvd.nist.gov/developers/request-an-api-key


API Key: e52ca83d-3a8d-4b54-b193-9e4bab0407d4   



======================================================================

1. HTTPS (HyperText Transfer Protocol Secure)

    Purpose: Secure version of HTTP, used for encrypted communication between a web browser and a server.
    Encryption: Uses SSL/TLS to encrypt data, protecting it from eavesdropping and attacks.
    Port: Default is 443.
    Use Case: Secure website access, online banking, secure API communication.

2. SSH (Secure Shell)

    Purpose: A secure protocol for remote login and command execution on another computer over a network.
    Encryption: Uses public-key cryptography to ensure secure authentication.
    Port: Default is 22.
    Use Case: Remote server management, secure file transfer (via SCP/SFTP).

3. TCP (Transmission Control Protocol)

    Purpose: A connection-oriented protocol that ensures reliable and ordered data transmission.
    Encryption: Not encrypted by default, but can use TLS/SSL.
    Port: Various ports (e.g., 80 for HTTP, 443 for HTTPS).
    Use Case: Web browsing, file transfer, remote login, email communication.

4. UDP (User Datagram Protocol)

    Purpose: A connectionless protocol that allows fast, low-latency data transfer without guaranteeing delivery.
    Encryption: Not encrypted by default. Can use DTLS for encryption.
    Port: Various ports (e.g., 53 for DNS, 123 for NTP).
    Use Case: Live video/audio streaming, DNS queries, gaming, real-time applications.

5. Ethernet

    Purpose: A wired communication protocol used for networking computers in a local area network (LAN).
    Encryption: Not encrypted by default. Can use MACsec for encryption.
    Port: Uses RJ-45 (Ethernet) ports.
    Use Case: Industrial automation, office networking, IoT devices, high-speed data transfer.

6. Wi-Fi (Wireless Fidelity)

    Purpose: A wireless networking technology that allows devices to connect to the internet and communicate over a local network.
    Encryption: Uses WPA2/WPA3 for security.
    Port: Uses IEEE 802.11 standards, does not rely on specific ports.
    Use Case: Wireless internet access, IoT communication, mobile devices, smart home applications.

7. Bluetooth

    Purpose: A short-range wireless communication protocol for exchanging data between devices.
    Encryption: Uses AES encryption in Bluetooth 4.0 and later.
    Port: Does not use specific ports; operates in the 2.4 GHz ISM band.
    Use Case: Wireless audio streaming, file transfer, IoT device communication, wearable technology.

8. USB (Universal Serial Bus)

    Purpose: A wired interface for connecting peripherals like keyboards, storage devices, and embedded systems.
    Encryption: Not encrypted by default.
    Port: USB Type-A, USB Type-C, Micro-USB.
    Use Case: File transfer, charging, debugging embedded devices.

9. UART (Universal Asynchronous Receiver-Transmitter)

    Purpose: A hardware communication protocol for serial data exchange between microcontrollers and peripherals.
    Encryption: Not encrypted.
    Port: Uses RX (Receive) and TX (Transmit) pins.
    Use Case: Debugging, sensor communication, embedded device interfacing.

10. SPI (Serial Peripheral Interface)

    Purpose: A synchronous serial communication protocol for high-speed data transfer between microcontrollers and peripherals.
    Encryption: Not encrypted.
    Port: Uses MISO, MOSI, SCLK, and CS pins.
    Use Case: Sensor communication, memory modules, display controllers.

11. I2C (Inter-Integrated Circuit)

    Purpose: A multi-device communication protocol that allows multiple devices to share a single communication bus.
    Encryption: Not encrypted.
    Port: Uses SDA (data) and SCL (clock) pins.
    Use Case: Sensors, EEPROM, RTC, embedded peripherals.

12. CAN (Controller Area Network)

    Purpose: A robust vehicle and industrial communication protocol designed for real-time data exchange.
    Encryption: Not encrypted, but secure CAN (CANcrypt) is available.
    Port: Uses CAN_H and CAN_L.
    Use Case: Automotive, industrial automation, robotics.

13. MQTT (Message Queuing Telemetry Transport)

    Purpose: A lightweight IoT messaging protocol for efficient machine-to-machine communication.
    Encryption: Uses SSL/TLS for encryption.
    Port: 1883 (default), 8883 (TLS-secured).
    Use Case: IoT communication, smart home automation, remote monitoring.

14. DHCP (Dynamic Host Configuration Protocol)

    Purpose: Assigns IP addresses dynamically to devices on a network.
    Encryption: Not encrypted.
    Port: 67 (server), 68 (client).
    Use Case: Automatic IP assignment in local networks.

15. uDHCP (Micro DHCP)

    Purpose: A lightweight DHCP client/server used in embedded Linux systems.
    Encryption: Not encrypted.
    Port: 67 (server), 68 (client).
    Use Case: Dynamic IP allocation in embedded systems, Linux-based IoT devices.

16. NTP (Network Time Protocol)

    Purpose: Synchronizes the clock of network devices with an accurate time source.
    Encryption: Not encrypted by default, but NTS (Network Time Security) adds encryption.
    Port: 123.
    Use Case: Time synchronization for embedded systems, industrial automation.

17. RTP (Real-time Transport Protocol)

    Purpose: Provides real-time transmission of audio and video over IP networks.
    Encryption: Uses SRTP (Secure RTP) for encryption.
    Port: 16384–32767 (dynamic range).
    Use Case: VoIP, video conferencing, live streaming.

18. PPP (Point-to-Point Protocol)

    Purpose: A communication protocol used for direct data transfer over serial links.
    Encryption: Supports CHAP and PAP for authentication.
    Port: Not port-based, used in serial communication.
    Use Case: Dial-up connections, industrial control systems.

19. Modbus

    Purpose: A serial communication protocol used in industrial automation for transmitting data between devices.
    Encryption: Not encrypted by default, but Modbus Secure adds encryption.
    Port: 502.
    Use Case: PLC communication, SCADA systems, factory automation.

20. WebSocket

    Purpose: Provides full-duplex communication between client and server over a single TCP connection.
    Encryption: Uses WSS (WebSocket Secure) for encryption.
    Port: 80 (ws://), 443 (wss://).
    Use Case: Real-time chat applications, online gaming, IoT control systems.







1. Networking Protocols
1.1 TCP (Transmission Control Protocol)

    Purpose: A reliable, connection-oriented protocol for data transmission.
    Encryption: Not by default; can use TLS for security.
    Port: Varies based on application (e.g., HTTP - 80, HTTPS - 443).
    Use Case: Web browsing, file transfers, emails, and secure communications.

1.2 UDP (User Datagram Protocol)

    Purpose: A connectionless, fast, but unreliable transport protocol.
    Encryption: None by default, but can use DTLS for security.
    Port: Varies by service (e.g., DNS - 53, VoIP - 5060).
    Use Case: Real-time applications like VoIP, video streaming, gaming, and IoT sensor data.

1.3 HTTP (Hypertext Transfer Protocol)

    Purpose: Standard protocol for web communication between clients and servers.
    Encryption: None (use HTTPS for security).
    Port: 80.
    Use Case: Web page loading, APIs, and IoT dashboards.

1.4 HTTPS (Hypertext Transfer Protocol Secure)

    Purpose: Secure version of HTTP using SSL/TLS encryption.
    Encryption: Uses TLS (SSL) for encryption.
    Port: 443.
    Use Case: Secure web applications, online banking, and encrypted IoT communication.

1.5 MQTT (Message Queuing Telemetry Transport)

    Purpose: A lightweight protocol for publish-subscribe communication in IoT.
    Encryption: Can use TLS/SSL.
    Port: 1883 (unsecure), 8883 (secure).
    Use Case: IoT, home automation, real-time data logging.

1.6 DHCP (Dynamic Host Configuration Protocol)

    Purpose: Assigns IP addresses dynamically to devices.
    Encryption: None.
    Port: 67 (server), 68 (client).
    Use Case: Used in routers, embedded systems with dynamic IPs.

1.7 DNS (Domain Name System)

    Purpose: Resolves domain names to IP addresses.
    Encryption: Can use DNS over HTTPS (DoH) or DNS over TLS (DoT).
    Port: 53.
    Use Case: Internet browsing, cloud services, IoT devices accessing remote servers.

1.8 NTP (Network Time Protocol)

    Purpose: Synchronizes clocks of networked devices.
    Encryption: None.
    Port: 123.
    Use Case: IoT sensors, industrial controllers, time-sensitive applications.


3. Wireless Communication Protocols
3.1 Wi-Fi (IEEE 802.11)

    Purpose: Wireless LAN communication.
    Encryption: WPA2, WPA3.
    Frequency: 2.4 GHz / 5 GHz.
    Use Case: IoT, embedded web servers, remote device control.

3.2 Bluetooth (IEEE 802.15.1)

    Purpose: Short-range wireless communication.
    Encryption: AES-CCM (128-bit encryption).
    Range: 10-100m.
    Use Case: Wireless sensors, audio devices, wearable tech.

3.3 Zigbee (IEEE 802.15.4)

    Purpose: Low-power, low-data-rate wireless communication.
    Encryption: AES-128.
    Frequency: 2.4 GHz.
    Use Case: Smart home automation, industrial IoT.

3.4 LoRa (Long Range)

    Purpose: Low-power, long-range communication.
    Encryption: AES-128.
    Frequency: 868 MHz (EU), 915 MHz (US).
    Use Case: Smart agriculture, remote monitoring.

4. Industrial & Specialized Protocols
4.1 Modbus

    Purpose: Communication between industrial devices (RTUs, PLCs).
    Encryption: None (but Modbus TCP can use TLS).
    Port: 502.
    Use Case: Industrial automation, motor control, sensors.

4.2 PROFINET

    Purpose: Ethernet-based industrial automation protocol.
    Encryption: Uses TLS for security.
    Use Case: Factory automation, real-time data exchange.

4.3 EtherCAT

    Purpose: High-speed industrial Ethernet communication.
    Encryption: None by default.
    Use Case: Robotics, CNC machines, real-time control systems.

4.4 EnDat

    Purpose: Digital interface for rotary and linear encoders.
    Encryption: None.
    Use Case: Precision motion control, industrial robotics.

5. Cellular Communication Protocols
5.1 GSM (Global System for Mobile Communications)

    Purpose: Standard for mobile networks.
    Encryption: A5/1, A5/2 encryption.
    Use Case: Embedded systems with cellular connectivity.

5.2 LTE (Long-Term Evolution)

    Purpose: High-speed mobile communication for IoT and embedded systems.
    Encryption: AES encryption.
    Use Case: IoT devices, vehicle telematics, smart city applications.

5.3 NB-IoT (Narrowband IoT)

    Purpose: Low-power, wide-area IoT communication.
    Encryption: 128-bit AES.
    Use Case: Smart metering, asset tracking, remote sensors.
    
    
    
1. Dynamic Host Configuration Protocol (DHCP)
*************************************************


Definition:Dynamic Host Configuration Protocol (DHCP) is a system for assigning Internet Protocol (IP) addresses to each network device (known as a host) on an organization's network. DHCP simplifies network administration by automatically assigning, managing, and reusing IP addresses.

Use Case:DHCP is used in enterprise networks, home networks, and ISPs to dynamically allocate IP addresses to devices, reducing manual configuration efforts.

2. Networking and DHCP Commands

Below is a list of commonly used networking and DHCP commands along with their descriptions and use cases.

2.1 dhclient (DHCP Client)

Definition: Requests an IP address from a DHCP server.
Usage:

dhclient eth0 - Requests an IP for the eth0 interface.

dhclient -r eth0 - Releases the current DHCP lease.

dhclient -v eth0 - Runs in verbose mode for debugging.

dhclient -I eth0 - Requests an IP with a different client identifier.

2.2 dhcpd (DHCP Server Daemon)

Definition: Assigns IP addresses to clients.
Usage:

dhcpd -d - Runs the DHCP server in debug mode.

dhcpd -f - Runs in the foreground instead of as a daemon.

dhcpd -cf /etc/dhcp/dhcpd.conf - Specifies a custom configuration file.

2.3 udhcp (Lightweight DHCP Client & Server)

Definition: A minimal DHCP implementation used in embedded systems.
Usage:

udhcp -S - Starts the DHCP server.

udhcp -q - Runs the DHCP server in quiet mode.

2.4 ifconfig (Deprecated, use ip)

Definition: Displays and configures network interfaces.
Usage:

ifconfig - Shows all active interfaces.

ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up - Assigns an IP.

ifconfig eth0 down - Disables the eth0 interface.

2.5 ip (Modern replacement for ifconfig)

Definition: Displays and modifies network settings.
Usage:

ip addr show - Lists all IP addresses.

ip link set eth0 up - Brings the eth0 interface up.

ip route show - Displays the routing table.

ip addr add 192.168.1.100/24 dev eth0 - Assigns an IP to eth0.

2.6 nmcli (NetworkManager CLI)

Definition: Manages network settings from the command line.
Usage:

nmcli device status - Shows network devices and their status.

nmcli con show - Lists available connections.

nmcli device wifi list - Lists available WiFi networks.

nmcli con up "WiFi_Name" - Connects to a WiFi network.

2.7 route

Definition: Displays and modifies the routing table.
Usage:

route -n - Displays the routing table.

route add default gw 192.168.1.1 - Sets a default gateway.

2.8 arp

Definition: Displays/manages the ARP cache.
Usage:

arp -a - Lists known ARP entries.

arp -d 192.168.1.1 - Deletes an ARP entry.

2.9 ping

Definition: Tests connectivity between devices.
Usage:

ping google.com - Sends ICMP packets to Google.

ping -c 5 google.com - Sends 5 packets and stops.

2.10 traceroute

Definition: Shows the path packets take to a destination.
Usage:

traceroute google.com - Displays the route taken to Google.

2.11 ss (Socket Statistics)

Definition: Displays network connection details.
Usage:

ss -tulnp - Shows listening ports with process details.

ss -s - Displays socket statistics.

2.12 dig

Definition: Queries DNS servers for information.
Usage:

dig google.com - Retrieves DNS records for Google.

2.13 nslookup

Definition: Resolves domain names to IPs.
Usage:

nslookup google.com - Retrieves the IP address of Google.

2.14 tcpdump

Definition: Captures network packets.
Usage:

tcpdump -i eth0 - Captures packets on eth0.

tcpdump -w capture.pcap - Saves captured packets to a file.

2.15 iptables

Definition: Configures firewall rules.
Usage:

iptables -L - Lists firewall rules.

iptables -A INPUT -p tcp --dport 22 -j ACCEPT - Allows SSH.

2.16 iwconfig

Definition: Configures wireless interfaces.
Usage:

iwconfig wlan0 - Displays WiFi settings.

iwconfig wlan0 essid "MyNetwork" - Connects to a specific network.

2.17 wpa_supplicant

Definition: Manages WPA/WPA2 authentication.
Usage:

wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf - Connects to WiFi.    
    
    
    
    
1. dhclient (DHCP Client)

    Definition: Requests an IP address from a DHCP server.
    Use Case: Used when the system needs to obtain a dynamic IP.
    Common Arguments:
        dhclient eth0 → Requests an IP for the eth0 interface.
        dhclient -r eth0 → Releases the current DHCP lease.
        dhclient -v eth0 → Runs in verbose mode for debugging.
        dhclient -I eth0 → Requests an IP with a different client identifier.

2. dhcpd (DHCP Server Daemon)

    Definition: Assigns IP addresses to clients.
    Use Case: Used on Linux servers to act as a DHCP server.
    Common Arguments:
        dhcpd -d → Runs the DHCP server in debug mode.
        dhcpd -f → Runs in the foreground instead of a daemon.
        dhcpd -cf /etc/dhcp/dhcpd.conf → Specifies a custom configuration file.

3. udhcp (Lightweight DHCP Client & Server)

    Definition: A minimal DHCP implementation used in embedded systems.
    Use Case: Used in small Linux devices like routers.
    Common Arguments:
        udhcp -S → Starts the DHCP server.
        udhcp -q → Runs the DHCP server in quiet mode.

4. ifconfig (Deprecated, use ip)

    Definition: Displays and configures network interfaces.
    Use Case: Used to check or assign IP addresses manually.
    Common Arguments:
        ifconfig → Shows all active interfaces.
        ifconfig eth0 192.168.1.100 netmask 255.255.255.0 up → Assigns an IP.
        ifconfig eth0 down → Disables the eth0 interface.

5. ip (Modern replacement for ifconfig)

    Definition: Displays and modifies network settings.
    Use Case: Used for IP configuration, routing, and link management.
    Common Arguments:
        ip addr show → Lists all IP addresses.
        ip link set eth0 up → Brings the eth0 interface up.
        ip route show → Displays the routing table.
        ip addr add 192.168.1.100/24 dev eth0 → Assigns an IP to eth0.

6. nmcli (NetworkManager CLI)

    Definition: Manages network settings from the command line.
    Use Case: Used to configure WiFi, Ethernet, and VPN.
    Common Arguments:
        nmcli device status → Shows network devices and their status.
        nmcli con show → Lists available connections.
        nmcli device wifi list → Lists available WiFi networks.
        nmcli con up "WiFi_Name" → Connects to a WiFi network.

7. nmtui (NetworkManager Text UI)

    Definition: A text-based UI for network configuration.
    Use Case: Used when GUI is unavailable but an easy interface is needed.
    How to Use:
        Run nmtui and navigate with arrow keys.

8. systemctl restart networking

    Definition: Restarts the networking service.
    Use Case: Used after changing network settings.
    Common Arguments:
        systemctl status networking → Checks the networking service status.
        systemctl restart networking → Restarts networking.

9. ethtool

    Definition: Configures Ethernet device settings.
    Use Case: Checks and modifies network interface parameters.
    Common Arguments:
        ethtool eth0 → Shows Ethernet settings for eth0.
        ethtool -s eth0 speed 1000 duplex full → Sets 1Gbps full-duplex.

10. route

    Definition: Displays and modifies the routing table.
    Use Case: Used to set up static routes.
    Common Arguments:
        route -n → Displays the routing table.
        route add default gw 192.168.1.1 → Sets a default gateway.

11. arp

    Definition: Displays/manages the ARP cache.
    Use Case: Used to view and delete ARP entries.
    Common Arguments:
        arp -a → Lists known ARP entries.
        arp -d 192.168.1.1 → Deletes an ARP entry.

12. ping

    Definition: Tests connectivity between devices.
    Use Case: Checks if a remote server is reachable.
    Common Arguments:
        ping google.com → Sends ICMP packets to Google.
        ping -c 5 google.com → Sends 5 packets and stops.

13. traceroute

    Definition: Shows the path packets take to a destination.
    Use Case: Used for diagnosing slow network connections.
    Example: traceroute google.com.

14. ss (Socket Statistics)

    Definition: Displays network connection details.
    Use Case: Checks which ports are open.
    Common Arguments:
        ss -tulnp → Shows listening ports with process details.
        ss -s → Displays socket statistics.

15. dig

    Definition: Queries DNS servers for information.
    Use Case: Used for domain name resolution.
    Example: dig google.com.

16. nslookup

    Definition: Resolves domain names to IPs.
    Use Case: Checks DNS configuration.
    Example: nslookup google.com.

17. tcpdump

    Definition: Captures network packets.
    Use Case: Debugging network traffic.
    Common Arguments:
        tcpdump -i eth0 → Captures packets on eth0.
        tcpdump -w capture.pcap → Saves captured packets to a file.

18. iptables

    Definition: Configures firewall rules.
    Use Case: Allows or blocks network traffic.
    Common Arguments:
        iptables -L → Lists firewall rules.
        iptables -A INPUT -p tcp --dport 22 -j ACCEPT → Allows SSH.

19. firewalld

    Definition: Manages firewall settings dynamically.
    Use Case: Used in modern Linux distributions for firewall management.
    Example: firewall-cmd --list-all.

20. iwconfig

    Definition: Configures wireless interfaces.
    Use Case: Checks WiFi signal strength.
    Example: iwconfig wlan0.

21. wpa_supplicant

    Definition: Manages WPA/WPA2 authentication.
    Use Case: Connects to secured WiFi networks.
    Example:

wpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf



========================================================================================================================================================================



What the Customer is Asking For:

The customer wants a GUI-based control interface over HTTPS and SSH for their Model 6254-SSH using the Lantronix XPort EDGE (or XPort Pro as an alternative).

The GUI should allow:

    Channel Switching:
        Select CH1, CH2, CH3, or CH4 to position "A".
        Select CH1, CH2, CH3, or CH4 to position "B".
        Switch all channels simultaneously to "A" or "B".

    Pushbutton Lockout Control:
        Lock specific channels from responding to pushbuttons.
        Unlock specific channels to allow pushbutton presses.

    Status Query Functions:
        Query the position of each channel (A/B).
        Query lock/unlock status of each channel.
        Query firmware version.

    Lantronix XPort EDGE vs. XPort Pro:
        XPort EDGE: Preferred, but needs HTTPS & SSH programming.
        XPort Pro: Already has HTTPS & SSH but does not work with modern browsers.

    Stable and Future-Proof Solution:
        Must work on modern web browsers like Chrome, Firefox, Edge.

Project Proposal Format (To Provide to Customer)

You need to send the following details:
Phase	Description	Tasks	Deliverables	Modules / Features Supported	Assumptions	Execution Timeline (weeks)	Total Cost (INR, incl. tax)
1	System Analysis & Requirements	Understanding Lantronix XPort EDGE, finalizing architecture	Detailed System Design Document	HTTPS, SSH, GUI	XPort EDGE selected	1 week	₹XXX
2	Firmware & Web Development	Programming HTTPS, SSH, GUI	Working prototype for channel control	Channel switching, Lock/Unlock	Embedded web server	4 weeks	₹XXX
3	Testing & Debugging	Verify browser compatibility	Test Reports	Functionality Validation	Real hardware testing	2 weeks	₹XXX
4	Deployment & Support	Final delivery & Documentation	User Manual, Source Code	Full solution	Customer approval	1 week	₹XXX
Next Steps:

    Confirm whether Lantronix XPort EDGE or XPort Pro is to be used.
    Check if HTTPS/SSH integration on XPort EDGE is feasible.
    Estimate effort and cost.
    Provide the formatted proposal to the customer.


=================================================================================================================

Unit networking.service is masked

Fix the Issue
--------------

1. Check the Status of the Networking Service
 
 systemctl status networking.service


2.Unmask and Restart the Service

 sudo systemctl unmask networking.service
 sudo systemctl enable networking.service
 sudo systemctl restart networking.service


3. Use NetworkManager Instead (For Ubuntu 18.04 and Later)

 sudo systemctl restart NetworkManager

 nmcli device status



after off on pc getting same means final solution is 
------------------------------------------------------

Possible Causes & Solutions

1. Check if NetworkManager and Networking Services Are Enabled on Boot

sudo systemctl is-enabled NetworkManager
sudo systemctl is-enabled networking

If they show disabled, enable them:

sudo systemctl enable NetworkManager
sudo systemctl enable networking


2. Check the Status of Network Services

Run:

sudo systemctl status NetworkManager
sudo systemctl status networking

    If you see errors, share them here.
    If they are inactive (dead), try restarting them:

    sudo systemctl restart NetworkManager
    sudo systemctl restart networking
    
    
LOG:-
======

zumi@zumi-pc:~$ sudo systemctl is-enabled NetworkManager
disabled

zumi@zumi-pc:~$ sudo systemctl is-enabled networking
networking.service is not a native service, redirecting to systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install is-enabled networking
enabled

zumi@zumi-pc:~$ sudo systemctl enable NetworkManager
Created symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service → /lib/systemd/system/NetworkManager.service.
Created symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service → /lib/systemd/system/NetworkManager-dispatcher.service.
Created symlink /etc/systemd/system/network-online.target.wants/NetworkManager-wait-online.service → /lib/systemd/system/NetworkManager-wait-online.service.
zumi@zumi-pc:~$ sudo systemctl status NetworkManager


==========================================================================================================================================================================================

linux app to windows app
------------------------

Steps to Install WSL on Windows

Step 1: Enable WSL

    Open PowerShell as Administrator.
    
    Run the following command:

wsl --install

Step 2: Set Up Linux Distribution

    After rebooting, open Windows Terminal or PowerShell, and type:

wsl


Step 3: Use WSL

    Open a Linux terminal by typing wsl in PowerShell or Command Prompt.
    You can run Linux commands like ls, cd, grep, etc.
    Access Windows files from WSL using:

cd /mnt/c/


after same like linux


==============================================================================================================================================================================================


manually delete leftover configurations:

rm -rf ~/.config/meld ~/.local/share/meld


install meld
------------

sudo apt update
sudo apt upgrade
sudo apt install meld -y

==============================================================================================================================================================================================
duinfo Command in U-Boot
--------------------------
The duinfo command is used in U-Boot to display DRAM (DDR) usage information. It provides details about the memory layout, reserved memory regions, and available free memory.

=> duinfo
Device Usage Information:
Total: 512 MB, Used: 128 MB, Free: 384 MB
Reserved: 64 MB, Kernel: 32 MB


The bdinfo command provides board-specific information, including the U-Boot runtime address.


=> bdinfo
arch_number = 0x00000C42
boot_params = 0x80000100
DRAM bank   = 0x00000000
-> memstart = 0x80000000
-> memsize  = 0x40000000
flashstart  = 0x00000000
flashsize   = 0x00000000
flashoffset = 0x00000000


Checking relocate_code in U-Boot Source Code

In U-Boot source code (arch/arm/lib/crt0.S), look for:


relocate_code:
    ldr r0, =_TEXT_BASE   /* Load base address */


_TEXT_BASE is the address where U-Boot relocates itself in DDR.
For TI AM4376, it is usually 0x80800000 or 0x80000000.

===========================================================================================================================================================================================


board bringup am437x .txt
---------------------------------

kernel/drivers/net/ethernet/ti/prueth.ko: kernel/net/hsr/hsr.ko kernel/drivers/net/ethernet/ti/icss_iep.ko kernel/drivers/soc/ti/pruss.ko kernel/drivers/remoteproc/pru_rproc.ko 


/lib/modules/5.10.100-rt62-g204ec708dc/kernel/drivers/net/ethernet/ti


cp prueth.ko /lib/modules/5.10.100-rt62-g204ec708dc/kernel/drivers/net/ethernet/ti

irq_pruss_intc         16384  0
hsr                    57344  0
icss_iep               24576  0
pru_rproc              24576  0
pruss                  16384  1 pru_rproc



cd /run/media/mmcblk0p1

insmod pruss.ko

rmmod pruss


cd /run/media/mmcblk0p1

insmod hsr.ko

insmod pruss.ko

insmod icss_iep.ko  

insmod pru_rproc.ko

insmod prueth.ko


rmmod hsr

rmmod pruss

rmmod icss_iep

rmmod pru_rproc

rmmod prueth

        
modprobe pru_rproc
modprobe rpmsg_pru


nand flash
=================


fatload mmc 0:0 0x82000000 u-boot-spl.bin
nand write 0x82000000 NAND.SPL 0x2aa74


fatload mmc 0:0 0x82000000 u-boot.bin
nand write 0x82000000 NAND.u-boot 0x2aa74









MLO woring 
============
CONFIG_SPL_TEXT_BASE=0x402F4000

get_dpll_ddr_params


consol uart flash commant
==========================

sx -kb MLO < /dev/ttyUSB2 > /dev/ttyUSB2

sx -kb --ymodem u-boot.img < /dev/ttyUSB2 > /dev/ttyUSB2


sudo ../gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-objdump -d u-boot-spl > z.dis

arch/arm/cpu/armv7/start.S



make as a secure 
==================


this step is make our build is secure
=====================================

wget https://launchpad.net/gcc-arm-embedded/4.7/4.7-2013-q1-update/+download/gcc-arm-none-eabi-4_7-2013q1-20130313-linux.tar.bz2
tar -xjf gcc-arm-none-eabi-4_7-2013q1-20130313-linux.tar.bz2

cd /opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts

export GCC_ARM_NONE_TOOLCHAIN=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/gcc-arm-none-eabi-4_7-2013q1
export TI_SECURE_DEV_PKG=/opt/ti-processor-sdk-linux-am437x-hs-evm-06.03.00.106/board-support/proc-sdk-secdev-am437x-hs-evm-01.06.00.05/scripts/proc-sdk-secdev

./build_secdev.sh


unset GCC_ARM_NONE_TOOLCHAIN
unset TI_SECURE_DEV_PKG




am4376 rebuild command
-----------------------

sudo su

cd /home/zumi/Abinash/am4376_board_bringup_new_project/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI


sudo wget -c https://releases.linaro.org/components/toolchain/binaries/6.5-2018.12/arm-linux-gnueabihf/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz

sudo tar xf gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf.tar.xz

export CC=/home/zumi/Abinash/am4376_board_bringup_new_project/build/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/gcc-linaro-6.5.0-2018.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-



make ARCH=arm CROSS_COMPILE=${CC} distclean
make ARCH=arm CROSS_COMPILE=${CC} am43xx_evm_defconfig
make ARCH=arm CROSS_COMPILE=${CC} -j8

cp spl/u-boot-spl.bin /home/zumi/tftp/mlo_send/1

cp u-boot.bin /home/zumi/tftp/mlo_send/2





evk re-build for u-boot only
=============================

cd /home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/work/am437x_evm-linux-gnueabi/u-boot-ti-staging/1_2020.01+gitAUTOINC+2781231a33-r36/git

export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

make distclean

make am43xx_hs_evm_defconfig

make -j8




make distclean

make am43xx_evm_defconfig

make -j8





Dcan link
=========

https://software-dl.ti.com/processor-sdk-linux/esd/AM437X/08_02_00_24/exports/docs/linux/Foundational_Components/Kernel/Kernel_Drivers/DCAN.html




EIP_DLR_processDLRFrame
========================= 

this function mainting the input fram reciving


setenv ipaddr 192.168.0.100    # Set the IP address of the U-Boot board
setenv netmask 255.255.255.0   # Set the subnet mask
setenv gatewayip 192.168.0.1   # Set the gateway (you can set this to your router's IP, if needed)
setenv serverip 192.168.0.141  # Set the IP address of your Linux PC (as a TFTP server or other service if needed)




setenv ipaddr 192.168.0.100    
setenv netmask 255.255.255.0 
setenv gatewayip 192.168.0.1 
setenv serverip 192.168.0.141  

zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ vim raw/nand_base.c
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ vim raw/nand_base.c
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ 
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ 
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ vim arch/arm/dts/am437x-gp-evm.dts 
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ cd ../../..
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI$ vim arch/arm/dts/am437x-gp-evm.dts 
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI$ cd -
/home/zumi/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ vim arch/arm/dts/am437x-gp-evm.dts 
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ vim raw/nand_base.c
zumi@zumi-pc:~/Abinash/am4376_board_bringup_new_project/build/new/26Aug2024_ISSI_Executables/ti-u-boot-2023.04+gitAUTOINC+d74d0993e2-gd74d0993e2_TI_KEY_ISSI/drivers/mtd/nand$ 




===================================================================================================================================================================================
gedit install command
----------------------
sudo apt install gedit

======================================================================================================================================================================================

pip3 install google-search-results


output like this 
----------------

zumi@zumi-pc:~/Abinash/Vulnerability_Check_rootfs/test_code/test_lib/lib$ python3 1.py 
Enter the library name: libev

🔍 Searching for: libev
🔍 Searching official site: http://software.schmorp.de/pkg/libev.html

✅ Available versions:
1: http://dist.schmorp.de/libev/libev-4.33.tar.gz

👉 Select version number (or 0 to exit): 1

⬇️ Download link: http://dist.schmorp.de/libev/libev-4.33.tar.gz



search download link for library 
=================================

import requests
import re
import sys
from bs4 import BeautifulSoup

# Define known official sources for these libraries
OFFICIAL_SOURCES = {
    "libmnl": "https://netfilter.org/projects/libmnl/",
    "libnl": "https://www.infradead.org/~tgr/libnl/",
    "libev": "http://software.schmorp.de/pkg/libev.html"
}

# Alternative FTP sources to try if the official sites fail
TRUSTED_SITES = [
    "https://netfilter.org/pub/libmnl/",
    "https://www.infradead.org/~tgr/libnl/files/",
    "http://dist.schmorp.de/libev/",
]

# Function to fetch direct download links from official sources
def fetch_official_download_link(library_name):
    if library_name in OFFICIAL_SOURCES:
        print(f"🔍 Searching official site: {OFFICIAL_SOURCES[library_name]}")
        try:
            response = requests.get(OFFICIAL_SOURCES[library_name], timeout=10)
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                links = soup.find_all('a', href=True)
                for link in links:
                    href = link['href']
                    if re.search(r'(\.tar\.gz|\.tar\.bz2|\.zip)$', href):
                        return href if href.startswith("http") else OFFICIAL_SOURCES[library_name].rstrip('/') + '/' + href.lstrip('/')
        except requests.RequestException:
            pass
    return None

# Function to search for the library in trusted sources
def search_download_links(library_name):
    print(f"\n🔍 Searching for: {library_name}")

    # Check the official source first
    official_link = fetch_official_download_link(library_name)
    if official_link:
        print(f"\n✅ Found official download link: {official_link}")
        return

    # Otherwise, search alternative sources
    download_links = []
    for site in TRUSTED_SITES:
        try:
            response = requests.get(site, timeout=10)
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                links = soup.find_all('a', href=True)
                for link in links:
                    href = link['href']
                    if re.search(rf'{library_name}.*(\.tar\.gz|\.tar\.bz2|\.zip)$', href, re.IGNORECASE):
                        full_link = href if href.startswith("http") else site.rstrip('/') + '/' + href.lstrip('/')
                        download_links.append(full_link)
        except requests.RequestException as e:
            print(f"⚠️ Error accessing {site}: {e}")

    # Print results
    if download_links:
        print("\n✅ Available versions:")
        for idx, link in enumerate(download_links, 1):
            print(f"{idx}: {link}")
        try:
            choice = int(input("\n👉 Select version number (or 0 to exit): ")) - 1
            if 0 <= choice < len(download_links):
                print(f"\n⬇️ Download link: {download_links[choice]}")
            else:
                print("\n❌ Invalid selection.")
        except ValueError:
            print("\n❌ Invalid input. Please enter a number.")
    else:
        print("\n❌ No download links found.")

# Main execution
if __name__ == "__main__":
    if len(sys.argv) > 1:
        library_name = sys.argv[1]
    else:
        library_name = input("Enter the library name: ").strip()
    search_download_links(library_name)


--------------------------------------------------------------not impliment fully --------

import requests
import re
from bs4 import BeautifulSoup

# Search sources
SOURCES = {
    "GitHub": "https://github.com/search?q={}",
    "SourceForge": "https://sourceforge.net/projects/{}/files/",
    "Launchpad": "https://launchpad.net/{}",
    "Debian (apt)": "sudo apt install {}",
    "Homebrew (macOS)": "brew install {}",
    "Arch (pacman)": "sudo pacman -S {}",
    "Python (pip)": "pip install {}",
    "NodeJS (npm)": "npm install {}",
}

def search_sourceforge(lib_name):
    url = SOURCES["SourceForge"].format(lib_name)
    page = requests.get(url)
    soup = BeautifulSoup(page.text, 'html.parser')

    links = []
    for a in soup.find_all('a', href=True):
        if any(ext in a['href'] for ext in [".tar.gz", ".zip", ".deb", ".exe"]):
            links.append(url + a['href'])
    
    return links if links else ["No direct download links found."]

def search_github(lib_name):
    url = SOURCES["GitHub"].format(lib_name)
    return [url]  # Direct GitHub search page

def search_launchpad(lib_name):
    url = SOURCES["Launchpad"].format(lib_name)
    return [url]  # Direct Launchpad project page

def search_package_managers(lib_name):
    return [SOURCES[pm].format(lib_name) for pm in ["Debian (apt)", "Homebrew (macOS)", "Arch (pacman)", "Python (pip)", "NodeJS (npm)"]]

def main():
    lib_name = input("Enter the library name: ").strip()
    print(f"\n🔍 Searching for: {lib_name}...\n")
    
    results = {
        "GitHub": search_github(lib_name),
        "SourceForge": search_sourceforge(lib_name),
        "Launchpad": search_launchpad(lib_name),
        "Package Managers": search_package_managers(lib_name)
    }

    # Display results
    index = 1
    options = []
    for source, links in results.items():
        for link in links:
            print(f"[{index}] {source} - {link}")
            options.append(link)
            index += 1

    choice = int(input("\nEnter the number of the source to download: "))
    
    if "github.com" in options[choice - 1]:
        print(f"\n🎯 Run the following command:\n\ngit clone {options[choice - 1]}\n")
    elif options[choice - 1].startswith("sudo") or options[choice - 1].startswith("pip"):
        print(f"\n🎯 Run the following command:\n\n{options[choice - 1]}\n")
    else:
        print(f"\n🎯 Run the following command:\n\nwget {options[choice - 1]}\n")

if __name__ == "__main__":
    main()


======================================================================================================================================================================================

compile all the file like .sys .map .o .i .s
================================================

manual command compile one by one
-------------------

gcc -Wall -Wextra -g -c hello.c -o hello.o
gcc hello.o -lpthread -Wl,-Map,thread.map -o hello
gcc -Wall -Wextra -g -S hello.c -o thread.s
gcc -Wall -Wextra -g -E hello.c -o thread.i
nm hello > thread.sym
objdump -D hello > thread.disasm

makefile Makefile any one ok
==================================================================

CC = gcc
CFLAGS = -Wall -Wextra -g
LDFLAGS = -lpthread -Wl,-Map,obj/thread.map

SRC = hello.c
OBJ_DIR = obj
OBJ = $(OBJ_DIR)/hello.o
EXE = $(OBJ_DIR)/hello

# Create obj directory if it doesn't exist
$(shell mkdir -p $(OBJ_DIR))

all: $(EXE) assembly preprocessed symbols disasm

$(EXE): $(OBJ)
	$(CC) $(OBJ) $(LDFLAGS) -o $@

$(OBJ): $(SRC)
	$(CC) $(CFLAGS) -c $< -o $@

assembly: $(SRC)
	$(CC) $(CFLAGS) -S $< -o $(OBJ_DIR)/thread.s

preprocessed: $(SRC)
	$(CC) $(CFLAGS) -E $< -o $(OBJ_DIR)/thread.i

symbols: $(EXE)
	nm $(EXE) > $(OBJ_DIR)/thread.sym

map: $(EXE)
	cat $(OBJ_DIR)/thread.map

disasm: $(EXE)
	objdump -D $(EXE) > $(OBJ_DIR)/thread.disasm

clean:
	rm -rf $(EXE) $(OBJ_DIR)

-----------------------------------------------------------------------

advance make file linker.lds Helps in customizing memory layout for performance optimization. 
========================================================================================

manual commant compile one by one
===================================

gcc -Wall -Wextra -g -Og -c hello.c -o obj/hello.o
gcc obj/hello.o -lpthread -Wl,-Map,obj/thread.map -T obj/linker.lds -o obj/hello
gcc -Wall -Wextra -g -Og -S hello.c -o obj/thread.s
gcc -Wall -Wextra -g -Og -E hello.c -o obj/thread.i
readelf -S obj/hello > obj/thread.sections
nm obj/hello > obj/thread.sym
readelf -l obj/hello | grep -A 10 "LOAD" > obj/ddr_load.info
objdump -D obj/hello > obj/thread.disasm



MEMORY {
    DDR (rwx) : ORIGIN = 0x80000000, LENGTH = 128M
}

SECTIONS {
    . = ORIGIN(DDR);
    
    .text : {
        *(.text)
        *(.text.*)
    } > DDR

    .rodata : {
        *(.rodata)
        *(.rodata.*)
    } > DDR

    .data : {
        *(.data)
        *(.data.*)
    } > DDR

    .bss : {
        *(.bss)
        *(.bss.*)
    } > DDR

    .init_array : {
        PROVIDE_HIDDEN(__init_array_start = .);
        KEEP(*(.init_array))
        KEEP(*(.ctors))
        PROVIDE_HIDDEN(__init_array_end = .);
    } > DDR

    .fini_array : {
        PROVIDE_HIDDEN(__fini_array_start = .);
        KEEP(*(.fini_array))
        KEEP(*(.dtors))
        PROVIDE_HIDDEN(__fini_array_end = .);
    } > DDR

    .eh_frame : {
        *(.eh_frame)
    } > DDR
}


makefile
========

CC = gcc
CFLAGS = -Wall -Wextra -g -Og
LDFLAGS = -lpthread -Wl,-Map,obj/thread.map -T obj/linker.lds

SRC = hello.c
OBJ_DIR = obj
OBJ = $(OBJ_DIR)/hello.o
EXE = $(OBJ_DIR)/hello

$(shell mkdir -p $(OBJ_DIR))

all: $(EXE) assembly preprocessed sections symbols ddr_info disasm

$(EXE): $(OBJ) $(OBJ_DIR)/linker.lds
	$(CC) $(OBJ) $(LDFLAGS) -o $@

$(OBJ): $(SRC)
	$(CC) $(CFLAGS) -c $< -o $@

assembly: $(SRC)
	$(CC) $(CFLAGS) -S $< -o $(OBJ_DIR)/thread.s

preprocessed: $(SRC)
	$(CC) $(CFLAGS) -E $< -o $(OBJ_DIR)/thread.i

sections: $(EXE)
	readelf -S $(EXE) > $(OBJ_DIR)/thread.sections

symbols: $(EXE)
	nm $(EXE) > $(OBJ_DIR)/thread.sym

ddr_info: $(EXE)
	readelf -l $(EXE) | grep -A 10 "LOAD" > $(OBJ_DIR)/ddr_load.info

disasm: $(EXE)
	objdump -D $(EXE) > $(OBJ_DIR)/thread.disasm

$(OBJ_DIR)/linker.lds:
	echo '$(shell cat linker.lds)' > $@

clean:
	rm -rf $(OBJ_DIR)




example c code

hello.c 
==========

#include <stdio.h>

void abi()
{
    printf("Try programiz Abinash\n");
}

int main() {
    // Write C code here
    printf("Try programiz.pro\n");

    void(*p)();

    p=abi;

   printf("\n%p\n",p);

    p();

    return 0;
}

output
======

./hello 

Try programiz.pro

0x55def2a20169
Try programiz.Abinash




Explanation of Compilation Files
==================================
1. ddr_load.info  
**Purpose:** Contains memory load information, particularly for sections loaded into DDR memory.  
**Why It’s Needed:** Helps analyze how program sections are allocated in memory, which is useful for debugging memory allocation issues.  
**Advantage:**  
- Useful for debugging memory corruption or misalignment issues.  
- Helps check if memory regions are correctly mapped and loaded in DDR.  
- Essential for embedded systems where proper memory segmentation is critical.  

2. hello (Executable File)  
**Purpose:** The final compiled binary executable.  
**Why It’s Needed:** This is the actual program that runs on the system.  
**Advantage:**  
- The output of the build process, which can be executed and tested.  
- Can be debugged using gdb (GNU Debugger) to find runtime errors.  
- If it crashes, analyzing related files (thread.map, thread.sym, etc.) can help locate the issue.  

3. hello.o (Object File)  
**Purpose:** An intermediate file containing compiled code before linking.  
**Why It’s Needed:** This is needed for modular compilation; multiple object files are linked to create the final executable.  
**Advantage:**  
- Faster compilation as only modified source files need recompilation.  
- Helps isolate errors before final linking.  
- Can be analyzed using objdump to check symbol definitions.  

4. linker.lds (Linker Script)  
**Purpose:** Defines how sections like .text, .data, and .bss are mapped in memory.  
**Why It’s Needed:** Ensures that specific code/data is placed in the correct memory region, especially in embedded systems.  
**Advantage:**  
- Crucial for memory-constrained environments.  
- Helps in customizing memory layout for performance optimization.  
- Prevents linker errors due to improper memory assignment.  

5. thread.disasm (Disassembly File)  
**Purpose:** Contains the disassembled machine code of the compiled executable.  
**Why It’s Needed:** Helps understand how the compiler translates high-level code into machine instructions.  
**Advantage:**  
- Useful for debugging assembly-level issues and performance optimizations.  
- Helps analyze generated instructions to detect compiler optimizations.  
- Can be compared against source code to understand inline optimizations.  

6. thread.i (Preprocessed Output File)  
**Purpose:** Contains the preprocessed C source file after macro expansion and header file inclusion.  
**Why It’s Needed:** Helps in debugging preprocessor-related issues like missing headers or macro expansion errors.  
**Advantage:**  
- Identifies macro expansions and #define issues.  
- Helps resolve issues with conditional compilation (#ifdef, #ifndef).  
- Useful for understanding how the compiler interprets macros and includes.  

7. thread.map (Memory Map File)  
**Purpose:** Provides a detailed memory map of the final executable, showing symbols and their locations.  
**Why It’s Needed:** Helps in debugging linking issues, memory overflows, and symbol conflicts.  
**Advantage:**  
- Useful for tracking down undefined references or missing symbols.  
- Helps analyze memory layout and section sizes.  
- Useful in embedded systems where memory optimization is critical.  

8. thread.s (Assembly File)  
**Purpose:** The assembly code generated from the source code before machine code conversion.  
**Why It’s Needed:** Helps analyze how C code translates into assembly.  
**Advantage:**  
- Useful for debugging compiler-generated assembly instructions.  
- Helps optimize code performance by inspecting the generated assembly.  
- Essential for understanding low-level execution and instruction flow.  

9. thread.sections (Section Headers File)  
**Purpose:** Lists the section headers and their sizes in the compiled binary.  
**Why It’s Needed:** Helps in analyzing memory allocation of different segments.  
**Advantage:**  
- Useful in embedded systems to verify memory allocation.  
- Helps detect excessive stack/heap usage or misaligned sections.  
- Aids in diagnosing runtime crashes due to memory misalignment.  

10. thread.sym (Symbol Table File)  
**Purpose:** Contains symbols (functions, variables) with their addresses in the executable.  
**Why It’s Needed:** Helps debug symbol-related issues like missing function definitions.  
**Advantage:**  
- Useful for debugging undefined references or linking issues.  
- Can be used with gdb to analyze function calls and memory addresses.  
- Helps track down segmentation faults and invalid memory accesses.  

### Summary Table  

+---------------+--------------------------+-------------------------------------------+------------------------------------------------------+
| File          | Purpose                  | Why It’s Needed                           |            Advantages                                |
+---------------+--------------------------+-------------------------------------------+------------------------------------------------------+
| ddr_load.info | Memory load details      | Debug memory allocation                   | Fix memory corruption, check DDR mappings            |
| hello         | Executable binary        | Final output                              | Can be debugged, tested, and executed                | 
| hello.o       | Compiled object file     | Intermediate step before linking          | Faster compilation, helps in modular debugging       |
| linker.lds    | Linker script            | Controls memory layout                    | Customizes memory sections, prevents overflow        |
| thread.disasm | Disassembled executable  | Analyze compiler-generated machine code   | Debug instruction-level errors, optimize performance |
| thread.i      | Preprocessed output      | Debug preprocessor issues                 | Fix #define, #include, and macro problems            |
| thread.map    | Memory map of executable | Debug linking issues                      | Check symbol addresses, section sizes                |
| thread.s      | Assembly output          | Understand compiler translation           | Optimize performance, debug at assembly level        |
| thread.sections | Section headers        | Analyze memory segment allocation         | Debug memory layout, fix misalignment issues         |
| thread.sym    | Symbol table             | Debug function and variable addresses     | Locate functions in memory, analyze undefined symbols|
+---------------+--------------------------+-------------------------------------------+------------------------------------------------------+

### How These Files Help in Debugging  
- **If the program crashes at runtime** → Check `thread.map` and `thread.sym` to locate faulty symbols.  
- **If there is a segmentation fault** → Use `gdb` with `hello`, analyze memory sections from `thread.sections`.  
- **If performance is slow** → Check `thread.s` and `thread.disasm` for inefficient assembly code.  
- **If linking errors occur** → Analyze `thread.map` and `linker.lds` for missing symbols or incorrect memory allocations.  
- **If macros or headers are causing issues** → Inspect `thread.i` to see preprocessed output.  




linker.lds Linker Script
========================

### 1. MEMORY Section
```
MEMORY {
    DDR (rwx) : ORIGIN = 0x82000000, LENGTH = 128M
}
```
**What This Does:**
- Defines a memory region named DDR (Dynamic Random Access Memory).
- ORIGIN = 0x82000000 → The starting address in memory where your program will be loaded.
- LENGTH = 128M → The total size of this memory region (128 MB).
- rwx → Read, write, execute permissions.

**Why It's Needed:**
- It ensures that the linker knows where to place the program in memory.
- Embedded systems often have different memory regions (e.g., Flash, RAM), and this script tells the linker where to load specific sections.

### 2. SECTIONS Section
```
SECTIONS {
    . = ORIGIN(DDR);
```
- This sets the starting address of the first section to the beginning of the DDR memory region (0x82000000).

### 3. .text Section (Code Section)
```
    .text : {
        *(.text)
        *(.text.*)
    } > DDR
```
**What This Does:**
- The .text section contains all executable code (functions).
- `*(.text)` → Includes all functions from object files.
- `*(.text.*)` → Includes functions with names like `.text.function_name`.
- `> DDR` → This section is stored in the DDR memory.

**Why It's Needed:**
- This is where the actual machine code resides.
- If there's an issue with function execution, debugging `.text` can help identify misaligned or missing functions.

### 4. .rodata Section (Read-Only Data)
```
    .rodata : {
        *(.rodata)
        *(.rodata.*)
    } > DDR
```
**What This Does:**
- The .rodata section contains read-only data, such as const variables and string literals.
- `*(.rodata)` → Includes all read-only data.
- `*(.rodata.*)` → Includes any sub-sections of .rodata.
- `> DDR` → This section is stored in DDR.

**Why It's Needed:**
- Keeps constants separate from writable data, preventing accidental modifications.
- Helps optimize memory by placing read-only data in ROM if needed.

### 5. .data Section (Initialized Global & Static Variables)
```
    .data : {
        *(.data)
        *(.data.*)
    } > DDR
```
**What This Does:**
- The .data section contains initialized global and static variables.
- `*(.data)` → Includes all initialized variables.
- `*(.data.*)` → Includes sub-sections of .data.
- `> DDR` → Stored in DDR memory.

**Why It's Needed:**
- Ensures that global/static variables are correctly loaded into memory at program startup.
- If a program crashes due to variable corruption, checking `.data` can help.

### 6. .bss Section (Uninitialized Global & Static Variables)
```
    .bss : {
        *(.bss)
        *(.bss.*)
    } > DDR
```
**What This Does:**
- The .bss section holds uninitialized global and static variables.
- `*(.bss)` → Includes all uninitialized variables.
- `*(.bss.*)` → Includes sub-sections of .bss.
- `> DDR` → Stored in DDR.

**Why It's Needed:**
- Variables in .bss are initialized to zero at program startup.
- Reduces binary size since only the size is stored, not actual values.

### 7. .init_array Section (Constructor Functions)
```
    .init_array : {
        PROVIDE_HIDDEN(__init_array_start = .);
        KEEP(*(.init_array))
        KEEP(*(.ctors))
        PROVIDE_HIDDEN(__init_array_end = .);
    } > DDR
```
**What This Does:**
- Stores function pointers for constructors (functions that run before `main()`).
- `KEEP(*(.init_array))` → Ensures that startup functions are not removed by the linker.
- `PROVIDE_HIDDEN(__init_array_start = .);` → Defines a symbol at the start.
- `PROVIDE_HIDDEN(__init_array_end = .);` → Defines a symbol at the end.

**Why It's Needed:**
- Required for C++ programs (constructor execution before `main()`).
- Used for initializing hardware peripherals at startup.

### 8. .fini_array Section (Destructor Functions)
```
    .fini_array : {
        PROVIDE_HIDDEN(__fini_array_start = .);
        KEEP(*(.fini_array))
        KEEP(*(.dtors))
        PROVIDE_HIDDEN(__fini_array_end = .);
    } > DDR
```
**What This Does:**
- Stores function pointers for destructors (functions that run after `main()`).
- `KEEP(*(.fini_array))` → Ensures destructors are preserved.
- `PROVIDE_HIDDEN(__fini_array_start = .);` → Marks the start.
- `PROVIDE_HIDDEN(__fini_array_end = .);` → Marks the end.

**Why It's Needed:**
- Required for C++ programs (destructor execution).
- Used in embedded systems to clean up resources before shutdown.

### 9. .eh_frame Section (Exception Handling)
```
    .eh_frame : {
        *(.eh_frame)
    } > DDR
```
**What This Does:**
- The .eh_frame section contains exception handling information.
- Used for C++ exceptions and stack unwinding.

**Why It's Needed:**
- Required for C++ programs using `try/catch`.
- Needed for debugging with backtraces.

### Final Notes
- This script tells the linker where to place each section in memory.
- If you modify it, you need to consider:
  - **Memory constraints** (ensuring sections fit in DDR).
  - **Execution flow** (placing `.text` and `.data` correctly).
  - **Debugging** (checking `.map` and `.sym` files to verify correctness).



============================================================================================================================================================================================
============================================================================================================================================================================================

search script 
=============

#!/bin/bash

# Define the search directory
SEARCH_DIR="home/zumi/Abinash/AM4376/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm"

# Define the list of libraries to search for
LIBRARIES=(
    "golang-runtime"
    "expat"
    "libxml2"
    "mbed_tls"
    "ntp"
    "glibc"
    "systemd"
    "glib"
    "net-snmp"
    "libarchive"
    "elfutils"
    "libpcap"
    "less"
    "openssl"
    "libexif"
    "jvm-hotspot"
    "vsftpd"
    "zlib"
    "libflac"
    "xz"
    "iperf"
    "libcap"
    "libwebp"
)

# Output file for logging results
LOG_FILE="search_results.txt"
> "$LOG_FILE"  # Clear previous results

# Perform the search
for LIB in "${LIBRARIES[@]}"; do
    echo "Searching for: $LIB" | tee -a "$LOG_FILE"
    find .  -type f -iname "$LIB*" | tee -a "$LOG_FILE"
    echo -e "----------------------------------------------------\n\n" | tee -a "$LOG_FILE"
done

echo "Search completed. Results saved in $LOG_FILE"

======================================================================================================================================================
python vartion change manualy
------------------------------

sudo apt update && sudo apt install python3 python3-pip -y
sudo update-alternatives --config python


pip3 install requests prettytable

wget https://github.com/nexB/scancode-toolkit/releases/download/v32.3.2/scancode-toolkit-v32.3.2_py3.10-linux.tar.gz
tar -xvzf scancode-toolkit-v32.3.2_py3.10-linux.tar.gz
cd scancode-toolkit-v32.3.2
chmod +x scancode



sudo ln -s ~/Abinash/Vulnerability_Check_rootfs/test_code/scancode-toolkit-v32.3.2/scancode /usr/local/bin/scancode


zumi@zumi-pc:~/Abinash/Vulnerability_Check_rootfs/test_code/lib/scancode-toolkit-v32.3.2$ ./scancode --license --json-pp results.json /usr/lib/openssh/


pip3 install cve-bin-tool


python lib uninstall commant
============================

pip3 uninstall cve-bin-tool -y






sudo add-apt-repository ppa:deadsnakes/ppa
sudo apt update
sudo apt install python3.10

sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 1

sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 1
sudo update-alternatives --config python3

scancode -l -c -n 4 --json-pp licenses_report.json lib/

=======================================================================================================================================================================================
=======================================================================================================================================================================================

backtrace Debugging
----------------------

sudo apt update
sudo apt install gdb

sudo apt update
sudo apt install strace


gdb ./chat

strace -f ./chat --verbose


# Advanced Debugging Techniques

## 1. Using gdb (GNU Debugger)
GDB helps debug programs by providing detailed runtime analysis:

```bash
gdb ./chat
```

### Common GDB Commands:
- `run` – Start the program execution.
- `bt` – Show the backtrace if the program crashes.
- `break main` – Set a breakpoint at `main`.
- `continue` – Resume execution after a breakpoint.
- `step` – Step through code line-by-line.
- `next` – Execute the next line but do not step into functions.
- `print variable` – Print the value of a variable.
- `quit` – Exit GDB.

## 2. Using strace for System Call Debugging
`strace` allows tracing system calls made by a program:

```bash
strace -f ./chat --verbose
```

### Common `strace` Options:
- `-f` – Follow child processes.
- `-e trace=open,read,write` – Show only specific system calls.
- `-o output.txt` – Save output to a file.
- `-c` – Summarize system calls and execution time.

(gdb) break my_function       # Break at function start
(gdb) run                     # Run program
(gdb) step                    # Step into function
(gdb) break my_function:10     # Break at line 10 inside function
(gdb) continue                # Continue execution
(gdb) print my_variable        # Print a variable
(gdb) backtrace                # Show function call stack
(gdb) delete 1                 # Remove first breakpoint
(gdb) continue                 # Continue execution

gcc -g 1.c -o modbus_server -lmodbus


===================================================================================================================================================================================
gpt4all  AI ABINASH  
------------------

https://linuxconfig.org/how-to-install-gpt4all-on-ubuntu-debian-linux


ollma ai
=========
curl -fsSL https://ollama.com/install.sh | sh

ollama pull mistral

ollama run mistral


=======================================================================================================================================================================================
python env 
----------

**Setting Up cve-bin-tool in a Virtual Environment**

To avoid modifying your system-wide Python installation, you can install and run `cve-bin-tool` inside a virtual environment. Follow these steps:

---

### **1. Check Available Python Versions**
Run the following commands to check if you have Python 3.8 or newer installed:

python3 --version  
python3.8 --version  
python3.9 --version  
python3.10 --version  

If you have Python 3.8 or newer, use that version. If not, you may need to install a newer Python version manually.

---

### **2. Create a Virtual Environment**
Create a new directory and set up a Python virtual environment inside it:

mkdir ~/cve-tool  
cd ~/cve-tool  
python3.8 -m venv venv  

This creates a virtual environment in `~/cve-tool/venv`.

---

### **3. Activate the Virtual Environment**
Activate the virtual environment using:

source venv/bin/activate  

Your terminal should now display `(venv)`, indicating that the virtual environment is active.

---

### **4. Upgrade Pip and Install cve-bin-tool**
Once inside the virtual environment, update pip and install `cve-bin-tool`:

pip install --upgrade pip  
pip install cve-bin-tool  

---

### **5. Run cve-bin-tool**
After installation, verify that `cve-bin-tool` works by running:

cve-bin-tool --help  

---

### **6. Exit the Virtual Environment**
To exit the virtual environment, simply run:

deactivate  

To use the virtual environment again later, navigate to the directory and reactivate it:

cd ~/cve-tool  
source venv/bin/activate
deactivate  

---

//////////////////////////////

🔹 How It Protects Your System
✅ Isolation: Packages installed inside venv do not interfere with system libraries.
✅ No system modifications: Installing or removing packages inside venv does not touch /usr/lib/python3.X (the system’s default Python path).
✅ Easy cleanup: If something breaks inside venv, you can delete the entire venv folder without harming your OS.

🔹 What Happens If You Delete or Move venv?
If you delete the venv folder, all installed packages inside it are lost.
If you move the venv folder, it might break unless you recreate it (python3.10 -m venv venv).
🔹 Example: Virtual Environment vs. System Python

# Inside venv
(venv) $ which python
/home/zumi/cve-tool/venv/bin/python

# Outside venv
$ which python
/usr/bin/python3
This shows that inside venv, Python is taken from the virtual environment, not the system.

🔥 Summary
Creating & using venv does NOT affect your system’s Python.
It isolates dependencies and makes projects self-contained.
If you mess something up, just delete venv and start fresh.

//////////////////////////////


Manually Install Python 3.10 (Without Upgrading Ubuntu)
----------------------------------------------------------

If you don't want to upgrade, you can manually build Python 3.10 from source.

Step 1: Install Required Dependencies

sudo apt update
sudo apt install -y software-properties-common build-essential \
    libssl-dev libffi-dev python3-dev libsqlite3-dev \
    wget libbz2-dev libreadline-dev libncursesw5-dev \
    libgdbm-dev zlib1g-dev liblzma-dev tk-dev

Step 2: Download and Compile Python 3.10

cd /usr/src
sudo wget https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz
sudo tar xvf Python-3.10.0.tgz
cd Python-3.10.0
sudo ./configure --enable-optimizations
sudo make -j$(nproc)
sudo make altinstall

Step 3: Verify Installation

python3.10 --version

Step 4: Create a Virtual Environment

python3.10 -m venv venv
source venv/bin/activate
Now, try installing cve-bin-tool again:

pip install --upgrade pip
pip install cve-bin-tool

1. Use the JSON Mirror (Faster Downloads)
cve-bin-tool --nvd-json-mirror pngtest

2. Skip Unnecessary Sources
cve-bin-tool --disable-sources gitlab,redhat,osv pngtest

3. Use Cached Data (No Re-Downloading)
cve-bin-tool --offline pngtest


cve-check-tool
*************

https://github.com/clearlinux/cve-check-tool


sudo apt update
sudo apt install build-essential autoconf automake libtool pkg-config libglib2.0-dev libjson-glib-dev libcurl4-gnutls-dev
sudo apt install libxml2-dev
sudo apt-get install check
sudo apt-get install lcov


./autogen.sh
./configure

make


sudo make install




sudo rm /usr/local/bin/cve-check-tool
sudo rm -rf /usr/local/lib/cve-check-tool
sudo rm -rf /usr/local/include/cve-check-tool
sudo rm -rf /usr/local/share/cve-check-tool





Uninstalling Packages Installed with apt-get
===========================================





For packages installed with apt-get, you can simply run:

sudo apt-get remove <package-name>


sudo apt-get remove lcov


sudo apt-get purge lcov


sudo apt-get autoremove





mkdir -p ~/NVDS && cd ~/NVDS

# Download CVE data for recent years
for YEAR in {2002..2025}; do
    FILE="nvdcve-1.1-$YEAR.json.gz"
    URL="https://nvd.nist.gov/feeds/json/cve/1.1/$FILE"
    echo "Downloading: $URL"
    curl -o "$FILE" "$URL"

    # Check if download was successful
    if [ -s "$FILE" ]; then
        echo "Downloaded successfully: $FILE"
    else
        echo "Failed to download: $FILE"
        rm -f "$FILE"
    fi
done

dowload the automatic all the files 
nvdcve-1.1-2002.json.g








==========================================================================================

pip is not working properly so first i removed the pip.
command - sudo apt-get remove python3-pip
	
after that i am uninstalling the pip and removing it completely.
command - sudo pip uninstall pip
	  sudo rm -f /usr/bin/pip
	  sudo rm -f /usr/bin/pip3
	  
now i am newly installing the pip.
command - sudo apt-get install python3-pip

still the issue is not resolved so again i am removing the pip.
command - sudo rm -rf /usr/local/lib/python3.8/dist-packages/pip*
	   sudo rm -rf ~/.local/lib/python3.8/site-packages/pip*
	   sudo rm -f /usr/bin/pip
	   sudo rm -f /usr/bin/pip3
	   
now again installing the pip.
command - sudo apt-get install python3-pip

but it is not showing pip so now i am installing the pip through a python script.
command - curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
	   sudo python3 get-pip.py

now it is present in /usr/local/bin/pip3, i moved it to /usr/bin/pip3
command - sudo ln -s /usr/local/bin/pip3 /usr/bin/pip3
	  sudo ln -s /usr/local/bin/pip /usr/bin/pip
	  sudo apt-get purge python3-pip
	  
now the issue is resolved.


=====================================================================================================================================================================================================
wget http://ftp.gnu.org/gnu/automake/automake-1.16.3.tar.gz

tar -xvzf automake-1.16.3.tar.gz
cd automake-1.16.3
./configure
make
sudo make install



pngtest lib install libcmake
-----------------------

git clone https://github.com/glennrp/libpng.git
cd libpng

./configure
make
sudo make install


high varsion
====================================================================================================================================================================================================

wget https://download.sourceforge.net/libpng/libpng-1.6.43.tar.gz  # Check https://sourceforge.net/projects/libpng/files/ for the latest version
tar -xvzf libpng-1.6.43.tar.gz
cd libpng-1.6.43
./configure --prefix=/usr/local
make -j$(nproc)
sudo make install



Example: Without --prefix vs. With --prefix
Option	Installed Location
No --prefix	/usr/bin, /usr/lib (might overwrite system files)
--prefix=/usr/local	/usr/local/bin, /usr/local/lib (safe, doesn't overwrite system files)
3. What Happens After ./configure --prefix=/usr/local?

After running the command:

./configure --prefix=/usr/local

    It sets up the software to install binaries in /usr/local/bin
    It configures libraries in /usr/local/lib
    It prepares headers in /usr/local/include
    It generates Makefiles so you can run:


--------------------ls cp echo 

wget https://ftp.gnu.org/gnu/coreutils/coreutils-9.4.tar.xz

tar -xf coreutils-9.4.tar.xz
cd coreutils-9.4
./configure
make

sudo make install


./configure --prefix=/home/zumi/lib

make

sudo make install



wget https://www.openssl.org/source/openssl-3.0.12.tar.gz
tar -xf openssl-3.0.12.tar.gz
cd openssl-3.0.12
./config
make
sudo make install

-------------------------------------------------------------	-------same libs old vartion new vartion---------
example 1
**************

with cve examles
================

wget https://zlib.net/fossils/zlib-1.2.11.tar.gz
tar -xf zlib-1.2.11.tar.gz
cd zlib-1.2.11

./configure --prefix=/home/zumi/lib1
make -j8
make install

without cve example 
==================

wget https://zlib.net/zlib-1.3.1.tar.xz
tar -xf zlib-1.3.1.tar.xz
cd zlib-1.3.1

./configure --prefix=/home/zumi/lib
make -j8
make install



example 2
**************

with cve examles
================

wget https://libarchive.org/downloads/libarchive-3.4.2.tar.gz
tar -xf libarchive-3.4.2.tar.gz
cd libarchive-3.4.2

./configure --prefix=/home/zumi/testing_libs/old
make -j8
make install


without cve example  
=======================

wget https://libarchive.org/downloads/libarchive-3.7.6.tar.gz
tar -xf libarchive-3.7.6.tar.gz
cd libarchive-3.7.6


./configure --prefix=/home/zumi/testing_libs/new
make -j8
make install






# Download the source code
wget https://sourceforge.net/projects/expat/files/expat/2.2.9/expat-2.2.9-RENAMED-VULNERABLE-PLEASE-USE-2.4.1-INSTEAD.tar.gz

# Extract the archive
tar -xzf expat-2.2.9-RENAMED-VULNERABLE-PLEASE-USE-2.4.1-INSTEAD.tar.gz

# Navigate to the source directory
cd expat-2.2.9

# Configure the build
./configure --prefix=/home/zumi/testing_libs/expat/old

# Compile the source code
make

# Install the library (requires root privileges)
make install




# Download the source code for version 2.7.0
git clone https://github.com/libexpat/libexpat.git

# Extract the archive
tar -xzf expat-2.7.0.tar.gz

# Navigate to the source directory
cd expat-2.7.0

# Configure the build
./configure --prefix=/home/zumi/testing_libs/expat/new

# Compile the source code
make

# Install the library (requires root privileges)
make install



===================================================================================================================================================================================================
===================================================================================================================================================================================================

If the PC display is not working, but the command line is working, use the following commands:

sudo apt install --reinstall ubuntu-desktop
sudo reboot


sudo systemctl restart gdm


### Fixing APT Update Issues and Display/Terminal Issues

#### **1. Edit sources.list to Use Old Releases**
```bash
sudo vi /etc/apt/sources.list
```

deb [trusted=yes] http://old-releases.ubuntu.com/ubuntu focal main restricted universe multiverse
deb [trusted=yes] http://old-releases.ubuntu.com/ubuntu focal-updates main restricted universe multiverse
deb [trusted=yes] http://old-releases.ubuntu.com/ubuntu focal-security main restricted universe multiverse
deb [trusted=yes] http://old-releases.ubuntu.com/ubuntu focal-backports main restricted universe multiverse
```
Save and exit: `Ctrl + X`, then `Y`, then `Enter`.

#### **2. Clear APT Cache and Fix Missing Packages**
```bash
sudo apt clean
sudo apt update --fix-missing
sudo apt install --reinstall apt python3-apt -y
```

#### **3. Force Update & Upgrade**
```bash
sudo apt update --allow-insecure-repositories
sudo apt upgrade --allow-insecure-repositories -y
```

#### **4. Fix the Missing `apt_pkg` Module**
```bash
sudo apt install --reinstall python3-apt -y
sudo ln -s /usr/lib/python3/dist-packages/apt_pkg.cpython-38-x86_64-linux-gnu.so /usr/lib/python3/dist-packages/apt_pkg.so
```

#### **5. Restart the System**
```bash
sudo reboot
```

#### **6. Fix Display and Terminal Issues**
##### **If GUI Display is Not Working:**
```bash
sudo systemctl restart gdm    # For GNOME (Ubuntu default)
sudo systemctl restart lightdm # For LightDM (older versions, Xfce, Lubuntu)
sudo systemctl restart sddm   # For KDE (Kubuntu)
```

##### **If Terminal Won't Open in GUI:**
Try opening with:
```bash
Ctrl + Alt + T
```
Or manually run:
```bash
xterm &
gnome-terminal &
tilix &
```

##### **If GUI is Completely Broken, Reinstall Ubuntu Desktop:**
```bash
sudo apt update && sudo apt install --reinstall ubuntu-desktop -y
sudo reboot
```

##### **If Terminal Doesn't Work After Reinstalling:**
```bash
dconf reset -f /org/gnome/terminal/
gnome-shell --replace &
```

##### **If All Else Fails, Use Alternative Terminal Applications:**
```bash
sudo apt install tilix xterm konsole -y
tilix &
xterm &
konsole &
```

##### **Final Steps: Ensure All Packages Are Fixed**
```bash
sudo apt --fix-broken install
sudo dpkg --configure -a
sudo apt update && sudo apt upgrade -y
```

##### **Force Restart if Necessary**
```bash
sudo reboot -f
sudo poweroff -f
```

### **Final Notes:**
- If the problem persists, check for disk errors:
```bash
sudo fsck -f /dev/sda
```
- If your network is unstable, try using a wired connection before updating packages.

This guide should help resolve APT update errors, missing repositories, and display/terminal issues!






===================================================================================================================================================================================================
===================================================================================================================================================================================================


### **File Not Retaining Contents After Reboot**

It looks like your name.txt file is not retaining its contents after a reboot. This could be due to several reasons:

### **Possible Causes and Fixes:**

#### **1. File Stored in a Temporary Filesystem (tmpfs)**
- If you are saving name.txt in a directory like /tmp or /run, it will be erased on reboot.
- **Fix:** Store the file in a persistent location like:
  /home/root/name.txt
  /etc/name.txt

#### **2. Filesystem Not Being Written Properly (Write Caching)**
- If your filesystem uses write caching, changes may not be saved if the system shuts down unexpectedly.
- **Fix:** Run sync after writing to flush changes to disk:
  echo "MyName" > /home/root/name.txt
  sync

#### **3. Filesystem is Mounted as Read-Only**
- Check if your filesystem is read-only:
  mount | grep root
- If it is mounted as ro (read-only), changes won’t be saved.
- **Fix:** Remount it as read-write:
  mount -o remount,rw /

#### **4. File Gets Overwritten During Boot**
- If a startup script resets the file during boot, it will lose your changes.
- **Fix:** Check startup scripts in:
  /etc/init.d/
  /etc/rc.local

#### **5. Filesystem is Corrupted or OverlayFS is Enabled**
- If your system uses an overlay filesystem (e.g., for a read-only root), changes won’t persist.
- **Fix:** Store the file in /data/ or a writable partition.

#### **6. Verify and Change File Permissions Before Reboot**
- Just for verification purposes, after editing the file, save and close it.
- **Check if the file contents are still there before rebooting:**
  cat /home/root/name.txt
- **Change file permissions before rebooting to ensure accessibility:**
  chmod 000 /home/root/name.txt

---

### **Next Steps:**
1. **Where are you saving name.txt?**
2. **Check if the file exists after reboot** using:
   ls -l /path/to/name.txt
3. **If it exists but is empty**, try writing it using sync.
4. **If it does not exist**, try a different location like /home/root/.

===================================================================================================================================================================================================
===================================================================================================================================================================================================

open file replace the name  script .sh
======================================

#!/bin/bash

# Check if the user provided a file argument
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <file_path>"
    exit 1
fi

FILE="$1"

# Check if the file exists
if [ ! -f "$FILE" ]; then
    echo "Error: File '$FILE' not found!"
    exit 1
fi

# Replace 'perror' with 'print_error' in the file
sed -i 's/perror/print_error/g' "$FILE"

echo "Successfully replaced 'perror' with 'print_error' in $FILE"



./replace_perror.sh your_file.c


===================================================================================================================================================================================================
===================================================================================================================================================================================================

ABINASH spelling
------------------

To help me understand, I take notes. Please use simple English so I can remember it easily.

In the sentence below, check the spelling and improve it to make it clear and easy for everyone to understand.

In the sentence below, I am sending a request to my manager and HR. I need the sentence to be softer, more genuine, and respectful.

Here is the full document in plain text format(.txt) fixes. I’ve added clear section headers (marked with -----) for better organization that you can copy and save.
Commands are also provided in plain text format. Do not include a copy button—just provide all text in document format. I need a document.

Here is the full document in plain text format(.txt) fixes. I’ve added clear section headers (marked with -----) for better organization that you can copy and save.
Commands are also provided in plain text format. Do not include a copy button—just provide all text in document format. I need a document. Don't want the box, also for commands just give me text format.

This version uses a clean box-style format for better alignment and readability in plain text.

I need to create a proposal document for a client and a project. I will provide an example document to help you understand.

----------------------------------------------------------------------------------------------------


I need a well-structured and professional C file header definition that follows IEEE standards. The header should include details like the file name, a brief description, author information, version, current date, and contact email in a structured format. It should be easy to understand and formatted professionally.

/** 
 *  @file example.c
 *  @brief Implementation of Device-to-PC Communication
 *
 *  This source file provides the complete implementation of communication 
 *  between the embedded device and a remote PC. It includes handling of 
 *  data transmission, protocol management, and error handling.
 *
 *  @version 1.0.0  
 *  @date 2024-02-24  
 *  @author Abinash  
 *  @email abinash@zumisolutions.com  
 *
 *  @copyright Copyright (c) 2024 Zumi Solutions. All rights reserved.
 *
 *  @bug No known bugs.
 */
 
 modify blowe code
 
------------------------------------------------------------------------------------------------------------------
 
Please add meaningful sentences explaining the function below in 3 to 4 lines.

/** @brief example_function
 *
 *  This function reads the device name from the dev.txt file
 *
 *  @param  dev_name : returns the device name
 *
 *
 *  @return length of the device name string
 *
 */

Use curly braces {} on a separate line.

Every // comment in the code should be formatted as follows:

Expected output format:

/*  
 * A4 (440 Hz) for 2 seconds  
 */  
 
 modify blowe fun


===================================================================================================================================================================================================
===================================================================================================================================================================================================

In Linux, file permissions are represented using three-digit octal numbers, where:

- The first digit represents the owner (user).
- The second digit represents the group.
- The third digit represents others (everyone else).

Each digit is a sum of:

- **4 (r)** → Read permission
- **2 (w)** → Write permission
- **1 (x)** → Execute permission

### Explaining 444, 555, and 777:

| Permission | Owner | Group | Others | Meaning |
|------------|--------|-------|--------|-----------|
| **444** | r-- | r-- | r-- | Read-only for all (No write or execute) |
| **555** | r-x | r-x | r-x | Read & execute for all (No write) |
| **777** | rwx | rwx | rwx | Full permissions for all (Read, Write, Execute) |

## Removing Read & Write Permissions:
To remove read (r) and write (w) permissions for specific cases, use `chmod`:

### 1. Remove Read & Write for All (444 → No read/write)
```bash
chmod 000 filename
```
This removes all permissions (read, write, and execute) for everyone.

### 2. Remove Write (w) Only (555 → No write, but can read/execute)
```bash
chmod 555 filename
```
This ensures read & execute only but no writing.

### 3. Remove Read & Write for Owner, Group, and Others (777 → Remove read/write)
```bash
chmod 111 filename
```
This keeps only execute (x) permission.

## Alternative: Using Symbolic Mode (`chmod -rw`)
Instead of octal numbers, you can use symbolic notation:

- **Remove read (r) and write (w) for everyone:**
  ```bash
  chmod a-rw filename
  ```
- **Remove read (r) and write (w) only for owner:**
  ```bash
  chmod u-rw filename
  ```
- **Remove read (r) and write (w) only for group:**
  ```bash
  chmod g-rw filename
  ```
- **Remove read (r) and write (w) only for others:**
  ```bash
  chmod o-rw filename
  ```

Let me know if you need more details!

===========================================================================================================================================================================================================
===========================================================================================================================================================================================================
# Linux System Directories and Their Use Cases

## **Linux Filesystem Overview**

This document provides an in-depth explanation of the Linux filesystem structure, detailing the purpose, subdirectories, and common use cases of each major directory.

---

## **1. Root Directory (`/`)**
- The top-level directory of the Linux filesystem.
- All other directories and files exist under `/`.

---

## **2. Home Directory (`/home`)**
- Stores user-specific files, settings, and personal data.
- Each user has a dedicated subdirectory: `/home/username`.
- Common subdirectories:
  - `.cache/` - Temporary cached data for applications.
  - `.config/` - Configuration files for installed applications.
  - `.local/` - User-specific binaries and application data.
  - `.ssh/` - SSH keys and configuration files.
  - `Documents/`, `Downloads/`, `Music/`, `Pictures/`, `Videos/` - Personal folders for organizing user data.

---

## **3. Boot Directory (`/boot`)**
- Contains files required for booting the system.
- Important files and subdirectories:
  - `vmlinuz` - The Linux kernel.
  - `initrd.img` - Initial RAM disk used during boot.
  - `grub/` - GRUB bootloader configuration files.
  - `config-*` - Kernel configuration files.
  - `System.map-*` - Kernel symbol table.

---

## **4. Binary Directories (`/bin`, `/sbin`, `/usr/bin`, `/usr/sbin`)**
- These directories store essential and system-related executable files:
  - `/bin/` - Essential binaries for all users (e.g., `ls`, `cp`, `mv`, `cat`).
  - `/sbin/` - System administration binaries (e.g., `fsck`, `reboot`).
  - `/usr/bin/` - User-installed applications (e.g., `firefox`, `vim`).
  - `/usr/sbin/` - Non-essential system binaries (e.g., `apache2`, `mysql`).

---

## **5. Device Files (`/dev`)**
- Contains special files that represent hardware devices.
- Common device files:
  - `/dev/sda` - First hard drive.
  - `/dev/tty` - Terminal devices.
  - `/dev/null` - Discards all input.
  - `/dev/zero` - Provides infinite null bytes.
  - `/dev/random` - Random number generator.

---

## **6. System Configuration (`/etc`)**
- Stores system-wide configuration files.
- Important files and directories:
  - `/etc/passwd` - User account information.
  - `/etc/shadow` - Encrypted user passwords.
  - `/etc/fstab` - Filesystem mount configuration.
  - `/etc/network/` - Network settings.
  - `/etc/ssh/` - SSH daemon configuration.

---

## **7. Library Files (`/lib`, `/lib64`, `/usr/lib`)**
- Stores shared libraries required by binaries in `/bin` and `/sbin`.
- `/lib/` - Essential 32-bit libraries.
- `/lib64/` - Essential 64-bit libraries.
- `/usr/lib/` - Libraries for user applications.

---

## **8. Mount Points (`/mnt`, `/media`)**
- `/mnt/` - Temporary mount points for manually mounted filesystems.
- `/media/` - Mount points for removable media (USB drives, CDs, DVDs).

---

## **9. Optional Software (`/opt`)**
- Stores third-party software packages.
- Example: `/opt/google/chrome/` contains Google Chrome installation files.

---

## **10. Process Information (`/proc`)**
- A virtual filesystem that provides real-time system and process information.
- Common files:
  - `/proc/cpuinfo` - CPU details.
  - `/proc/meminfo` - Memory usage.
  - `/proc/[PID]/` - Information about running processes.

---

## **11. Root User Directory (`/root`)**
- The home directory for the `root` user.
- Has elevated permissions compared to `/home/username/`.

---

## **12. Runtime Files (`/run`)**
- Contains temporary files used for system processes.
- Stores PID files, sockets, and other runtime data.

---

## **13. Temporary Files (`/tmp`)**
- Used for temporary file storage.
- Files are typically deleted upon reboot.

---

## **14. User Programs (`/usr`)**
- Contains user applications and data.
- `/usr/local/` - Used for locally installed software.

---

## **15. Variable Data (`/var`)**
- Stores files that change frequently.
- Common subdirectories:
  - `/var/log/` - System logs.
  - `/var/lib/` - Data for system services.
  - `/var/www/` - Web server data.

---

## **16. Swap File (`swapfile`)**
- Used for virtual memory (swap space) to extend RAM.

=============================================================================================================================================================================================================
/bin/sh: 1: flex: not found  means that the flex package is missing.

sudo apt update
sudo apt install -y flex bison libssl-dev bc make gcc



uint8_t buffer_BR_DATA[] =
{
0x01, 0x00,    //data1
0x00, 0x00,    //data2    
0x01, 0x00,    //data3
0x02, 0x00,    //data4
0x01, 0x00,    //data5
0x00, 0x00,    //data6
0x01, 0x00,    //data7
0x96, 0x00,    //data8
0x05, 0x00,    //data9
0x91, 0x00,    //data10
0x0A, 0x00,    //data11
0x03, 0x00,    //data12
0x01, 0x00,    //data13
0x02, 0x00,    //data14
0x04, 0x00,    //data15
0x01, 0x00,    //data16
0x32, 0x00,    //data17
0x30, 0x00,    //data18
0x0A, 0x00,    //data19
0x05, 0x00,    //data20
0x04, 0x00,    //data21
0x06, 0x00,    //data22
0x03, 0x00,    //data23 
0x10, 0x27, 0x00 ,0x00,    //data24 
0xF4, 0x01, 0x00 ,0x00,    //data25
0x01, 0x01    //data26
}



========================================================================================================================================================================================================
========================================================================================================================================================================================================
crc 8
-----

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// Polynomial for CRC-8 (CRC-8-CCITT: x^8 + x^2 + x^1 + 1 -> 0x07)
#define CRC8_POLY 0x07

// Function to calculate CRC-8 over the first 6 bytes
uint8_t calculate_crc8(uint8_t *data) {
    uint8_t crc = 0x00;
    for (int i = 0; i < 6; i++) {
        crc ^= data[i];  // XOR with byte
        for (int j = 0; j < 8; j++) {
            if (crc & 0x80) 
                crc = (crc << 1) ^ CRC8_POLY;
            else 
                crc <<= 1;
        }
    }
    return crc;
}

// Function to set CRC-8 in the last byte of the array
void set_crc8(uint8_t *frame) {
    frame[6] = calculate_crc8(frame);
}

// Function to verify CRC-8
void verify_crc8(uint8_t *frame) {
    uint8_t calculated_crc = calculate_crc8(frame);
    if (calculated_crc != frame[6]) {
        printf("CRC-8 error! Exiting...\n");
        exit(EXIT_FAILURE);
    } else {
        printf("CRC-8 is valid.\n");
    }
}

// Example usage
int main() {
    uint8_t example_frame[7] = {0x05, 0x0A, 0x00, 0x03, 0x00, 0x01, 0x00};  // Last byte is CRC

    // Compute and set CRC
    set_crc8(example_frame);

    printf("Updated frame with CRC-8: ");
    for (int i = 0; i < 7; i++) {
        printf("%02X ", example_frame[i]);
    }
    printf("\n");

    // Verify CRC
    verify_crc8(example_frame);

    return 0;
}

========================================================================================================================================================================================================
========================================================================================================================================================================================================
crc16
-----

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// Polynomial for CRC-16 (MODBUS)
#define CRC_POLY 0xA001

// Function to calculate CRC-16 over the first 6 bytes
uint16_t calculate_crc16(uint8_t *data) {
    uint16_t crc = 0xFFFF;
    for (int i = 0; i < 6; i++) {
        crc ^= data[i];  // XOR with byte
        for (int j = 0; j < 8; j++) {
            if (crc & 1)
                crc = (crc >> 1) ^ CRC_POLY;
            else
                crc >>= 1;
        }
    }
    return crc;
}

// Function to set CRC in the last 2 bytes of the array
void set_crc(uint8_t *frame) {
    uint16_t crc = calculate_crc16(frame);
    frame[6] = (crc >> 8) & 0xFF;  // High byte
    frame[7] = crc & 0xFF;         // Low byte
}

// Function to verify CRC by comparing calculated and received CRC
void verify_crc16(uint8_t *frame) {
    uint16_t calculated_crc = calculate_crc16(frame);
    uint16_t received_crc = (frame[6] << 8) | frame[7];  // Extract CRC from frame

    if (calculated_crc != received_crc) {
        printf("CRC error! Exiting...\n");
        exit(EXIT_FAILURE);
    } else {
        printf("CRC is valid.\n");
    }
}

// Example usage
int main() {
    uint8_t example_frame[8] = {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};  // Initial frame with empty CRC

    // Compute and set CRC
    set_crc(example_frame);

    printf("Updated frame with CRC: ");
    for (int i = 0; i < 8; i++) {
        printf("%02X ", example_frame[i]);
    }
    printf("\n");
    
    // Verify CRC
    verify_crc16(example_frame);

    return 0;
}

========================================================================================================================================================================================================
========================================================================================================================================================================================================
crc32
-----
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// Polynomial for CRC-32 (Ethernet CRC-32: 0x04C11DB7)
#define CRC32_POLY 0x04C11DB7

// Function to calculate CRC-32 over the first 6 bytes
uint32_t calculate_crc32(uint8_t *data) {
    uint32_t crc = 0xFFFFFFFF;
    for (int i = 0; i < 6; i++) {
        crc ^= (uint32_t)data[i] << 24;
        for (int j = 0; j < 8; j++) {
            if (crc & 0x80000000) 
                crc = (crc << 1) ^ CRC32_POLY;
            else 
                crc <<= 1;
        }
    }
    return crc ^ 0xFFFFFFFF; // Final XOR
}

// Function to set CRC-32 in the last 4 bytes of the array
void set_crc32(uint8_t *frame) {
    uint32_t crc = calculate_crc32(frame);
    frame[6] = (crc >> 24) & 0xFF;
    frame[7] = (crc >> 16) & 0xFF;
    frame[8] = (crc >> 8) & 0xFF;
    frame[9] = crc & 0xFF;
}

// Function to verify CRC-32
void verify_crc32(uint8_t *frame) {
    uint32_t calculated_crc = calculate_crc32(frame);
    uint32_t received_crc = (frame[6] << 24) | (frame[7] << 16) | (frame[8] << 8) | frame[9];

    if (calculated_crc != received_crc) {
        printf("CRC-32 error! Exiting...\n");
        exit(EXIT_FAILURE);
    } else {
        printf("CRC-32 is valid.\n");
    }
}

// Example usage
int main() {
    uint8_t example_frame[10] = {0x05, 0x0A, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}; // Last 4 bytes for CRC

    // Compute and set CRC
    set_crc32(example_frame);

    printf("Updated frame with CRC-32: ");
    for (int i = 0; i < 10; i++) {
        printf("%02X ", example_frame[i]);
    }
    printf("\n");

    // Verify CRC
    verify_crc32(example_frame);

    return 0;
}

========================================================================================================================================================================================================
========================================================================================================================================================================================================
can am437x setup
================


canDo application run complier:
-===============================
sudo apt install libusb-1.0-0-devRead BMCR Reg:


https://software-dl.ti.com/processor-sdk-linux/esd/AM437X/08_02_00_24/exports/docs/linux/Foundational_Components/Kernel/Kernel_Drivers/DCAN.html

if getting any error we need do add ipr

insmod can.ko
sleep 0.5
insmod can-raw.ko
sleep 0.5
insmod can-gw.ko  
sleep 0.5
insmod can-bcm.ko
sleep 0.5
insmod can-dev.ko
sleep 0.5
insmod c_can.ko 
sleep 0.5
insmod c_can_platform.ko
sleep 0.5



ip link set can0 type can bitrate 50000

ip link set can0 up

cansend can0 123#DEADBEEF


ip link set can0 down
ip link set can0 type can bitrate 125000
ip link set can0 up
candump can0 &
cansend can0 123#DEADBEEF

=============================================================================================================================================================================================

Failed to fetch https://static.nvd.nist.gov/feeds/xml/cve/nvdcve-2.0-2002.meta

 ping -c 4 static.nvd.nist.gov

=============================================================================================================================================================================================
Password-Protect a Folder Using a ZIP Archive
--------------------------------------------

sudo apt update
sudo apt install zip unzip

1)Create a password-protected ZIP archive:

zip -er workspase_protected.zip /home/zumi/Abinash/workspase

2)Delete the original folder (optional):

rm -r /home/zumi/Abinash/workspase

3)Access the folder:

unzip workspase_protected.zip






=============================================================================================================================================================================================
cpu details:- 
===========
Alpha: 64-bit RISC from DEC, used in servers and scientific computing.

ARC: Configurable RISC for embedded applications like automotive and storage.

ARM64: 64-bit ARM for mobile, embedded, and server applications (e.g., smartphones, Raspberry Pi).

C6x: TI's DSP architecture for digital signal processing in audio and video applications.

C-SKY: Chinese RISC for embedded and IoT devices.

H8300: Renesas microcontroller for industrial automation and consumer electronics.

Hexagon: Qualcomm’s DSP for mobile devices, particularly Snapdragon SoCs.

IA64: Intel Itanium, used in enterprise servers and high-performance computing.

M68k: Motorola 68k, widely used in early computers like the Amiga and industrial systems.

MicroBlaze: Xilinx FPGA soft processor for embedded applications.

MIPS: RISC architecture for embedded systems, networking, and routers.

NDS32: AndeStar 32-bit RISC for low-power embedded applications.

NIOS2: Altera FPGA soft processor used in custom embedded designs.

OpenRISC: Open-source RISC for educational, research, and embedded applications.

PARISC: HP's PA-RISC for enterprise servers and workstations.

PowerPC: RISC by IBM, used in aerospace, automotive, and legacy Macs.

RISC-V: Open-source RISC for embedded systems, IoT, and academic research.

S390: IBM's mainframe architecture for enterprise-level applications.

SH: SuperH from Renesas for automotive and industrial control.

SPARC: Scalable RISC from Sun Microsystems for enterprise servers.

UM: User Mode Linux for running Linux within a Linux host for testing and development.

X86: Intel/AMD architecture for desktops, laptops, and servers.

Xtensa: Configurable processor from Cadence for DSP and AI applications, often used in audio and voice processing.

==========================================================================================================================================================================================
Board booting time reducing
===========================


u-boot autoboot delay we need de increase are reduses we need do inlcude the 

configs/am43xx_evm_defconfig   include CONFIG_BOOTDELAY=100 you get output 100 sec delay 

confermation you check the .config file in current build folder 

#
# Autoboot options
#
CONFIG_AUTOBOOT=y
CONFIG_BOOTDELAY=2



its off the logs in kernel boot
===============================

before build include/configs/am43xx_evm.h we need do edit this file 

=> printenv nandargs 
nandargs=setenv bootargs console=${console} ${optargs} root=${nandroot} rootfstype=${nandrootfstype} quiet loglevel=3 



we will enalbe for temperary  use
 
sysctl -w kernel.printk="8 4 1 7"

echo "kernel.printk=8 4 1 7" >> /etc/sysctl.conf
sysctl -p


========================================================
systemd
=========

Enable Manually
Open the inittab file located in the /etc/inittab directory.

You will find a line similar to:

si::sysinit:/etc/init.d/rcS
Add one more line below it to include your script:


s1::sysinit:/etc/init.d/moduls.sh                                                 //this is your script 
Then create a UBI (Unsorted Block Image) for it to work during the system boot.


=======================================
#!/bin/sh

# Function to load a module if it exists
load_module() {
    if [ -f "/lib/modules/$1.ko" ]; then
        insmod /lib/modules/$1.ko
        echo "Loaded module: $1"
    else
        echo "Warning: Module $1 not found."
    fi
}

# Load CAN related modules
for module in can can-raw can-gw can-bcm can-dev c_can c_can_platform; do
    load_module "$module"
done

# Load other modules
for module in hsr pruss pru_rproc icss_iep irq-pruss-intc llc stp bridge prueth at25; do
    load_module "$module"
done

# Bring up network interfaces if they exist
if ip link show eth0 >/dev/null 2>&1; then
    ifconfig eth0 up && echo "eth0 brought up successfully." || echo "Failed to bring up eth0."
    dhclient eth0 &
else
    echo "Warning: eth0 not found."
fi

if ip link show eth1 >/dev/null 2>&1; then
    ifconfig eth1 up && echo "eth1 brought up successfully." || echo "Failed to bring up eth1."
    dhclient eth1 &
else
    echo "Warning: eth1 not found."
fi

echo "All applicable modules loaded and network interfaces checked."




================================


The board's booting time is optimized for Ethernet using the TISDK base image. Everything works fine with the base image, but when using the tiny rootfs, Ethernet doesn't work. The tiny rootfs has Ethernet firmware, but there seems to be an issue. We copied the firmware from the TISDK base image to the tiny rootfs, and now it works

working file sha256
===================

982b06f019f57d2a46a84546eb4a8994226f44bfbddaee58814597bdc5dd751b  am437x-pru0-prueth-fw.elf
7d3b9d45aa8939995e6e4f7ae4710b6b269787bfe621407f08696b99cf121687  am437x-pru1-prueth-fw.elf

small board am437x nand512 pearl ethernet 
*****************************************

1)
sudo apt update
sudo apt install mtd-utils

2)file name ubinize.cfg
=======================

[ubifs]
mode=ubi
image=rootfs.ubifs
vol_id=0
vol_size=483MiB
vol_type=dynamic
vol_name=rootfs
vol_alignment=1
vol_flags=autoresize

3)
sudo mkfs.ubifs -r /home/zumi/Karthi/yocto_build_am437x/tisdk/build/arago-tmp-external-arm-glibc/deploy/images/am437x-evm/tisdk-tiny-image/rootfs -o rootfs.ubifs -F -m 2048 -e 126976 -c 3932
sudo ubinize -o rootfs.ubi -m 2048 -p 128KiB -s 512 -O 2048 ubinize.cfg


./meta-arago-distro/recipes-core/images/tisdk-tiny-image.bb

Confirm Availability:
--------------------
MACHINE=am437x-evm bitbake-layers show-recipes bridge-utils



ARAGO_SYSVINIT = "1"

require arago-image.inc

IMAGE_FEATURES_remove = "package-management splash"

IMAGE_FSTYPES += "cpio cpio.xz"

ARAGO_TINY_IMAGE_EXTRA_INSTALL ?= ""

IMAGE_INSTALL = " \
    packagegroup-arago-sysvinit-boot \
    dhcp-client \
    net-snmp \
    iproute2 \
    can-utils \
    openssh-scp \
    openssh-ssh \
    bridge-utils \
    mstpd \
    ${ARAGO_TINY_IMAGE_EXTRA_INSTALL} \
"


deltask do_packagedata

export IMAGE_BASENAME = "tisdk-tiny-image"



visual studio install
========================================================================================================================================================================================

sudo snap install code --classic

code

sudo snap remove code


==========================================================================================

linux soure web link
======================

https://www.kernel.org/


Recommendation for AM437x Board

    Since you're using an embedded system (AM437x) and want stability without CVEs, I recommend:

        Longterm 6.6.84 — Good balance between security updates and compatibility.

        Longterm 6.1.131 — Another solid choice for embedded systems.

✅ Download Example


wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.6.84.tar.xz


export ARCH=arm
export CROSS_COMPILE=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-
export PATH=/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin:$PATH

make distclean

make tisdk_am437x-evm-rt_defconfig

make -j8



build time getting error
========================

scripts/gcc-plugins/gcc-common.h
/home/zumi/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/8.3.0/plugin/include/system.h:687:10: fatal error: gmp.h: No such file or directory


✅ Solution 1: Install GMP and Related Packages

Since you are on a host system, you need to install GMP and development headers.

For Ubuntu/Debian:

sudo apt-get install libgmp-dev libmpfr-dev libmpc-dev

✅ Solution 2: Disable GCC Plugins

If you don't need GCC plugins, you can disable them by adding the following to your kernel build configuration:

make menuconfig

    Go to Kernel Hacking → GCC Plugins.

    Disable GCC plugin support.

Alternatively, you can disable it using make directly:

make KCFLAGS=-fno-plugin



u-boot link
=======================================================================================================

https://github.com/u-boot/u-boot/tags?after=v2024.07


install 2025
============
git clone https://source.denx.de/u-boot/u-boot.git
git clone https://github.com/u-boot/u-boot.git


vartion verify cmt
=================
git describe --tags
cat Makefile | grep -i version







==========================================================================================================================================================================================
git docs
========

---------------------
## How to Upload and Download from GitHub using Git and SSH

---------------------
### Install Git

sudo apt update  
sudo apt install git  

---------------------
### Configure Git

git config --global user.name "Abinash"  
git config --global user.email "abinash@zumisolutions.com"  

git config --list

---------------------
### Generate SSH Key

ssh-keygen -t rsa -b 4096 -C "abinash@zumisolutions.com"  

- Press Enter to save the key in ~/.ssh/id_rsa  
- Enter a passphrase for protection (e.g., Abinash@123a)  

---------------------
### Verify Generated Keys

cat ~/.ssh/id_rsa.pub  

Copy the output and add it to your GitHub account:  
- Go to **GitHub → Settings → SSH and GPG Keys → New SSH Key**  
- Paste the copied SSH key  

---------------------
### Test SSH Connection

ssh -T git@github.com  

It will prompt for your GitHub account password and return:  

Hi Abinash204-ai! You've successfully authenticated, but GitHub does not provide shell access.  

---------------------
### Remove Stored Password (If Needed)

git config --global --unset user.password  

---------------------
### List Repositories from GitHub

curl -s https://api.github.com/users/Abinash204-ai/repos | grep -o 'git@[^"\]*'  

---------------------
### Install GitHub CLI

sudo snap install gh  

Follow the instructions to authenticate using an OTP.  

gh auth login

This command will ask whether you want to use SSH or HTTP. Select HTTP, this command will provide an OTP. Press Enter after receiving the OTP. Then, go to the website and enter the OTP to complete the authentication.

---------------------
### Create a New Repository

gh repo create Abinash --public --source=. --remote=origin  

---------------------
### Delete a Repository

gh auth refresh -h github.com -s delete_repo

before we need do give authentication using above cmt
----

gh repo delete Abinash204-ai/new-project --confirm  

---------------------
### Verify Repositories

curl -s https://api.github.com/users/Abinash204-ai/repos | grep -o 'git@[^"\]*'  

---------------------
### Delete a Specific Repository

gh repo delete Abinash204-ai/Abinash --confirm  

---------------------
## Upload to GitHub

---------------------
### Navigate to Your Project Folder

cd ~/Abinash/Laboratory/git/3_Equal_Partition_1GB_nand-store_flash  

---------------------
### Initialize Git

rm -rf .git
git init


git init  

---------------------
### Add Files and Commit

git add .  
git commit -m "Initial project commit"  


git add getting any worning use this :	git rm --cached Abinash

---------------------
### Create Repository Using GitHub CLI

gh repo create 3_Equal_Partition --public --source=. --remote=origin  

---------------------
### Manually Set Remote URL (If Needed)

git remote set-url origin git@github.com:Abinash204-ai/3_Equal_Partition.git  

---------------------
### Push Code

git branch -M main  
git push -u origin main  

---------------------
## Download from GitHub

---------------------
### List Repositories

curl -s https://api.github.com/users/Abinash204-ai/repos | grep -o 'git@[^"\]*'  

---------------------
### Clone a Repository

git clone git@github.com:Abinash204-ai/Abinash.git  

---------------------
## Manage Changes

---------------------
### Check Status

git status  

---------------------
### Stage and Commit Changes

git add .  
git commit -sm "Commit Message"  

---------------------
### Push Changes

git push origin main  

---------------------
### View Commit Logs

git log --oneline  

---------------------
## Revert Changes

---------------------
### Revert to Previous Commit

git reset --hard HEAD^1  

---------------------
### Update Local Repository with Remote Changes

git pull  
git status  
---------------------







